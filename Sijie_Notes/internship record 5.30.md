# internship record 5.30

1. ## abstract

   the idea：resonate and predicate

   目的：根据需求*（有可能精确有可能不精确，不精确是指对于一个输入满足需求的合法输出有多个，注意这里与非单射函数进行区别 e.g. 输入集合{1，3，-2}，需求是输出一个大于0的数，合法输出可以是1也可以是3）*R输入表达尽可能准确和完整的prompt给大模型，让大模型生成一个目标程序（本质是实现这个需求的代码），为此我们需要验证这个目标程序的正确性。

   根据previous work：我们提出了基于一致性（最大等价类划分），基于大模型自己给出的置信度（置信度与正确性关联弱），基于生成断言函数（该断言很可能与目标程序犯同源错误）等方法去验证目标程序的正确性，但是都具有如下的没有解决的问题：

   1.同一类里面很可能所有候选程序都具有**同源错误**，同断言方法，很大可能被误判为“正确”

   2.对于**输入集是无限**的情况无法验证（无法穷尽所有输入）

   3.对于**不精确的需求**，如果只让模型生成实现，你永远不知道它们是不是真的满足了“排序”“不重复”“简短”“添加项目”等语义。因为缺少一个“可执行的、严格的判定标准”，你无法判定哪种输出才算“正确完成需求”。

2. ## resonate如何解决同源错误/what is resonate

   首先我们有一个需求R（这里只讨论解决同源问题暂且不考虑是否精确）我们让大模型根据需求R生成一个目标程序 我们希望通过这个方法来判断这个目标程序是否正确 同时避免同源错误存在而误判的情况 这个目标程序对于每一个x和y生成输出z（实际上可能不止x，y可能包含多个参数，这里是泛化） 此外我们这里会另外生成一族resonators 注意这里不是一个而是多个resonators 而这个共振器族我们是基于R^-1需求生成 **每个共振器对于逆需求尽可能的采用不同的算法并改变了语义（这一步就是解决同源错误的关键）** 也就是说对于上一步我们得到的输出Z以及样本输入y 生成输入x（这里也实现了对于参数的部分逆）接下来就是定义一个共振性质 满足则能说明这个目标程序是正确的 因为此时同源错误可能性很小 不满足我们也能快速找到错误的点

   在进行具体化的过程中我们遇到了问题：

   1. 对于需求R，有着精确和不精确之分，对于一些不精确的需求，本质上来讲是对于一个输入有多个合法的输出，例如对于共振性质

      ```
                                    f(r(f(x, y), y),y) ≈ f(x, y)
      ```

      当输入（x，y）对应多个输出z1，z2，z3时，上述的性质很可能不再成立，但你却不能说这个程序是错误的

   2. 对于无限输入域，这里有两种情况，第一种是对于输入集本身就是无限的，第二种是我们基于逆需求进行构造共振器族时，逆过程得到的输出是无限的。对于前者，问题在于我们无法穷尽所有输入，那么这个性质的验证是不完备的，我们性质的判定不具有说服力，对于后者，r无法还原所有的x，大模型会自行进行让步，比如说对于取值进行截断，得出”好似正确”的结果，影响性质的判定。

3. ## what is predicate

   以下是直接的例子：

   给出需求R：每一位用户类型对应一种价格，用户类型无限，用户类型为1，2，3保证价格不变，其余的用户类型价格上调10

   目标程序：

   ```
   def f(x, y):
       if x in [1, 2, 3]:
           return y
       else:
           return y + 10
   ```

   predicate:

   ```
                            P = (x∈{1,2,3} ∧ z=y) ∨ (x∉{1,2,3} ∧ z=y+10)
   ```

   将predicate用lean4语言表示（形式化）：

   ```
   def P' (x y z : Int) : Prop :=
     (x = 1 ∨ x = 2 ∨ x = 3) ∧ z = y ∨ -- x ∈ {1,2,3} → z = y
     (x ≠ 1 ∧ x ≠ 2 ∧ x ≠ 3) ∧ z = y + 10 -- x ∉ {1,2,3} → z = y+10
   ```

   所以，predicate是通过逻辑表达式（如等式、不等式、集合关系），根据需求R产生的，目的是定义程序或函数的输入输出约束，而这种“约束”我们可以用lean4等形式化语言编写和证明。

4. ##  predicate 如何解决无限输入域的问题

   无限输入域无法实现的本质原因在于我们无法穷尽所有输入或者共振器r无法生成所有可能的输入，无法检验每一种实现的一致性，引入谓词后，我们将需求R和逆需求R^-1中的数学逻辑抽象出来，谓词将“穷举行为验证”转化为“逻辑条件验证”，从而避免了遍历所有输入。

   例如：

   需求R: 给定两个整数 x 和 y，返回它们中较大的那个数。这里输入是无限的 

   谓词P：

   ```lean
   def maxSpec (x y z : Int) : Prop :=
     (z = x ∨ z = y) ∧ z ≥ x ∧ z ≥ y
   ```

   有了谓词后，我们只需验证有限个输入输出是否满足这个谓词，就能验证是否满足这个内在的逻辑，避免验证每一个实现。

5. ## predicate 如何解决不精确需求的问题

   不精确需求本质上是对于同一个输入有多个合法的输出，加入谓词前是验证实现的一致性，加入谓词后，转变为验证他是一个满足谓词的合法输出，即使 f₁(x,y) = z₁, f₂(x,y) = z₂，不同，但只要都满足 p(x,y,zᵢ)，就都是正确实现，避免实现了共振性质中的等号。

6. ## resonate + predicate

   我们现在有自然语言表达的需求R，同时让llm基于R生成了目标程序f，我们的目标是通过此方法验证目标程序f的正确性。同时我们根据需求R生成形式化的谓词p，我们认为谓词p是完全正确的（符合形式化规范且符合需求R的数学逻辑与语义）。

   需求R：给定一个整数列表，返回其中的最大正整数。

   目标程序f：

   ```
   def f(x):
       positive_numbers = [n for n in x if n > 0]
       return max(positive_numbers) if positive_numbers else 0
   ```

   谓词p(lean4语言)：

   ```
   def P (x : List Int) (z : Int) : Bool :=
     match list_max (x.filter (· > 0)) with
     | some m => z = m
     | none   => z = 0 
   ```

   接下来，我们对任意的x由程序f得到输出z，将此输入输出对放入谓词p检验，也就是执行谓词，如果代入的输入输出对没有通过检验，我们可以断定程序f是错误的，但是就算通过了检验，我们却不能断定f是正确的，举个例子：

   需求R：给定一个数组 x，返回其中的一个正数元素

   谓词p

   ```
                               P(x, _, z) := (z ∈ x) ∧ (z > 0)
   ```

   f(硬编码返回3):

   ```
   f2(x, _) = return 3
   ```

   无论带入怎样的输入，这个谓词都成立，但显然f是不对的。

   因此，我们采用resonance，产生逆需求R^-1,以及逆实现f^-1,逆谓词p^-1.

   R^-1:对于某个输出值 z，反推一个合法的输入 x，使得输出 f(x) 会返回 z,如果 z = 0，那么 x 中没有正数；

   如果 z > 0，那么 z 是 x 中最大的正整数。

   f^-1:

   ```
   def f_inv(z, x):
       if z == 0:
           return [n for n in x if n <= 0]
       else:
           return [n for n in x if n <= z] 
   ```

   p^-1:

   ```
   def P_inv (z : Int) (x : List Int) : Bool :=
     match list_max (x.filter (· > 0)) with
     | some m => z = m
     | none   => z = 0
   ```

   通过 f⁻¹(z, x) 反推输入 x，然后使用逆谓词 P⁻¹(z, x) 检查是否反向验证通过,这里和上一部分执行谓词p进行检验的部分需要注意：

   对于具有简单清晰的数学逻辑与结果的输出可以直接采用lean4运行j检验，例如上面的例子：

   ```
   def list_max (xs : List Int) : Option Int :=
     match xs with
     | []      => none
     | x :: xs => some (xs.foldl (λ acc n => if n > acc then n else acc) x)
     
   def f (x : List Int) : Int :=
     match list_max (x.filter (· > 0)) with
     | some m => m
     | none   => 0
     
    def P (x : List Int) (z : Int) : Bool :=
     match list_max (x.filter (· > 0)) with
     | some m => z = m
     | none   => z = 0
    
   def f_inv (z : Int) : List Int :=
     if z ≤ 0 then [-1, -2]  
     else [z, z - 1, -3]  
     
   def P_inv (z : Int) (x : List Int) : Bool :=
     match list_max (x.filter (· > 0)) with
     | some m => z = m
     | none   => z = 0
       
   #eval f [3, -1, 5, 2]  
   #eval P [3, -1, 5, 2] 5  
   #eval P [3, -1, 5, 2] 4  
   
   #eval f_inv 5           
   #eval f (f_inv 5)       
   ```

   但是当输出是自然语言等无法用lean4语言编写，我们也许可以让llm针对谓词p生成前向函数（python）去检验，同理p^-1生成反转算法，也就是执行谓词的方法有多种。

   接下来实现p和p^-1的共振特性：

   ```
                                            P(x,z)⟺P^−1(z,x)
   ```

   ```
   theorem resonance_equiv : ∀ (x : List Int) (z : Int), P x z = P_inv z x := by
     intros x z
     unfold P P_inv
     simp
   ```

   如果每一项通过，我们判定f是正确的。

   

   

   

