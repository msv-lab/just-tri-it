\documentclass[10pt,aspectratio=32]{beamer}

\usepackage{tcolorbox}
\tcbuselibrary{most}
\usepackage{minted}
\usepackage{charter}
\usepackage{cleveref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{fontawesome}
\usepackage{tikz}

\newtheorem{proposition}{Proposition}
\newtheorem{hypothesis}{Hypothesis}


% Define styles for prompt and response
\tcbset{
    prompt/.style={colback=blue!5!white, colframe=blue!75!black, width=\textwidth, boxrule=0.3mm,title=Prompt},
    response/.style={colback=green!5!white, colframe=green!75!black, width=\textwidth, boxrule=0.3mm,title=Response}
}
\tcbset{enhanced,attach boxed title to top left={xshift=-2mm,yshift=-2mm},coltitle=black,boxed title style={size=small,colback=white},left=3pt,right=3pt}

\newtcbox{\highlight}{on line,
    arc=0pt,
    colframe=yellow!50, % Border color
    colback=yellow!50, % Background color
    boxrule=0.0pt, % Border thickness
    boxsep=0pt, % Remove padding inside the box
    left=1pt, right=1pt, top=2pt, bottom=2pt % Minimal margins
}


\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{bibliography item}{\insertbiblabel}
\setbeamertemplate{footline}{
    \leavevmode%
    \hbox{%
      \begin{beamercolorbox}[wd=.8\paperwidth,ht=2.25ex,dp=1ex,left]{title in head/foot}%
        \hspace{0.5cm}MSV Lab @ PKU
      \end{beamercolorbox}%
      \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,right]{title in head/foot}%
        \usebeamercolor[fg]{frame number}\insertframenumber{} / \inserttotalframenumber\hspace{0.5cm}
      \end{beamercolorbox}
    }
    \vskip0pt%
}

% https://tex.stackexchange.com/questions/22252/how-to-typeset-function-restrictions
\newcommand\restr[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace % automatically resize the bar with \right
  #1 % the function
  \littletaller % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}
\newcommand{\littletaller}{\mathchoice{\vphantom{\big|}}{}{}{}}

\title{Reliable Code Generation with LLMs\\ via Resonance Check}
\author{Sergey Mechtaev}
\institute{Peking University}
\date{2025}

\begin{document}

\frame[plain]{\titlepage}

\begin{frame}[fragile]
  \frametitle{Preliminaries: Code Generation}
  \begin{columns}[t]
    \column{0.48\textwidth}
    \begin{itemize}
    \item $R$ are natural language (NL) requirements;
    \item $m$ is an LLM, $m(\cdot \mid R)$ is a distribution of programs;
    \item Programs $p \sim m(\cdot \mid R)$ sampled based on requirements are functions $$A_1 \times \cdots \times A_n \to B$$ where $A_1, \cdots, A_n$ are input domains, $B$ is the output domain.
    \end{itemize}
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
    \begin{tcolorbox}[prompt,title=Prompt]
      Implement a function \mintinline{python}{f(n: int) -> int} that computes the n-th Fibonacci number.
    \end{tcolorbox}
    % Response box
    \begin{tcolorbox}[response]
      \begin{minted}[escapeinside=||]{python}
def f(n: int) -> int:
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
      \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Preliminaries: Specification}
  The semantics of NL requirement $\llbracket \cdot \rrbracket : \mathrm{NL} \to 2^{A_1 \times \cdots \times A_n \times B}$ is a specification implicitly defined by these requirements, e.g. $$\llbracket ``multiple\ two\ numbers" \rrbracket = \{ (2, 2, 4), (2, 3, 6), \cdots \}.$$
  For simplicity, assume that all inputs and outputs are valid and useful:
  \begin{align*}
    &\forall a_1\in A_1,\ \cdots, a_n\in A_n\ \exists b\in B.\ (a_1, \cdots, a_n, b) \in \llbracket R \rrbracket\\
    &\forall b\in B\ \exists a_1\in A_1,\ \cdots, a_n\in A_n.\ (a_1, \cdots, a_n, b) \in \llbracket R \rrbracket
  \end{align*}
  \vspace{-3mm}
  \begin{columns}[t]
    \column{0.48\textwidth}
    A program $p \sim m(\cdot \mid R)$ is \emph{correct} iff
    \begin{align*}
      \forall\ &a_1\in A_1,\ \cdots, a_n\in A_n.\\
      &(a_1, \cdots, a_n, p(a_1, \cdots, a_n)) \in \llbracket R \rrbracket,
    \end{align*}
    denoted as $\llbracket R \rrbracket \vdash p.$ 
    \column{0.48\textwidth}
    It is \emph{incorrect} iff
    \begin{align*}
      \exists &a_1\in A_1,\ \cdots, a_n\in A_n.\\
              &(a_1, \cdots, a_n, p(a_1, \cdots, a_n)) \notin \llbracket R \rrbracket,
    \end{align*}
    denoted as $\llbracket R \rrbracket \nvdash p.$ 
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Exactness of Requirements/Specifications}
  \begin{definition}[Exact Specification]
    A specification is \emph{exact} if it is a function. Otherwise, it is \emph{inexact}.
  \end{definition}
  \begin{example}[Inexact Requirements]
    These requirements permit multiple outputs for the same input:
      \begin{align*}
        \llbracket ``return&\ a\ positive\ element\ of\ a\ given\ set" \rrbracket =\\
        \quad\{\ &(\{1, -1, 3\}, {\color{red} 1}),\\
        \quad&(\{1, -1, 3\}, {\color{red} 3}), \cdots \}.
      \end{align*}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Describing Specifications}

  Assume any specification can be expressed in natural language using $$\llparenthesis \cdot \rrparenthesis : 2^{A_1 \times \cdots \times A_n \times B} \to \mathrm{NL},$$ e.g.
  \begin{align*}
    &\llparenthesis\,\{\,(0, 1), (1, 2), (2, 3), \cdots \,\}\,\rrparenthesis = \\
    &\quad\quad``increment\ a\ given\ number"
      \end{align*}  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reliability of LLM-Generated Code}
  \begin{columns}
    \column{0.48\textwidth}
    LLMs make mistakes, e.g. hallucinate~\cite{liu2024exploring}, which results in incorrect programs.\\[0.3cm]
    \textbf{Challenge}: how to automatically catch mistakes without explicit $\llbracket R \rrbracket$?
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
    \begin{tcolorbox}[prompt,title=Prompt]
        You are given a positive integer array `nums`. Return the total frequencies of elements in `nums` such that those elements all have the maximum frequency.
    \end{tcolorbox}
    % Response box
    \begin{tcolorbox}[response]
      \begin{minted}[escapeinside=||]{python}
def count(nums):
  freq = Counter(nums)
  max = freq.values()
  count = len([
   k for k, v in
   freq.items()
    if v == max
  ])
  return |\highlight{count}| # missing `* max`
      \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Previous Work: Consistency}
  \begin{definition}
    Programs $p_1$ and $p_2$ are equivalent ($p_1 \equiv p_2$) iff $$\forall a_1\in A_1,\cdots,a_n\in A_n.\ p_1(a_1,\cdots,a_n) = p_2(a_1,\cdots,a_n).$$
  \end{definition}
  \textbf{CodeT}~\cite{chen2022codet} partitions samples into equivalence classes:
  \begin{columns}
    \column{0.48\textwidth}
    \begin{center}
  \begin{tikzpicture}[level distance=10mm,sibling distance=5mm]
  \node {$m(\cdot \mid R)$} [grow=down]
    child          { node (p2) {\color{red}$p_1$} }
    child          { node (p2) {\color{red}$p_2$} }
    child          { node {\color{blue}$p_3$} }
    child          { node (p4) {\color{red}$p_4$} }
    child[missing] { node {} }
    child          { node {\color{teal}$p_k$} };
  \end{tikzpicture}
    \end{center}
    \column{0.48\textwidth}
  \begin{align*}
  {\color{red}p_1} &\equiv {\color{red}p_2} \equiv {\color{red}p_4} \equiv \cdots\\
  {\color{blue}p_3} &\equiv \cdots\\
  {\color{teal}p_k} &\equiv \cdots
  \end{align*}
  \end{columns}
  \vspace{2mm}
  Then, it selects a sample, say, $p_1$, if $[p_1]$ is the largest equivalence class.\\[0.2cm]
  \textbf{Limitations:}
  \begin{itemize}
  \item LLMs consistently make the same mistakes.
  \item The method does not work for inexact requirements.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Previous Work: Confidence}
  \begin{columns}
    \column{0.48\textwidth}
    Measure confidence of an LLM response through token probabilities or verbalized self-ask~\cite{spiess2024calibration}.\\[0.3cm]
    \textbf{Problem:} Confidence measures weakly correlate with correctness.
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement a Fibonacci function in Python and print how confident you are about its correctness (from 0\% to 100\%).
      \end{tcolorbox}
      % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b          
        \end{minted}
Confidence: 99\%. The 1\% uncertainty accounts for potential uncaught edge cases.
      \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Previous Work: Assertions}
  \begin{columns}
    \column{0.48\textwidth}
    Sample both programs and assertions specifying the expected output~\cite{key2022toward}, i.e. executable predicates directly capturing $\llbracket R \rrbracket$.\\[0.3cm]
    
    \textbf{Intuition:} for some problems, it is easier to check correctness of an output than to compute it.
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
The function \mintinline{python}{s(l: list) -> list} sorts the list in non-descending order. Create a predicate that checks, for a given l, if s(l) returns a correct output.
    \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def is_sorted_correctly(l: list) -> bool:
    sorted_l = s(l)
    if Counter(l) != Counter(sorted_l):
        return False
    for i in range(len(sorted_l) - 1):
        if sorted_l[i] > sorted_l[i + 1]:
            return False
    return True          
        \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Problems with Assertions}
  \begin{columns}
    \column{0.52\textwidth}
    \begin{itemize}
    \item For some problems, an implementation is the simplest description of the expected output.
    \item Given a function $f:X\to Y$ implementing $R$ and a predicate $p: X \times Y \to \{0,1\}$ implementing $\widetilde{R}$ (requirements for an assertion that checks $R$), we only have a weak guarantee that $$\forall x\in X.\ p(x, f(x))$$ implies $$\llbracket \widetilde{R} \rrbracket\vdash p \Rightarrow \llbracket R \rrbracket\vdash f.$$
    \end{itemize}
    \column{0.46\textwidth}
    {\scriptsize
      % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Function $F(n)$ computes the $n$-th Fibonacci number. Implement a predicate in Python that checks for a given $n$ if the output of $F$ is correct.
    \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def correct_fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a

def is_fib_correct(n, F):
    try:
        return F(n) == |\highlight{correct\_fib(n)}|
    except:
        return False
        \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}{New Idea: Resonance}
  \begin{itemize}
  \item Sample several \emph{resonator} programs with deliberately altered requirements.
  \item Check their \emph{resonance property} that provably holds iff either all programs correctly implement their requirements, or all programs wrongly implement their requirements.
  \item If the programs \emph{resonate}, then they are either correct, or have \emph{sympathetic faults}, i.e. low-probability faults that cancel each other out.
  \end{itemize}
  \begin{definition}
    Let $r_1 \sim m(\cdot \mid R_1), \cdots, r_n \sim m(\cdot \mid R_n)$ be resonators. A hyperproperty $\phi$ over $r_1, \cdots, r_n$ is a resonance property if it holds iff either all programs are correct or all programs are incorrect: $$\phi[r_1, \cdots, r_n] \Leftrightarrow \bigwedge_i \llbracket R_i \rrbracket \vdash r_i \vee \bigwedge_i \llbracket R_i \rrbracket \nvdash r_i.$$
  \end{definition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Consistency is A Trivial Resonance Property}
  \begin{proposition}[Resonance Generalizes Consistency]
    Let $R$ be requirements, and $r_1, r_2 \sim m(\cdot \mid R)$ be resonators generated based on these requirements. Then, the following is a resonance property: $$r_1 \equiv r_2.$$
  \end{proposition}
  \textbf{Problems:}
  \begin{itemize}
  \item sympathetic faults are high-probability, because LLMs consistently make the same mistakes.
  \item likely to fail for correct programs when the requirements are inexact.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Better Resonance Properties}
  To account for different types of specifications, check several resonance properties in the order of raising complexity and generality:\\[0.2cm]
  \begin{itemize}
  \item FOR-INV: Forward function + (Partial) Inverse
  \item FOR-FIB: Forward function + (Partial) Fiber function
  \item COR-FIB: Correspondence function + (Partial) Fiber function
  \item VAL-FIB: Validator function + Its (Partial) Fiber function
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{FOR-INV Resonance Property}
  \begin{definition}[Inverse Specification]
    Let $S\subset A\times B$ be a specification. Its inverse is
    $S^{-1} \triangleq \{(b, a) \mid (b, a) \in S\}.$ Similarly, the inverse of requirements $R$ is $R^{-1} \triangleq \llparenthesis\ \llbracket R \rrbracket^{-1}\rrparenthesis$. For multi-argument functions, the inverse should produce a tuple as the output.
  \end{definition}
  \begin{proposition}[FOR-INV]
    Let $R$ be requirements, $f: A\to B \sim m(\cdot \mid R)$ and $g: B\to A \sim m(\cdot \mid R^{-1})$ be resonators. The following is a resonance property: $$g \circ f \equiv \mathrm{id_A} \wedge f \circ g \equiv \mathrm{id_B}.$$
  \end{proposition}
  \textbf{Hypothesis:} inversion-based resonance reduces sympathetic bugs compared to the standard consistency, because $f$ and $g$ require different algorithms.
  \textbf{Problem:} likely to fail if $\llbracket R \rrbracket$ is not a bijection.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Liberal Resonance Property}
  \textbf{Problem:} it might be too expensive to check the right inverse property $f \circ g \equiv \mathrm{id}_B$ on the entire set $B$.\\[0.2cm]
  \textbf{Idea:} since not all resonators are equally important, we can weaken the property to make it easier to check.\\
  \begin{definition}[Liberal FOR-INV]
    Let $R$ be requirements, $f: A\to B \sim m(\cdot \mid R)$ and $g: B\to A \sim m(\cdot \mid R^{-1})$ be resonators. The left inverse property $$g \circ f \equiv \mathrm{id_A}$$ is not a resonance property since, although it checks $f$, it captures the behavior of $g$ only on the range of $f$. We call it a liberal resonance property.
  \end{definition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Limitations of FOR-INV}
  \begin{columns}[t]
    \column{0.48\textwidth}
    {\scriptsize
    % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement \mintinline{python}{f(i: int) -> int} that returns a number greater than i by at most 2.
      \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def f(i: int) -> int:
  return i+1
        \end{minted}
    \end{tcolorbox}
    }    
    \column{0.48\textwidth}
    {\scriptsize
    % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement \mintinline{python}{g(i: int) -> int} that returns a number smaller than i by at most 2.
      \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def g(i: int) -> int:
  return i-2
        \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
  \vspace{0.5cm}
  Independently generated forward and backward functions for inexact requirements may not match. \textbf{Note:} the generation must be independent to reduce the chance of sympathetic faults.
\end{frame}

\begin{frame}[fragile]
  \frametitle{FOR-FIB Resonance Property}
  \begin{definition}[Fiber Specification]
    Let $S\subset A\times B$ be a specification. Its fiber function specification is $$S^{\succ} \triangleq \Bigl\{ (b, \{ a \mid (a, b)\in S \})\ \Big|\ (\cdot, b) \in S \Bigl\}.$$ Given requirements $R$, the requirements for a fiber function are $R^{\succ} \triangleq \llparenthesis\ \llbracket R \rrbracket^{\succ}\rrparenthesis$.
  \end{definition}
  \begin{proposition}[Liberal FOR-FIB]
   Let $R$ be requirements, $f: A\to B \sim m(\cdot \mid R)$ and $g: B\to 2^A \sim m(\cdot \mid R^{\succ})$ be resonators. The following is a liberal resonance property: $$\forall b \in B.\ f(g(b)) = \{b\}\wedge \forall a \in A.\ a \in g(f(a)),$$ since it checks for the exhaustiveness of fibers only on the range of $f$.
  \end{proposition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Limitations of Inverse and Fiber Resonators}
  \begin{columns}[t]
    \column{0.48\textwidth}
    Inverse functions may enumerate inputs of the forward function.
    {\scriptsize
      % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement a Python function that for a given Fibinacci number n returns its index in the sequence.
    \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def find_fibonacci_index(n):
    if n < 0:
        return -1
    if n == 0:
        return 0
    if n == 1:
        return 1

    a, b = 1, 1
    index = 2
    while b < n:
        a, b = b, a + b
        index += 1
    return index if b == n else -1
        \end{minted}
    \end{tcolorbox}
    }
    \column{0.48\textwidth}
    Hard to compute fibers for multi-arguments functions.
    {\scriptsize
    % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement a Python function that for a boolean 'found' enumerates all pairs of a list and an integer such that the list contains the integer iff the boolean is true.
      \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def enumerate_pairs(found):
  max_list=3
  max_int=3
  pairs = []
  ints = range(max_int + 1)
  for l in range(max_list + 1):
    for lst in product(ints, repeat=l):
      lst = list(lst)
        for num in ints:
          if (num in lst) == found:
            pairs.append(
              (lst.copy(), num))
  return pairs
        \end{minted}
    \end{tcolorbox}
    }    
  \end{columns}
\end{frame}

\begin{frame}{Partial Inverses and Fiber Functions}
  \begin{definition}
    Given a specification $S \subset A_1 \times A_2 \times \cdots \times A_n \times B$, its \emph{partial inversion} w.r.t. the $i$-th argument is a specification $$S^{-1}_i \subset A_1 \times \cdots A_{i-1} \times \mathbf{B} \times A_{i-1} \times \cdots \times A_n \times \mathbf{A_i}$$ s.t. $(a_1, \cdots, a_n, b) \in S$ iff $(a_1, \cdots, a_{i-1}, b, a_{i+1}, \cdots, a_n, a_i) \in S^{-1}_i.$ Partial fiber functions are defined respectfully.
  \end{definition}
  \begin{example}
    Assume a specification is a function $f : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ defined as $f(x, y) = x \mod y.$ A possible partial inverse w.r.t. the first argument is $g(z, y) = y + z$; the partial fiber function is $g(z, y) = \{i*y + z\}_{i\in\mathbb{N}}.$
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{FOR-INV with Partial Inverses}
  \begin{proposition}
    Let $R$ be requirements specifying functions over two arguments, $f \sim m(\cdot \mid R)$ and $g \sim m(\cdot \mid R^{-1}_1)$ be resonators. The following is a liberal resonance property (checks $g$ on a subdomain): $$\forall (x, y,\cdot)\ \in \llbracket R \rrbracket.\ g(f(x,y),y) = x.$$
  \end{proposition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{FOR-FIB with Partial Fiber Functions}
  \begin{proposition}
    Let $R$ be requirements, defining a specification over two arguments, $f \sim m(\cdot \mid R)$ and $g \sim m(\cdot \mid R_1^{\succ})$ be resonators. Then, the following is a liberal resonance property (checks $g$ on a subdomain): $$\forall (x, y,\cdot)\ \in \llbracket R \rrbracket.\ f(g(f(x,y),y), y) = \{f(x,y)\} \wedge x\in g(f(x,y),y).$$
  \end{proposition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Challenge: Inexact Requirements}
  If the requirements are inexact, then the check $f(g(f(x,y),y), y) = \{f(x,y)\}$ may fail. For example, for the problem description\\[0.2cm]
  \begin{quote}
    Implement a function that returns the list of all positive values stored in the nodes of a given graph.
  \end{quote}\\[0.2cm]
  $f$ may assume an implementation that traverses the graph in the depth-first search order, and $g$ may assume an implementation that traverses the graph in the breadth-first search order. Although both are valid solutions, the order of elements in the output list will be different.
\end{frame}

\begin{frame}[fragile]
  \frametitle{COR-FIB Resonance Property}
  \begin{definition}[Correspondence Functions]
    Given a specification $S \subset A_1 \times A_2 \times \cdots \times A_n \times B$, its \emph{correspondence} function specification is $S^{\prec} \subset A_1 \times \cdots \times A_n \times 2^B$ s.t. $$S^{\prec} \triangleq \Bigl\{ (a_1,\cdots, a_n,\ \{ b \mid (a_1,\cdots, a_n, b)\in S \})\ \Big|\ (a_1,\cdots, a_n, \cdot) \in S \Bigl\}.$$ Given $R$, the requirements for a correspondence function are $R^{\prec} \triangleq \llparenthesis\ \llbracket R \rrbracket^{\prec}\rrparenthesis$.
  \end{definition}
  \begin{proposition}[COR-FIB]
    Let $R$ be requirements, $f: A\to 2^B \sim m(\cdot \mid R^{\prec})$ and $g: B\to 2^A \sim m(\cdot \mid R^{\succ})$ be resonators. The following is a resonance property:
    \begin{align*}
      &\forall b \in B.\ (g(b) = g(f(g(b))) \wedge b \in f(g(b)) \wedge \forall a', a''\in g(b).\ f(a') = f(a''))\ \wedge\\ &\forall a \in A.\ (f(a) = f(g(f(a))) \wedge a \in g(f(a)) \wedge \forall b', b''\in f(a).\ g(b') = g(b'')).
    \end{align*}
  \end{proposition}
  \vspace{-3mm}
  \textbf{Note:} this property assumes that there is a one-to-one correspondence between equivalence classes of inputs and outputs.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Challenge: Infinite Images and Fibers}
The introduced fiber and correspondence functions have to be exhaustive. This is often impossible, e.g. inverting \texttt{contains(list, element)}:
    {\scriptsize
      % Prompt box
    \begin{tcolorbox}[prompt,title=Prompt]
Write a Python function that, given a list if integers, and a boolean value "include", returns all elements that are in the list if "include" is true, and all possible elements that are not in the list if "include" is false.
    \end{tcolorbox}
    % Response box
    \begin{tcolorbox}[response]
      \begin{minted}[escapeinside=||]{python}
def filter_elements(lst, include):
    if include:
        return lst.copy()
    else:
        if not lst:
            return []
        minval = min(lst)
        maxval = max(lst)
        # DeepSeek-v3 assumes a subset of input domain:
        possible_elements = |\highlight{set(range(minval, maxval + 1))}|
        elements_not_in_list = list(possible_elements - set(lst))
        return elements_not_in_list
      \end{minted}
    \end{tcolorbox}
    }
\end{frame}

\begin{frame}[fragile]
  \frametitle{VAL-FIB Resonance Property}
  \begin{definition}[Validator Functions]
    Given a specification $S \subset A_1 \times A_2 \times \cdots \times A_n \times B$, its \emph{validator} function specification is $\widetilde{S} \subset A_1 \times \cdots \times A_n \times B \times \{0,1\}$ s.t.
    \begin{align*}
      \widetilde{S} \triangleq &\{ (a_1,\cdots, a_n, b, 1)\ |\ (a_1,\cdots, a_n, b) \in S \}\ \wedge\\
      &\{ (a_1,\cdots, a_n, b, 0)\ |\ (a_1,\cdots, a_n, b) \notin S \}.
    \end{align*}
    Given $R$, the requirements for a validator function are $\widetilde{R} \triangleq \llparenthesis\ \widetilde{\llbracket R \rrbracket}\ \rrparenthesis$.
  \end{definition}
  \begin{definition}[VAL-FIB]
    VAL-FIB for $R$ is FOR-FIB for $\widetilde{R}$.
  \end{definition}
  \vspace{0.4cm}
  \textbf{Note}: this is for infinite images, but small input domains.
\end{frame}

\begin{frame}[allowframebreaks]{References}
  \bibliographystyle{unsrt}
  \bibliography{bibliography.bib}
\end{frame}

\end{document}
