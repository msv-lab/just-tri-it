\documentclass[10pt,aspectratio=32]{beamer}

\usepackage{tcolorbox}
\tcbuselibrary{most}
\usepackage{minted}
\usepackage{charter}
\usepackage{cleveref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{fontawesome}
\usepackage{tikz}

\newtheorem{proposition}{Proposition}
\newtheorem{hypothesis}{Hypothesis}


% Define styles for prompt and response
\tcbset{
    prompt/.style={colback=blue!5!white, colframe=blue!75!black, width=\textwidth, boxrule=0.3mm,title=Prompt},
    response/.style={colback=green!5!white, colframe=green!75!black, width=\textwidth, boxrule=0.3mm,title=Response}
}
\tcbset{enhanced,attach boxed title to top left={xshift=-2mm,yshift=-2mm},coltitle=black,boxed title style={size=small,colback=white},left=3pt,right=3pt}

\newtcbox{\highlight}{on line,
    arc=0pt,
    colframe=yellow!50, % Border color
    colback=yellow!50, % Background color
    boxrule=0.0pt, % Border thickness
    boxsep=0pt, % Remove padding inside the box
    left=1pt, right=1pt, top=2pt, bottom=2pt % Minimal margins
}


\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{bibliography item}{\insertbiblabel}
\setbeamertemplate{footline}{
    \leavevmode%
    \hbox{%
      \begin{beamercolorbox}[wd=.8\paperwidth,ht=2.25ex,dp=1ex,left]{title in head/foot}%
        \hspace{0.5cm}MSV Lab @ PKU
      \end{beamercolorbox}%
      \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,right]{title in head/foot}%
        \usebeamercolor[fg]{frame number}\insertframenumber{} / \inserttotalframenumber\hspace{0.5cm}
      \end{beamercolorbox}
    }
    \vskip0pt%
}

\title{Does LLM-Generated Code Resonate?}
\author{Sergey Mechtaev}
\institute{Peking University}
\date{2025}

\begin{document}

\frame[plain]{\titlepage}

\begin{frame}[fragile]
  \frametitle{Preliminaries: Code Generation}
  \begin{columns}[t]
    \column{0.48\textwidth}
    \begin{itemize}
    \item $R$ are natural language (NL) requirements;
    \item $m$ is an LLM, $m(\cdot \mid R)$ is a distribution of programs;
    \item Programs $p \sim m(\cdot \mid R)$ sampled based on requirements are functions $$A_1 \times \cdots \times A_n \to B$$ where $A_1, \cdots, A_n$ are input domains, $B$ is the output domain.
    \end{itemize}
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
    \begin{tcolorbox}[prompt,title=Prompt]
      Implement a function \mintinline{python}{f(n: int) -> int} that computes the n-th Fibonacci number.
    \end{tcolorbox}
    % Response box
    \begin{tcolorbox}[response]
      \begin{minted}[escapeinside=||]{python}
def f(n: int) -> int:
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
      \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Preliminaries: Specification}
  The semantics of NL requirement $\llbracket \cdot \rrbracket : \mathrm{NL} \to 2^{A_1 \times \cdots \times A_n \times B}$ is a specification implicitly defined by these requirements, e.g.
  \begin{align*}
    &\llbracket ``the\ division\ function" \rrbracket =\\
    &\quad\{ (2, 2, 1), (6, 2, 3), \cdots \}.
  \end{align*}  
  \begin{columns}[t]
    \column{0.48\textwidth}
    A program $p \sim m(\cdot \mid R)$ is \emph{correct} iff
    \begin{align*}
      \forall\ &a_1\in A_1,\ \cdots, a_n\in A_n.\\
      &(a_1^i, \cdots, a_n^i, p(a_1^i, \cdots, a_n^i)) \in \llbracket R \rrbracket,
    \end{align*}
    denoted as $\llbracket R \rrbracket \vdash p.$ 
    \column{0.48\textwidth}
    It is \emph{incorrect} iff
    \begin{align*}
      \exists &a_1\in A_1,\ \cdots, a_n\in A_n.\\
              &(a_1, \cdots, a_n, p(a_1, \cdots, a_n)) \notin \llbracket R \rrbracket,
    \end{align*}
    denoted as $\llbracket R \rrbracket \nvdash p.$ 
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Exactness of Requirements/Specifications}
  \begin{definition}[Exact Specification]
    A specification is \emph{exact} if it is a function. Otherwise, it is \emph{inexact}.
  \end{definition}
  \begin{example}[Inexact Requirements]
    These requirements permit multiple outputs for the same input:
      \begin{align*}
        \llbracket ``return&\ a\ positive\ element\ of\ a\ given\ set" \rrbracket =\\
        \quad\{\ &(\{1, -1, 3\}, {\color{red} 1}),\\
        \quad&(\{1, -1, 3\}, {\color{red} 3}), \cdots \}.
      \end{align*}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Describing Specifications}

  Assume a specification can be expressed in natural language using $$\llparenthesis \cdot \rrparenthesis : 2^{A_1 \times \cdots \times A_n \times B} \to \mathrm{NL},$$ e.g.
  \begin{align*}
    &\llparenthesis\,\{\,(0, 1), (1, 2), (2, 3), \cdots \,\}\,\rrparenthesis = \\
    &\quad\quad``increment\ a\ given\ number"
      \end{align*}  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reliability of LLM-Generated Code}
  \begin{columns}
    \column{0.48\textwidth}
    LLMs make mistakes, e.g. hallucinate~\cite{liu2024exploring}, which results in incorrect programs.\\[0.3cm]
    \textbf{Challenge}: how to automatically catch mistakes without explicit $\llbracket R \rrbracket$?
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
    \begin{tcolorbox}[prompt,title=Prompt]
        You are given a positive integer array `nums`. Return the total frequencies of elements in `nums` such that those elements all have the maximum frequency.
    \end{tcolorbox}
    % Response box
    \begin{tcolorbox}[response]
      \begin{minted}[escapeinside=||]{python}
def count(nums):
  freq = Counter(nums)
  max = freq.values()
  count = len([
   k for k, v in
   freq.items()
    if v == max
  ])
  return |\highlight{count}| # missing `* max`
      \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Previous Work: Consistency-Based}
  \begin{definition}
    Programs $p_1$ and $p_2$ are equivalent ($p_1 \equiv p_2$) iff $$\forall a_1\in A_1,\cdots,a_n\in A_n.\ p_1(a_1,\cdots,a_n) = p_2(a_1,\cdots,a_n).$$
  \end{definition}
  \textbf{CodeT}~\cite{chen2022codet} partitions samples into equivalence classes:
  \begin{columns}
    \column{0.48\textwidth}
    \begin{center}
  \begin{tikzpicture}[level distance=10mm,sibling distance=5mm]
  \node {$m(\cdot \mid R)$} [grow=down]
    child          { node (p2) {\color{red}$p_1$} }
    child          { node (p2) {\color{red}$p_2$} }
    child          { node {\color{blue}$p_3$} }
    child          { node (p4) {\color{red}$p_4$} }
    child[missing] { node {} }
    child          { node {\color{teal}$p_k$} };
  \end{tikzpicture}
    \end{center}
    \column{0.48\textwidth}
  \begin{align*}
  {\color{red}p_1} &\equiv {\color{red}p_2} \equiv {\color{red}p_4} \equiv \cdots\\
  {\color{blue}p_3} &\equiv \cdots\\
  {\color{teal}p_k} &\equiv \cdots
  \end{align*}
  \end{columns}
  \vspace{2mm}
  Then, it selects a sample, say, $p_1$, if $[p_1]$ is the largest equivalence class.\\[0.2cm]
  \textbf{Limitations:}
  \begin{itemize}
  \item LLMs consistently make the same mistakes.
  \item The method does not work for inexact requirements.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Previous Work: Confidence-Based}
  \begin{columns}
    \column{0.48\textwidth}
    Measure confidence of an LLM response through token probabilities or verbalized self-ask~\cite{spiess2024calibration}.\\[0.3cm]
    \textbf{Problem:} Confidence measures weakly correlate with correctness.
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement a Fibonacci function in Python and print how confident you are about its correctness (from 0\% to 100\%).
      \end{tcolorbox}
      % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b          
        \end{minted}
Confidence: 99\%. The 1\% uncertainty accounts for potential uncaught edge cases.
      \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Previous Work: Assertion-Based}
  \begin{columns}
    \column{0.48\textwidth}
    Sample both programs and assertions specifying the expected output~\cite{key2022toward}.\\[0.3cm]
    \textbf{Problem:} an implementation may be the shortest description of the expected output, therefore the assertion may contain the same bugs.
    \column{0.48\textwidth}
    {\scriptsize
      % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Function $F(n)$ computes the $n$-th Fibonacci number. Implement a predicate in Python that checks for a given $n$ if the output of $F$ is correct.
    \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def correct_fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a

def is_fib_correct(n, F):
    try:
        return F(n) == |\highlight{correct\_fib(n)}|
    except:
        return False
        \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}{New Idea: Resonance}
  \begin{itemize}
  \item Sample several \emph{resonator} programs with deliberately altered requirements.
  \item Check their \emph{resonance property} that provably holds iff either all programs correctly implement their requirements, or all programs wrongly implement their requirements.
  \item If the programs \emph{resonate}, then they are either correct, or have \emph{sympathetic faults}, i.e. low-probability faults that cancel each other out.
  \end{itemize}
  \begin{definition}
    Let $r_1 \sim m(\cdot \mid R_1), \cdots, r_n \sim m(\cdot \mid R_n)$ be resonators. A hyperproperty $\phi$ over $r_1, \cdots, r_n$ is a resonance property iff it holds only when either all programs are correct or all programs are incorrect: $$\phi[r_1, \cdots, r_n] \Leftrightarrow \bigwedge_i \llbracket R_i \rrbracket \vdash r_i \vee \bigwedge_i \llbracket R_i \rrbracket \nvdash r_i.$$
  \end{definition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Consistency is Trivial Resonance Property}
  \begin{proposition}[Resonance Generalizes Consistency]
    Let $R$ be exact requirements, and $r_1, r_2 \sim m(\cdot \mid R)$ be resonators generated based on these requirements. Then, the following is a resonance property: $$r_1 \equiv r_2.$$
  \end{proposition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Inversion-Based Resonance Properties}
  \begin{proposition}[Inversion-Based Resonance]
    Let $R$ be exact requirements, such that $\llbracket R \rrbracket$ is a bijection, $f \sim m(\cdot \mid R)$ and $g \sim m(\cdot \mid R^{-1})$ be resonators, and $$R^{-1} \triangleq \llparenthesis\, \{(y, x) \mid (x, y) \in \llbracket R \rrbracket\}\,\rrparenthesis$$ are inverse requirements. Then, the following is a resonance property: $$f \circ g \equiv \mathrm{id}.$$
  \end{proposition}
  \textbf{Hypothesis:} inversion-based resonance reduces sympathetic bugs compared to the standard consistency, because $f$ and $g$ require different algorithms.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Inversion-Based Resonance (Non-Bijective Case)}
  \begin{proposition}
   Let $R$ be exact requirements, $f \sim m(\cdot \mid R)$ and $g \sim m(\cdot \mid \llparenthesis\,\mathrm{Inv}\,\rrparenthesis)$ be resonators where $$\mathrm{Inv} \triangleq \Bigl\{ (y, \{ x \mid (x, y)\in \llbracket R \rrbracket \})\ \Big|\ (\cdot, y) \in \llbracket R \rrbracket \Bigl\}$$ specifies to return all inputs that would produce a given output according to the original requirements. Then, the following is a resonance property: $$\forall (\cdot, y) \in \llbracket R \rrbracket.\ f(g(y)) = \{y\}\wedge \forall (x, \cdot) \in \llbracket R \rrbracket.\ x \in g(f(x)).$$
  \end{proposition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Limitations of Inversion-Based Resonators}
  \begin{columns}[t]
    \column{0.48\textwidth}
    Large or infinite preimages.
    {\scriptsize
    % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement a Python function that for a boolean 'found' enumerates all pairs of a list and an integer such that the list contains the integer iff the boolean is true.
      \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def enumerate_pairs(found):
  max_list=3
  max_int=3
  pairs = []
  ints = range(max_int + 1)
  for l in range(max_list + 1):
    for lst in product(ints, repeat=l):
      lst = list(lst)
        for num in ints:
          if (num in lst) == found:
            pairs.append(
              (lst.copy(), num))
  return pairs
        \end{minted}
    \end{tcolorbox}
    }    
    \column{0.48\textwidth}
    Implemented by enumerating inputs of the forward function.
    {\scriptsize
      % Prompt box
      \begin{tcolorbox}[prompt,title=Prompt]
Implement a Python function that for a given Fibinacci number n returns its index in the sequence.
    \end{tcolorbox}
    % Response box
      \begin{tcolorbox}[response]
        \begin{minted}[escapeinside=||]{python}
def find_fibonacci_index(n):
    if n < 0:
        return -1
    if n == 0:
        return 0
    if n == 1:
        return 1

    a, b = 1, 1
    index = 2
    while b < n:
        a, b = b, a + b
        index += 1
    return index if b == n else -1
        \end{minted}
    \end{tcolorbox}
    }
  \end{columns}
\end{frame}

\begin{frame}{Partial Inversion}
  \begin{definition}
    Given a specification $S \subset A_1 \times A_2 \times \cdots \times A_n \times B$, its \emph{partial inversion} w.r.t. the $i$-th argument is a specification $$S^{-1}_i \subset A_1 \times \cdots A_{i-1} \times \mathbf{B} \times A_{i-1} \times \cdots \times A_n \times \mathbf{A_i}$$ s.t. $(a_1, \cdots, a_n, b) \in S$ iff $(a_1, \cdots, a_{i-1}, b, a_{i+1}, \cdots, a_n, a_i) \in S^{-1}_i.$
  \end{definition}
  \begin{example}
    Assume a specification is a function $f : \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ defined as $f(x, y) = x \mod y.$ Its partial inverse w.r.t. the first argument is $g(z, y) = \{i*y + z\}_{i\in\mathbb{N}}.$
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Partial Inversion Based Resonance (Bijective Case)}
  \begin{proposition}
    Let $R$ be exact requirements, defining a bijective specification over two arguments, $f \sim m(\cdot \mid R)$ and $g \sim m(\cdot \mid \llparenthesis\, \llbracket R \rrbracket^{-1}_1 \,\rrparenthesis)$ be resonators. Then, the following is a resonance property: $$\forall (x, y,\cdot)\ \in \llbracket R \rrbracket.\ g(f(x,y),y) = x.$$
  \end{proposition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Partial Inversion Based Resonance (Non-Bijective Case)}
  \begin{proposition}
    Let $R$ be exact requirements, defining a specification over two arguments, $f \sim m(\cdot \mid R)$ and $g \sim m(\cdot \mid \llparenthesis\,\mathrm{Inv}_1\,\rrparenthesis)$ be resonators where $$\mathrm{Inv}_1 \triangleq \Bigl\{ (z, y, \{ x \mid (x, y, z)\in \llbracket R \rrbracket \})\ \Big|\ (\cdot, y, z) \in \llbracket R \rrbracket \Bigl\}$$ specifies to return all values of the first arguments that would produce a given output when used with a given second argument according to the original requirements. Then, the following is a resonance property: $$\forall (x, y,\cdot)\ \in \llbracket R \rrbracket.\ f(g(f(x,y),y), y) = \{f(x,y)\} \wedge x\in g(f(x,y),y).$$
  \end{proposition}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Challenge: Infinite Input Domains}
The introduced partial inversion has to return all possible inputs producing a given output, otherwise the check $x\in g(f(x,y),y)$ will fail. Such inversion is often impossible to implement, e.g. inverting \texttt{contains(list, element)}:
    {\scriptsize
      % Prompt box
    \begin{tcolorbox}[prompt,title=Prompt]
Write a Python function that, given a list if integers, and a boolean value "include", returns all elements that are in the list if "include" is true, and all possible elements that are not in the list if "include" is false.
    \end{tcolorbox}
    % Response box
    \begin{tcolorbox}[response]
      \begin{minted}[escapeinside=||]{python}
def filter_elements(lst, include):
    if include:
        return lst.copy()
    else:
        if not lst:
            return []
        minval = min(lst)
        maxval = max(lst)
        # DeepSeek-v3 assumes a subset of input domain:
        possible_elements = |\highlight{set(range(minval, maxval + 1))}|
        elements_not_in_list = list(possible_elements - set(lst))
        return elements_not_in_list
      \end{minted}
    \end{tcolorbox}
    }
\end{frame}


\begin{frame}[fragile]
  \frametitle{Solution 1: Explicitly Restrict The Domain}
    {\scriptsize
      % Prompt box
    \begin{tcolorbox}[prompt,title=Prompt]
Write a Python function that, given a list if integers, and a boolean value "include", returns all elements that are in the list if "include" is true, and all possible elements \highlight{between -1000 and 1000} that are not in the list if "include" is false.
    \end{tcolorbox}
    % Response box
    \begin{tcolorbox}[response]
      \begin{minted}[escapeinside=||]{python}
def filter_elements(int_list, include):
    possible_integers = set(range(-1000, 1001))

    if include:
        return int_list
    else:
        missing_integers = list(possible_integers - set(int_list))
        return missing_integers
      \end{minted}
    \end{tcolorbox}
    }
\end{frame}

\begin{frame}{Partial Inversion with Restricted Domain}
  \begin{definition}
    Given a specification $S \subset A_1 \times A_2 \times \cdots \times A_n \times B$, its \emph{partial inversion} w.r.t. the $i$-th argument restricted to a subdomain $D \subset A_i$ is a specification $$S^{-1}_{i,D} \subset A_1 \times \cdots A_{i-1} \times \mathbf{B} \times A_{i-1} \times \cdots \times A_n \times \mathbf{D}$$ s.t. $(a_1, \cdots, a_n, b) \in S \wedge a_i\in D$ iff $(a_1, \cdots, a_{i-1}, b, a_{i+1}, \cdots, a_n, a_i) \in S^{-1}_{i,D}.$
  \end{definition}
  \vspace{1cm}
  Note: the resonance property will be checked only on the subdomain $D$.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Challenge: Inexact Requirements}
  If the requirements are inexact, then the check $f(g(f(x,y),y), y) = \{f(x,y)\}$ may fail. For example, for the problem description\\[0.2cm]
  \begin{quote}
    Implement a function that returns the list of all positive values stored in the nodes of a given graph.
  \end{quote}\\[0.2cm]
  $f$ may assume an implementation that traverses the graph in the depth-first search order, and $g$ may assume an implementation that traverses the graph in the breadth-first search order. Although both are valid solutions, the order of elements in the output list will be different.
\end{frame}

\begin{frame}[allowframebreaks]{References}
  \bibliographystyle{unsrt}
  \bibliography{bibliography.bib}
\end{frame}

\end{document}
