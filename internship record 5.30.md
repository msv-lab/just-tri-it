# internship record 5.30

1. ## abstract

   the idea：resonate and predicate

   目的：根据需求*（有可能精确有可能不精确，不精确是指对于一个输入满足需求的合法输出有多个，注意这里与非单射函数进行区别 e.g. 输入集合{1，3，-2}，需求是输出一个大于0的数，合法输出可以是1也可以是3）*R输入表达尽可能准确和完整的prompt给大模型，让大模型生成一个目标程序（本质是实现这个需求的代码），为此我们需要验证这个目标程序的正确性。

   根据previous work：我们提出了基于一致性（最大等价类划分），基于大模型自己给出的置信度（置信度与正确性关联弱），基于生成断言函数（该断言很可能与目标程序犯同源错误）等方法去验证目标程序的正确性，但是都具有如下的没有解决的问题：

   1.同一类里面很可能所有候选程序都具有**同源错误**，同断言方法，很大可能被误判为“正确”

   2.对于**输入集是无限**的情况无法验证（无法穷尽所有输入）

   3.对于**不精确的需求**，如果只让模型生成实现，你永远不知道它们是不是真的满足了“排序”“不重复”“简短”“添加项目”等语义。因为缺少一个“可执行的、严格的判定标准”，你无法判定哪种输出才算“正确完成需求”。

2. ## resonate如何解决同源错误/what is resonate

   首先我们有一个需求R（这里只讨论解决同源问题暂且不考虑是否精确）我们让大模型根据需求R生成一个目标程序 我们希望通过这个方法来判断这个目标程序是否正确 同时避免同源错误存在而误判的情况 这个目标程序对于每一个x和y生成输出z（实际上可能不止x，y可能包含多个参数，这里是泛化） 此外我们这里会另外生成一族resonators 注意这里不是一个而是多个resonators 而这个共振器族我们是基于R^-1需求生成 **每个共振器对于逆需求尽可能的采用不同的算法并改变了语义（这一步就是解决同源错误的关键）** 也就是说对于上一步我们得到的输出Z以及样本输入y 生成输入x（这里也实现了对于参数的部分逆）接下来就是定义一个共振性质 满足则能说明这个目标程序是正确的 因为此时同源错误可能性很小 不满足我们也能快速找到错误的点

   在进行具体化的过程中我们遇到了问题：

   1. 对于需求R，有着精确和不精确之分，对于一些不精确的需求，本质上来讲是对于一个输入有多个合法的输出，例如对于共振性质

      ```
                                    f(r(f(x, y), y),y) ≈ f(x, y)
      ```

      当输入（x，y）对应多个输出z1，z2，z3时，上述的性质很可能不再成立，但你却不能说这个程序是错误的

   2. 对于无限输入域，这里有两种情况，第一种是对于输入集本身就是无限的，第二种是我们基于逆需求进行构造共振器族时，逆过程得到的输出是无限的。对于前者，问题在于我们无法穷尽所有输入，那么这个性质的验证是不完备的，我们性质的判定不具有说服力，对于后者，r无法还原所有的x，大模型会自行进行让步，比如说对于取值进行截断，得出”好似正确”的结果，影响性质的判定。

3. ## what is predicate

   以下是直接的例子：

   给出需求R：每一位用户类型对应一种价格，用户类型无限，用户类型为1，2，3保证价格不变，其余的用户类型价格上调10

   目标程序：

   ```
   def f(x, y):
       if x in [1, 2, 3]:
           return y
       else:
           return y + 10
   ```

   predicate:

   ```
                            P = (x∈{1,2,3} ∧ z=y) ∨ (x∉{1,2,3} ∧ z=y+10)
   ```

   将predicate用lean4语言表示（形式化）：

   ```
   def P' (x y z : Int) : Prop :=
     (x = 1 ∨ x = 2 ∨ x = 3) ∧ z = y ∨ -- x ∈ {1,2,3} → z = y
     (x ≠ 1 ∧ x ≠ 2 ∧ x ≠ 3) ∧ z = y + 10 -- x ∉ {1,2,3} → z = y+10
   
   ```

   所以，predicate是通过逻辑表达式（如等式、不等式、集合关系），根据需求R产生的，目的是定义程序或函数的输入输出约束，而这种“约束”我们可以用lean4等形式化语言编写和证明。

4. ##  predicate 如何解决无线输入域的问题

   

5. ## predicate 如何解决不精确需求的问题

6. ## 与原来方法对比 区别在哪里

7. ## 我们需要做的具体工作

8. ## 实际的例子

   

   

