# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Check for invalid inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    if any(not (-10**6 <= num <= 10**6) for num in nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # The subarrays must be non-overlapping and of size x
    # The total number of possible starting positions for a subarray of size x is n - x + 1
    # But we need to select k non-overlapping subarrays
    
    # The approach is to consider all possible groups of k non-overlapping subarrays of size x
    # For each group, calculate the cost to make all elements in each subarray equal
    # Then find the group with the minimal total cost
    
    # The challenge is to efficiently find the k non-overlapping subarrays with the minimal total cost
    
    # Precompute the cost for each possible subarray of size x
    # The cost for subarray starting at i (0-based) is the sum of absolute differences between each element and the median
    # The median minimizes the sum of absolute deviations
    
    # Precompute all possible subarrays and their costs
    subarray_costs = []
    for i in range(n - x + 1):
        sub = nums[i:i+x]
        sub_sorted = sorted(sub)
        median = sub_sorted[x // 2]  # median for even x is the lower one (consistent with example 2)
        cost = sum(abs(num - median) for num in sub)
        subarray_costs.append((i, cost))
    
    # Now, the problem reduces to selecting k non-overlapping subarrays with minimal total cost
    # The subarrays cannot overlap, i.e., for two subarrays starting at i and j, |i - j| >= x
    
    # This is similar to the problem of selecting k non-overlapping intervals with minimal sum
    # We can use dynamic programming to solve this
    
    # Initialize DP table: dp[i][j] represents the minimal cost to select j subarrays up to index i
    # But with n up to 1e5 and k up to 15, a 2D DP is not feasible
    
    # Instead, use a priority queue approach to select the top k non-overlapping subarrays with minimal cost
    # This is similar to the problem of scheduling non-overlapping intervals with maximum/minimum sum
    
    # We can use a max-heap (or min-heap with negative costs) to keep track of the best options
    
    # The idea is to first sort all subarrays by their starting index, then use a greedy approach with a heap
    
    # Sort the subarrays by their starting index (already sorted since we process them in order)
    
    # Now, we need to select k non-overlapping subarrays with minimal total cost
    # We can model this as a graph where each node represents a subarray, and edges connect to non-overlapping subarrays
    # Then, use Dijkstra's algorithm to find the path with minimal cost that includes k nodes
    
    # Alternatively, use a dynamic programming approach with a heap
    
    # Let's implement a DP approach where dp[m] represents the minimal cost to select m subarrays
    # and the last subarray ends before a certain index
    
    # Initialize a list to keep track of the best costs for each number of subarrays
    # We'll use a list of heaps, where heap[m] contains tuples of (total_cost, last_end_index)
    
    # Initialize the heap for 0 subarrays
    heaps = [[] for _ in range(k + 1)]
    heapq.heappush(heaps[0], (0, -x))  # cost 0, last end index is -x (so first subarray can start at 0)
    
    for i, cost in subarray_costs:
        start = i
        end = i + x - 1
        for m in range(k - 1, -1, -1):
            if heaps[m]:
                current_cost, last_end = heaps[m][0]
                if last_end < start:
                    new_cost = current_cost + cost
                    new_last_end = end
                    heapq.heappush(heaps[m + 1], (new_cost, new_last_end))
    
    # After processing all subarrays, the minimal cost for k subarrays is the minimal in heaps[k]
    if not heaps[k]:
        raise ValueError("No valid solution found")  # though constraints say k*x <= n, so there should be a solution
    
    min_cost = min(item[0] for item in heaps[k])
    return min_cost
