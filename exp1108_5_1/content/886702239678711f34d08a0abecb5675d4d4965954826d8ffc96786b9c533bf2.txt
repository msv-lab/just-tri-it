# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric constraint: houses at distance i from start and end must have different colors
    # This means for position i, it cannot have same color as position n-1-i
    
    # We'll use dynamic programming where dp[i][c] represents min cost for first i+1 houses
    # with house i having color c, while satisfying all constraints
    
    # But due to the symmetric constraint, we need to consider pairs (i, n-1-i) together
    
    # Initialize DP for the first half of houses
    # We'll process pairs (i, n-1-i) together
    
    # For each symmetric pair (i, j) where j = n-1-i, we need to choose colors c_i and c_j
    # such that c_i != c_j (symmetric constraint) and adjacent houses have different colors
    
    # We can process the array in pairs and track the minimum costs
    
    # Special handling for the middle pair when n is even
    if n == 2:
        # Only two houses, they must have different colors
        min_cost = float('inf')
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:
                    min_cost = min(min_cost, cost[0][c1] + cost[1][c2])
        return min_cost
    
    # For n > 2, we need to consider both adjacent and symmetric constraints
    # We'll use DP where state tracks colors of current symmetric pair
    
    # Initialize DP table
    # dp[i][c1][c2] would be too expensive, so we need a more efficient approach
    
    # Let's process the array from both ends towards the middle
    # For each symmetric pair (i, n-1-i), we need to choose colors that satisfy:
    # 1. color_i != color_{i-1} (if i > 0)
    # 2. color_{n-1-i} != color_{n-i} (if n-1-i < n-1)  
    # 3. color_i != color_{n-1-i}
    
    # We can use a DP that tracks the minimum cost for the first k pairs
    # with the last color chosen for the left side and right side
    
    # Let left = i, right = n-1-i
    # We'll iterate i from 0 to n/2-1
    
    # Initialize for the first pair (i=0, right=n-1)
    dp = []
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp.append((c1, c2, cost[0][c1] + cost[n-1][c2]))
    
    # Process remaining pairs
    for i in range(1, n//2):
        new_dp = []
        left_idx = i
        right_idx = n-1-i
        
        for prev_c1, prev_c2, prev_cost in dp:
            for c1 in range(3):
                if c1 != prev_c1:  # Adjacent constraint for left side
                    for c2 in range(3):
                        if c2 != prev_c2 and c1 != c2:  # Adjacent for right + symmetric
                            new_cost = prev_cost + cost[left_idx][c1] + cost[right_idx][c2]
                            new_dp.append((c1, c2, new_cost))
        
        # Keep only the best options to avoid state explosion
        # For each color combination, keep only the minimum cost
        best = {}
        for c1, c2, cost_val in new_dp:
            key = (c1, c2)
            if key not in best or cost_val < best[key]:
                best[key] = cost_val
        
        dp = [(c1, c2, cost_val) for (c1, c2), cost_val in best.items()]
    
    # Find minimum cost in the final state
    min_total = float('inf')
    for _, _, total_cost in dp:
        min_total = min(min_total, total_cost)
    
    return min_total
