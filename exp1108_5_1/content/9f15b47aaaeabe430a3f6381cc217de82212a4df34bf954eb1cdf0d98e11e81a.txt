# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if c < 0 or c > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also, adjacent houses cannot have the same color
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs where the i-th pair has colors c1 and c2
    # However, with n up to 10^5, we need a more efficient approach
    
    # Instead, we can process pairs independently and track the best combinations
    
    total_cost = 0
    
    for i in range(n // 2):
        j = n - 1 - i  # symmetric house
        
        # For houses i and j, we need to choose different colors
        # Also, if i > 0, house i cannot have same color as house i-1
        # And house j cannot have same color as house j+1 (which is symmetric to house i-1)
        
        if i == 0:
            # First pair - just minimize cost with different colors
            min_cost = float('inf')
            for c1 in range(3):
                for c2 in range(3):
                    if c1 != c2:
                        min_cost = min(min_cost, cost[i][c1] + cost[j][c2])
            total_cost += min_cost
        else:
            # For subsequent pairs, we need to consider constraints from previous pair
            # We'll find the best color combination for current pair that satisfies:
            # 1. c1 != c2 (symmetric houses different)
            # 2. c1 != prev_c1 (adjacent houses different for house i)
            # 3. c2 != prev_c2 (adjacent houses different for house j)
            
            # We need to track the best combinations from previous iteration
            # Let's store all valid (c1, c2) pairs from previous iteration with their costs
            prev_valid = []
            for prev_c1 in range(3):
                for prev_c2 in range(3):
                    if prev_c1 != prev_c2:
                        # Calculate cost for previous pair with these colors
                        prev_cost = cost[i-1][prev_c1] + cost[j+1][prev_c2]
                        prev_valid.append((prev_c1, prev_c2, prev_cost))
            
            # Find minimum cost for current pair considering constraints
            min_cost = float('inf')
            for c1 in range(3):
                for c2 in range(3):
                    if c1 != c2:
                        # Check against all previous valid combinations
                        for prev_c1, prev_c2, prev_pair_cost in prev_valid:
                            if c1 != prev_c1 and c2 != prev_c2:
                                current_cost = cost[i][c1] + cost[j][c2]
                                total_pair_cost = prev_pair_cost + current_cost
                                min_cost = min(min_cost, total_pair_cost)
            
            # Update total_cost (we subtract previous pair cost since we're recomputing)
            if i == 1:
                total_cost = min_cost
            else:
                total_cost = min_cost
    
    return total_cost + 1
