# signature: def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> list[int]
from typing import List

def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> List[int]:
    n = len(nums)
    
    # Validate inputs
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    # Precompute prefix sums for efficient range sum calculation
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Calculate the number of possible starting positions for subarrays
    max_possible_k = n // x
    
    # Function to calculate operations for making a subarray equal to target
    def calculate_operations(start_idx, target):
        end_idx = start_idx + x - 1
        if end_idx >= n:
            return float('inf')
        
        # Operations needed = sum of absolute differences between each element and target
        # This can be optimized using prefix sums and median
        subarray = nums[start_idx:end_idx + 1]
        
        # For minimum operations, we should make all elements equal to the median
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]
        
        # Calculate total operations
        total_ops = 0
        for num in subarray:
            total_ops += abs(num - median)
        
        return total_ops
    
    # Precompute operations for all possible subarrays
    subarray_ops = []
    for i in range(n - x + 1):
        ops = calculate_operations(i, 0)  # target doesn't matter since we use median
        subarray_ops.append((i, ops))
    
    # Sort subarrays by their operation cost
    subarray_ops.sort(key=lambda item: item[1])
    
    # Function to check if we can select k non-overlapping subarrays with total operations <= target
    def can_achieve_k(k, max_ops):
        # Use greedy selection with backtracking for small k
        selected = []
        
        def backtrack(idx, count, total_ops_used):
            if count == k:
                return total_ops_used <= max_ops
            
            if idx >= len(subarray_ops):
                return False
            
            # Skip current subarray
            if backtrack(idx + 1, count, total_ops_used):
                return True
            
            # Try to take current subarray if it doesn't overlap with selected ones
            current_start, current_ops = subarray_ops[idx]
            current_end = current_start + x - 1
            
            # Check overlap with already selected subarrays
            overlaps = False
            for start, _ in selected:
                end = start + x - 1
                if not (current_end < start or current_start > end):
                    overlaps = True
                    break
            
            if not overlaps and current_ops + total_ops_used <= max_ops:
                selected.append((current_start, current_ops))
                if backtrack(idx + 1, count + 1, total_ops_used + current_ops):
                    return True
                selected.pop()
            
            return False
        
        return backtrack(0, 0, 0)
    
    # Find all k values that satisfy the condition
    result = []
    max_k = min(15, max_possible_k)
    
    for k in range(1, max_k + 1):
        if k * x > n:
            continue
            
        # Check if min_operations_for_k_equal_subarrays is achievable for this k
        if can_achieve_k(k, min_operations_for_k_equal_subarrays):
            # Also check that it's the minimum (no smaller operations achieve k)
            if min_operations_for_k_equal_subarrays == 0 or not can_achieve_k(k, min_operations_for_k_equal_subarrays - 1):
                result.append(k)
    
    return result
