# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 10**5:
                raise ValueError("Invalid input")
    
    # For symmetric positions: i and n-1-i
    # We need to assign colors such that:
    # 1. adjacent houses have different colors
    # 2. symmetric houses have different colors
    
    # Since n is even, we can consider pairs (i, n-1-i)
    # For each pair, we need to assign colors (c1, c2) such that:
    # - c1 != c2 (symmetric constraint)
    # - For adjacent pairs: the color of house i+1 must be different from house i
    #   and the color of house n-1-i must be different from house n-2-i
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs (from both ends) with the left house having color c1
    # and the right house having color c2
    
    # Initialize DP for the first pair
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n//2)]
    
    # Initialize first pair (houses 0 and n-1)
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n//2):
        for c1 in range(3):  # Color for left house i
            for c2 in range(3):  # Color for right house n-1-i
                if c1 != c2:  # Symmetric constraint
                    # Try all possible colors for previous pair
                    for prev_c1 in range(3):  # Color for left house i-1
                        for prev_c2 in range(3):  # Color for right house n-i
                            # Adjacency constraints:
                            # House i-1 and house i must have different colors
                            # House n-i and house n-1-i must have different colors
                            if prev_c1 != c1 and prev_c2 != c2:
                                dp[i][c1][c2] = min(
                                    dp[i][c1][c2],
                                    dp[i-1][prev_c1][prev_c2] + cost[i][c1] + cost[n-1-i][c2]
                                )
    
    # Find minimum cost for the last pair
    result = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            result = min(result, dp[n//2 - 1][c1][c2])
    
    return result
