# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    n = len(cost_prefix) + 1
    
    # Check constraints
    if n % 2 != 0 or n < 2:
        raise ValueError("Invalid input")
    
    if n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(len(cost_prefix)):
        if len(cost_prefix[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost_prefix[i][j] < 0 or cost_prefix[i][j] > 100000:
                raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    # Dynamic programming arrays
    # dp[i][c1][c2] = minimum cost for first i+1 houses where:
    # - house i has color c1
    # - house n-1-i has color c2 (symmetric position)
    # We only need to compute for i < n//2
    
    half = n // 2
    INF = 10**18
    
    # Initialize DP for the first pair (house 0 and house n-1)
    dp = [[[INF for _ in range(3)] for _ in range(3)] for _ in range(half)]
    
    # Base case: first pair (houses 0 and n-1)
    for c0 in range(3):
        for cn1 in range(3):
            if c0 != cn1:  # Symmetric constraint
                cost = cost_prefix[0][c0]  # House 0 cost
                # House n-1 cost will be added later when we know cost_suffix
                dp[0][c0][cn1] = cost
    
    # Fill DP for pairs 1 to half-1
    for i in range(1, half):
        for c_prev in range(3):  # Color of house i-1
            for c_sym_prev in range(3):  # Color of house n-i
                if dp[i-1][c_prev][c_sym_prev] == INF:
                    continue
                
                for c_curr in range(3):  # Color of house i
                    if c_curr == c_prev:  # Adjacent constraint
                        continue
                    
                    for c_sym_curr in range(3):  # Color of house n-1-i
                        if c_sym_curr == c_sym_prev:  # Adjacent constraint
                            continue
                        if c_curr == c_sym_curr:  # Symmetric constraint
                            continue
                        
                        # House i and house n-1-i are at symmetric positions
                        cost = dp[i-1][c_prev][c_sym_prev] + cost_prefix[i][c_curr] + cost_prefix[n-1-i][c_sym_curr]
                        if cost < dp[i][c_curr][c_sym_curr]:
                            dp[i][c_curr][c_sym_curr] = cost
    
    # For the middle pair when n is even (houses half-1 and half)
    # These are adjacent to each other
    result = []
    
    # Try all possible color combinations for the last house (house n-1)
    # and check if the total cost equals minimum_beautiful_painting_cost
    for c_last in range(3):
        for c_half_minus_1 in range(3):
            if c_last == c_half_minus_1:  # Adjacent constraint for middle pair
                continue
            
            # Find the minimum cost configuration that ends with these colors
            min_cost = INF
            for c_sym in range(3):
                if c_sym == c_last:  # Symmetric constraint
                    continue
                if dp[half-1][c_half_minus_1][c_sym] != INF:
                    total_cost = dp[half-1][c_half_minus_1][c_sym] + cost_prefix[half][c_half_minus_1]
                    if total_cost < min_cost:
                        min_cost = total_cost
            
            if min_cost != INF:
                # Add the cost of the last house
                total_with_last = min_cost
                # We need to find cost_suffix values that make total_with_last + cost_suffix[0][c_last] = minimum_beautiful_painting_cost
                required_cost = minimum_beautiful_painting_cost - total_with_last
                
                if required_cost >= 0 and required_cost <= 100000:
                    cost_suffix_val = [[0, 0, 0]]
                    cost_suffix_val[0][c_last] = required_cost
                    
                    # For other colors, we can set any value >= required_cost
                    # but to get exactly minimum_beautiful_painting_cost, other colors must be >= required_cost
                    # We need to find all possible assignments where at least one color equals required_cost
                    # and all others are >= required_cost
                    
                    # Generate all possible cost_suffix arrays where cost_suffix[0][c_last] = required_cost
                    # and other colors are in [required_cost, 100000]
                    for other1 in range(3):
                        if other1 == c_last:
                            continue
                        for other2 in range(other1 + 1, 3):
                            if other2 == c_last:
                                continue
                            
                            # Generate all combinations for other colors
                            for val1 in range(required_cost, 100001):
                                for val2 in range(required_cost, 100001):
                                    cost_suffix_candidate = [[0, 0, 0]]
                                    cost_suffix_candidate[0][c_last] = required_cost
                                    cost_suffix_candidate[0][other1] = val1
                                    cost_suffix_candidate[0][other2] = val2
                                    
                                    # Check if this candidate gives exactly minimum_beautiful_painting_cost
                                    actual_min_cost = INF
                                    for color in range(3):
                                        candidate_cost = total_with_last + cost_suffix_candidate[0][color]
                                        if candidate_cost < actual_min_cost:
                                            actual_min_cost = candidate_cost
                                    
                                    if actual_min_cost == minimum_beautiful_painting_cost:
                                        result.append(cost_suffix_candidate)
    
    # Remove duplicates and return
    unique_result = []
    for item in result:
        if item not in unique_result:
            unique_result.append(item)
    
    return unique_result
