# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also, adjacent houses cannot have the same color
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i+1 pairs, with the left house having color c1 and right house having color c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # Instead, we can process pairs independently and track the best combinations
    
    # For each symmetric pair (i, n-1-i):
    # - The two houses in the pair must have different colors (condition 2)
    # - Each house must have a different color from its adjacent neighbors
    
    # We can use DP that tracks the minimum cost for the first k pairs
    # and the colors used for the last house on left and first house on right
    
    # Initialize DP for the first pair
    dp = {}
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric houses must have different colors
                dp[(c1, c2)] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n//2):
        new_dp = {}
        for (prev_c1, prev_c2), total_cost in dp.items():
            for c1 in range(3):
                for c2 in range(3):
                    if (c1 != c2 and  # Symmetric houses different colors
                        c1 != prev_c1 and  # Adjacent to previous left house
                        c2 != prev_c2):    # Adjacent to previous right house
                        key = (c1, c2)
                        new_cost = total_cost + cost[i][c1] + cost[n-1-i][c2]
                        if key not in new_dp or new_cost < new_dp[key]:
                            new_dp[key] = new_cost
        dp = new_dp
    
    # Find minimum cost
    if not dp:
        raise ValueError("Invalid input")
    
    min_cost = min(dp.values())
    
    # Add 1 to the final answer as requested
    return min_cost + 1
