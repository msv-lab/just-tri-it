# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not (2 <= len(nums) <= 10**5 and all(-10**6 <= num <= 10**6 for num in nums)):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # Collect all possible subarrays of size x
    subarrays = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        subarrays.append((i, subarray))
    
    # For each subarray, compute the cost to make all elements equal to the median
    # and store the cost along with the start index
    sub_costs = []
    for i, sub in subarrays:
        # To minimize operations, we should make all elements equal to the median
        sorted_sub = sorted(sub)
        median = sorted_sub[x // 2]
        cost = sum(abs(num - median) for num in sub)
        sub_costs.append((cost, i))
    
    # We need to select k non-overlapping subarrays with minimal total cost
    # This is similar to the problem of selecting k intervals with minimal sum, no overlaps
    # We can use dynamic programming or greedy approach with priority queue
    
    # Sort the subarrays by their start index
    sub_costs.sort(key=lambda item: item[1])
    costs = [item[0] for item in sub_costs]
    starts = [item[1] for item in sub_costs]
    ends = [s + x - 1 for s in starts]
    m = len(sub_costs)
    
    # We will use dynamic programming with a min-heap to keep track of the minimal cost up to a certain point
    # dp[i] represents the minimal cost to select i+1 subarrays up to current position
    # Initialize a heap to keep track of the minimal costs for the previous positions
    
    # The approach is similar to the problem of scheduling k non-overlapping intervals with minimal cost
    # We can use a min-heap to keep track of the best cost up to the current subarray
    
    # Initialize a list to store the minimal cost for selecting t subarrays up to the j-th subarray
    # We can use a heap to optimize the selection
    
    # The heap will store tuples of (current_cost, end_index)
    heap = []
    # For each subarray, we can choose to take it or not
    # The minimal cost for the first subarray is its own cost
    # For subsequent subarrays, we look for the earliest subarray that does not overlap with the current one
    
    # Initialize dp arrays
    prev_dp = [float('inf')] * m
    for j in range(m):
        prev_dp[j] = costs[j]
    
    for t in range(1, k):
        current_dp = [float('inf')] * m
        heap = []
        # We need to process the subarrays in order of their start index
        # For each subarray j, we look for the latest subarray i where ends[i] < starts[j]
        # The minimal cost up to i is stored in prev_dp[i]
        # We can use a heap to keep track of the minimal prev_dp[i] where ends[i] < starts[j]
        
        # Sort the subarrays by start time to process them in order
        # The sub_costs are already sorted by start index (starts)
        
        # We will use a pointer to keep track of the subarrays that have been processed so far
        pointer = 0
        for j in range(m):
            start_j = starts[j]
            # Add all subarrays i where ends[i] < start_j to the heap
            while pointer < m and ends[pointer] < start_j:
                heapq.heappush(heap, (prev_dp[pointer], ends[pointer]))
                pointer += 1
            # The minimal cost up to j is cost[j] + minimal cost in the heap
            if heap:
                min_prev_cost, _ = heap[0]
                current_dp[j] = costs[j] + min_prev_cost
        prev_dp = current_dp
    
    if not prev_dp:
        return 0
    min_total = min(prev_dp)
    return min_total if min_total != float('inf') else 0
