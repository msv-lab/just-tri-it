# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    n = len(cost_prefix) + 1
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    if not cost_prefix:
        if minimum_beautiful_painting_cost == 0:
            return [[0, 0, 0]]
        else:
            raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # Dynamic programming approach to find the minimum cost
    # We need to track the minimum costs for different color combinations
    # considering both adjacency and symmetry constraints
    
    # For symmetric positions (i, n-1-i), we need to ensure they have different colors
    # Since n is even, we have n/2 symmetric pairs
    
    # We'll compute the minimum cost for the first n-1 houses using cost_prefix
    # Then we'll find what cost_suffix values would make the total minimum cost equal to minimum_beautiful_painting_cost
    
    # Initialize DP for the first house
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n//2)]
    
    # Fill DP for the first symmetric pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Adjacent houses can't have same color
                dp[0][c1][c2] = cost_prefix[0][c1] + cost_prefix[n-2][c2]
    
    # Process remaining symmetric pairs
    for i in range(1, n//2):
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:  # Adjacent constraint
                    # Find the minimum from previous pair with valid colors
                    min_prev = float('inf')
                    for prev_c1 in range(3):
                        for prev_c2 in range(3):
                            if prev_c1 != c1 and prev_c2 != c2:  # Adjacent and symmetric constraints
                                min_prev = min(min_prev, dp[i-1][prev_c1][prev_c2])
                    
                    if min_prev != float('inf'):
                        dp[i][c1][c2] = min_prev + cost_prefix[i][c1] + cost_prefix[n-1-i-1][c2]
    
    # Find the minimum cost for the first n-1 houses
    min_cost_prefix = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_cost_prefix = min(min_cost_prefix, dp[n//2-1][c1][c2])
    
    # If the minimum cost for prefix is already greater than the target, no solution
    if min_cost_prefix > minimum_beautiful_painting_cost:
        raise ValueError("Invalid input")
    
    # Calculate the required cost_suffix
    # The cost_suffix will be added to the minimum of valid transitions from the last house in prefix
    # to the first house in suffix (which is the last house overall)
    
    # We need to find cost_suffix values that make total cost = minimum_beautiful_painting_cost
    required_suffix_cost = minimum_beautiful_painting_cost - min_cost_prefix
    
    # Distribute the required cost among the 3 colors
    # We can set all colors to the same value that makes the equation work
    # Since any valid cost_suffix is acceptable, we can choose a simple distribution
    
    cost_per_color = max(0, required_suffix_cost // 3)
    remainder = required_suffix_cost % 3
    
    cost_suffix = [cost_per_color] * 3
    for i in range(remainder):
        cost_suffix[i] += 1
    
    # Ensure all values are within valid range
    for i in range(3):
        if cost_suffix[i] < 0:
            cost_suffix[i] = 0
        if cost_suffix[i] > 100000:
            cost_suffix[i] = 100000
    
    return [cost_suffix]
