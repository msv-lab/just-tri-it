# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n != len(cost) or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    
    if n == 0:
        return 0
    
    # Pair the houses equidistant from the ends
    pairs = []
    for i in range(n // 2):
        j = n - 1 - i
        pairs.append((i, j))
    
    # Precompute the minimum and second minimum costs for each pair
    pair_min_costs = []
    for i, j in pairs:
        # For house i and j, find the best two colors for i and j such that they are different
        # and the sum is minimized.
        min_cost = float('inf')
        best_colors = None
        
        for ci in range(3):
            for cj in range(3):
                if ci != cj:
                    current_cost = cost[i][ci] + cost[j][cj]
                    if current_cost < min_cost:
                        min_cost = current_cost
                        best_colors = (ci, cj)
        
        # Also track the second best to handle adjacent constraints
        second_min_cost = float('inf')
        second_best_colors = None
        
        for ci in range(3):
            for cj in range(3):
                if ci != cj and (ci, cj) != best_colors:
                    current_cost = cost[i][ci] + cost[j][cj]
                    if current_cost < second_min_cost:
                        second_min_cost = current_cost
                        second_best_colors = (ci, cj)
        
        pair_min_costs.append({
            'min_cost': min_cost,
            'best_colors': best_colors,
            'second_min_cost': second_min_cost,
            'second_best_colors': second_best_colors
        })
    
    # Now, we need to ensure that adjacent pairs (in the pair list) don't have conflicting colors
    # For example, pair 0 and pair 1 must have i1's color != j0's color if they are adjacent.
    # But since the pairs are (0, n-1), (1, n-2), etc., the adjacency is between consecutive pairs.
    # So, for pair k and k+1, the j of pair k is i of pair k+1's neighbor (if they are adjacent).
    # However, in the straight line, the adjacency is between i and i+1, j and j-1.
    # So, the constraints are:
    # For two consecutive pairs (i1, j1) and (i2, j2), where i2 = i1 + 1 and j2 = j1 - 1:
    # The color of i2 must be different from the color of i1's adjacent (which is i2).
    # But i1 and i2 are adjacent only if j1 = i2 + 1, which is not the case here since pairs are (i, n-1-i).
    # Wait, perhaps it's better to think that the adjacency is between the original house indices.
    # So, for the original problem, the adjacency is between house i and i+1.
    # In the pairing, the adjacency between pairs is:
    # For pairs (i, j) and (i+1, j-1), the adjacency is between i and i+1, and between j and j-1.
    # So, the color of i+1 must be different from i, and j-1 must be different from j.
    # But in the pairing, i+1 is in the next pair, and j is in the current pair.
    # So, the color of the first house in the next pair (i+1) must be different from the color of the first house in the current pair (i).
    # Similarly, the color of the second house in the next pair (j-1) must be different from the color of the second house in the current pair (j).
    
    # Now, we can model this as a DP problem where for each pair, we choose between the best and second best options,
    # ensuring that the colors do not conflict with the previous pair's choices.
    
    if not pair_min_costs:
        return 0
    
    # Initialize DP: for each pair, track the cost if we choose the min or second min, and the colors used.
    # The DP state will be:
    # dp[i][0] = total cost up to pair i, choosing the min for pair i
    # dp[i][1] = total cost up to pair i, choosing the second min for pair i
    # Along with the colors chosen for i and j in the pair.
    
    dp = []
    first_pair = pair_min_costs[0]
    dp.append({
        'cost_min': first_pair['min_cost'],
        'colors_min': first_pair['best_colors'],
        'cost_second': first_pair['second_min_cost'],
        'colors_second': first_pair['second_best_colors']
    })
    
    for k in range(1, len(pair_min_costs)):
        current_pair = pair_min_costs[k]
        prev_dp = dp[k-1]
        
        # Option 1: choose min for current pair
        # Check against previous min and previous second min
        cost_if_prev_min = float('inf')
        if current_pair['best_colors'][0] != prev_dp['colors_min'][1]:
            cost_if_prev_min = prev_dp['cost_min'] + current_pair['min_cost']
        
        cost_if_prev_second = float('inf')
        if current_pair['best_colors'][0] != prev_dp['colors_second'][1]:
            cost_if_prev_second = prev_dp['cost_second'] + current_pair['min_cost']
        
        current_min_cost = min(cost_if_prev_min, cost_if_prev_second)
        current_min_colors = current_pair['best_colors']
        
        # Option 2: choose second min for current pair
        cost_if_prev_min_second = float('inf')
        if current_pair['second_best_colors'][0] != prev_dp['colors_min'][1]:
            cost_if_prev_min_second = prev_dp['cost_min'] + current_pair['second_min_cost']
        
        cost_if_prev_second_second = float('inf')
        if current_pair['second_best_colors'][0] != prev_dp['colors_second'][1]:
            cost_if_prev_second_second = prev_dp['cost_second'] + current_pair['second_min_cost']
        
        current_second_cost = min(cost_if_prev_min_second, cost_if_prev_second_second)
        current_second_colors = current_pair['second_best_colors']
        
        dp.append({
            'cost_min': current_min_cost,
            'colors_min': current_min_colors,
            'cost_second': current_second_cost,
            'colors_second': current_second_colors
        })
    
    last_dp = dp[-1]
    return min(last_dp['cost_min'], last_dp['cost_second'])
