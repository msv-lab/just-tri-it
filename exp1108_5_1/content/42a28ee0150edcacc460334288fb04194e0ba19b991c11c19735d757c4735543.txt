# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute cost for making each window of length x have all elements equal to target value
    # For a window starting at index i, the optimal target is the median of the window
    # This minimizes the sum of absolute deviations
    
    def compute_cost_for_target(window, target):
        return sum(abs(num - target) for num in window)
    
    def find_optimal_cost(window):
        # Sort the window to find median
        sorted_window = sorted(window)
        median = sorted_window[len(window) // 2]
        return compute_cost_for_target(window, median)
    
    # Calculate cost for each possible window
    window_costs = []
    for i in range(n - x + 1):
        window = nums[i:i + x]
        cost = find_optimal_cost(window)
        window_costs.append((i, cost))
    
    # We need to select k non-overlapping windows with minimum total cost
    # Windows are non-overlapping if the start indices are at least x apart
    
    # Sort windows by cost
    window_costs.sort(key=lambda w: w[1])
    
    # Use dynamic programming: dp[i][mask] = min cost using windows starting at or after index i,
    # where mask is a bitmask of selected windows
    # But since k is small (<=15), we can use a simpler approach
    
    # Greedy approach: try all combinations of k windows that don't overlap
    candidates = []
    
    def backtrack(idx, selected, total_cost, last_end):
        if len(selected) == k:
            candidates.append(total_cost)
            return
        
        for i in range(idx, len(window_costs)):
            start_idx, cost = window_costs[i]
            
            # Check if this window overlaps with any selected window
            # A window starting at start_idx covers [start_idx, start_idx + x - 1]
            # It doesn't overlap if start_idx >= last_end
            if start_idx >= last_end:
                backtrack(i + 1, selected + [start_idx], total_cost + cost, start_idx + x)
    
    backtrack(0, [], 0, 0)
    
    return min(candidates) if candidates else float('inf')
