# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n != len(cost) or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    
    # For each pair of equidistant houses, we need to choose colors such that:
    # 1. They are different from each other.
    # 2. The first house's color is different from the previous house (if exists).
    # 3. The second house's color is different from the next house (if exists).
    # However, since the problem is symmetric, we can process pairs and track the minimal cost.
    
    total_cost = 0
    for i in range(n // 2):
        j = n - 1 - i
        if i >= j:
            break
        
        # House i and house j are a pair
        if i == 0:
            # First pair: no adjacent constraints except between i and j
            min_cost = float('inf')
            for ci in range(3):
                for cj in range(3):
                    if ci != cj:
                        current_cost = cost[i][ci] + cost[j][cj]
                        if current_cost < min_cost:
                            min_cost = current_cost
            total_cost += min_cost
            # Track the last colors used for i and j
            last_ci, last_cj = None, None
            for ci in range(3):
                for cj in range(3):
                    if ci != cj and cost[i][ci] + cost[j][cj] == min_cost:
                        last_ci, last_cj = ci, cj
        else:
            # Subsequent pairs: must not have ci == last_ci (adjacent to previous i-1)
            # and cj must not equal last_cj (adjacent to previous j+1)
            # Also, ci != cj for the current pair
            min_cost = float('inf')
            for ci in range(3):
                for cj in range(3):
                    if ci != cj and ci != last_ci and cj != last_cj:
                        current_cost = cost[i][ci] + cost[j][cj]
                        if current_cost < min_cost:
                            min_cost = current_cost
            if min_cost == float('inf'):
                raise ValueError("No valid coloring possible")
            total_cost += min_cost
            # Update last_ci and last_cj for the next pair
            for ci in range(3):
                for cj in range(3):
                    if ci != cj and ci != last_ci and cj != last_cj and cost[i][ci] + cost[j][cj] == min_cost:
                        last_ci, last_cj = ci, cj
    
    return total_cost
