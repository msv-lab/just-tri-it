# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Input validation
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for each possible subarray of length x
    # cost[i] = minimum operations to make subarray starting at i have all equal elements
    cost = [0] * (n - x + 1)
    
    for i in range(n - x + 1):
        # To minimize operations, we should change all elements to the median
        subarray = nums[i:i+x]
        subarray_sorted = sorted(subarray)
        
        # For odd length, median is middle element
        # For even length, either middle element works (both give same cost)
        median = subarray_sorted[x // 2]
        
        # Calculate cost to make all elements equal to median
        current_cost = 0
        for num in subarray:
            current_cost += abs(num - median)
        cost[i] = current_cost
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # Use dynamic programming: dp[i][j] = min cost to select j subarrays from first i positions
    # But we need to ensure subarrays don't overlap
    
    # Since k is small (<=15), we can use DP with state (position, count)
    # But n is large (10^5), so we need an efficient approach
    
    # Alternative approach: use DP where state is (mask of used positions, count)
    # But that's too expensive
    
    # Better approach: since subarrays are of fixed length x, we can only choose starting positions
    # that are at least x apart to avoid overlap
    
    # We'll use memoization with position and count
    from functools import lru_cache
    
    @lru_cache(None)
    def dfs(pos, count):
        if count == 0:
            return 0
        if pos > n - x:
            return float('inf')
        
        # Option 1: skip current position
        skip = dfs(pos + 1, count)
        
        # Option 2: take subarray starting at pos, then skip x positions
        take = cost[pos] + dfs(pos + x, count - 1)
        
        return min(skip, take)
    
    result = dfs(0, k)
    
    # Clear cache to avoid memory issues
    dfs.cache_clear()
    
    return result
