# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    n = len(cost_prefix) + 1
    
    # Check constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    if n > 100000:
        raise ValueError("Invalid input")
    
    if not cost_prefix and n != 1:
        raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for cost in row:
            if cost < 0 or cost > 100000:
                raise ValueError("Invalid input")
    
    # Dynamic programming for the first n-1 houses
    # We need to track the minimum costs for different color combinations
    # considering both adjacent and symmetric constraints
    
    # For each position i, we'll track the minimum cost for each color
    # while also considering the symmetric house at position n-1-i
    
    # Initialize DP arrays
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # For the first house, initialize with its costs
    if n > 1:
        for c1 in range(3):
            dp[c1][c1] = cost_prefix[0][c1]
    
    # Process houses 1 to n-2 (0-indexed)
    for i in range(1, n-1):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_color in range(3):
            for symmetric_color in range(3):
                if dp[prev_color][symmetric_color] == float('inf'):
                    continue
                
                # Try all colors for current house
                for curr_color in range(3):
                    # Adjacent constraint: current color != previous color
                    if curr_color == prev_color:
                        continue
                    
                    # For symmetric constraint, we need to check if this position
                    # has a symmetric counterpart in the processed houses
                    symmetric_pos = n - 1 - i
                    if symmetric_pos < i:
                        # This position's symmetric counterpart has already been processed
                        # Check if colors match the symmetric constraint
                        if curr_color == symmetric_color:
                            continue
                    
                    # Update DP state
                    new_cost = dp[prev_color][symmetric_color] + cost_prefix[i][curr_color]
                    
                    # Update the symmetric color for the current position
                    # The symmetric color for position i is the color at position n-1-i
                    # Since we haven't processed that yet, we track the current color
                    # as a potential symmetric constraint
                    new_dp[curr_color][symmetric_color] = min(new_dp[curr_color][symmetric_color], new_cost)
        
        dp = new_dp
    
    # Now find all possible cost_suffix values that would make the total minimum cost
    # equal to minimum_beautiful_painting_cost
    result = []
    
    # Try all color combinations for the last house
    for last_color in range(3):
        # The last house's symmetric counterpart is the first house
        # So last_color cannot equal the color of the first house's symmetric color
        # Also, last_color cannot equal the color of the previous house (n-2)
        
        min_total_cost = float('inf')
        
        for prev_color in range(3):
            for first_color in range(3):
                if dp[prev_color][first_color] == float('inf'):
                    continue
                
                # Check constraints for the last house
                # Adjacent constraint: last_color != prev_color
                if last_color == prev_color:
                    continue
                
                # Symmetric constraint: last_color != first_color
                if last_color == first_color:
                    continue
                
                # Calculate total cost
                total_cost = dp[prev_color][first_color]  # cost for first n-1 houses
                # We'll add the cost_suffix later when we test different values
                
                min_total_cost = min(min_total_cost, total_cost)
        
        # If we found valid color combinations for the last house
        if min_total_cost != float('inf'):
            # We need to find cost_suffix values that make min_total_cost + cost_suffix[last_color] 
            # equal to minimum_beautiful_painting_cost
            required_cost = minimum_beautiful_painting_cost - min_total_cost
            
            # Check if this required cost is valid for the given constraints
            if 0 <= required_cost <= 100000:
                # Create the cost_suffix array
                cost_suffix = [[0, 0, 0]]
                cost_suffix[0][last_color] = required_cost
                
                # For the other colors, they can be any value >= required_cost
                # but we need to ensure the minimum cost is achieved with last_color
                for other_color in range(3):
                    if other_color != last_color:
                        cost_suffix[0][other_color] = required_cost + 1
                
                # Verify that with this cost_suffix, the minimum total cost is indeed
                # minimum_beautiful_painting_cost and uses last_color
                total_with_suffix = min_total_cost + cost_suffix[0][last_color]
                if total_with_suffix == minimum_beautiful_painting_cost:
                    # Check that no other color gives a lower cost
                    valid = True
                    for other_color in range(3):
                        if other_color != last_color:
                            # Check if this other color violates any constraints
                            violates_constraints = False
                            for prev_color in range(3):
                                for first_color in range(3):
                                    if dp[prev_color][first_color] == float('inf'):
                                        continue
                                    # Check adjacent constraint
                                    if other_color == prev_color:
                                        continue
                                    # Check symmetric constraint  
                                    if other_color == first_color:
                                        continue
                                    # If we get here, the color is valid
                                    other_total = dp[prev_color][first_color] + cost_suffix[0][other_color]
                                    if other_total < total_with_suffix:
                                        valid = False
                                        break
                                if not valid:
                                    break
                            if not valid:
                                break
                    
                    if valid:
                        result.append(cost_suffix)
    
    return result
