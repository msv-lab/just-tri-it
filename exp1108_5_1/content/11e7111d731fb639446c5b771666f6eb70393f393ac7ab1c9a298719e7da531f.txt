# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Check if there exists a valid coloring with the given cost
    # We'll use dynamic programming to find the actual minimum cost
    # and compare it with the given value
    
    # For symmetric constraint, we need to consider pairs (i, n-1-i)
    # For each pair, they cannot have the same color, and adjacent houses cannot have same color
    
    # Precompute the minimum cost for each symmetric pair
    pair_costs = []
    for i in range(n // 2):
        j = n - 1 - i
        
        # For positions i and j, they cannot have the same color
        # Also, i cannot have same color as i-1, j cannot have same color as j+1
        # But since we're processing pairs, we need to consider the constraints
        
        # Calculate all valid color combinations for this pair
        min_pair_cost = float('inf')
        
        for color_i in range(3):
            for color_j in range(3):
                if color_i == color_j:  # Symmetric constraint
                    continue
                
                # Check adjacent constraints within the pair
                # For the first pair (i=0, j=n-1), no left/right neighbors to check
                # For other pairs, we need to ensure they don't conflict with previous pair
                # But since we're verifying rather than computing, we'll use a different approach
                
                pair_cost = cost[i][color_i] + cost[j][color_j]
                if pair_cost < min_pair_cost:
                    min_pair_cost = pair_cost
        
        pair_costs.append(min_pair_cost)
    
    # Also need to consider the global minimum across all valid colorings
    # Let's use DP to find the actual minimum cost
    
    # DP[i][c1][c2] = min cost for first i pairs where last pair has colors c1 and c2
    # But this would be O(n * 9) which is too slow for n up to 10^5
    
    # Alternative approach: Since we're only verifying, we can check if the given cost
    # is achievable and is indeed the minimum
    
    # Let's compute the actual minimum using a more efficient approach
    # We can use DP that considers the state for the current pair based on the previous pair
    
    if n == 2:
        # Only one pair
        min_cost = float('inf')
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:  # Symmetric constraint
                    min_cost = min(min_cost, cost[0][c1] + cost[1][c2])
        return min_cost == minimum_cost_symmetric_painting
    
    # For n > 2, we need to consider adjacent constraints between pairs
    # Let's use DP where state is (color_left, color_right) for current pair
    
    # Initialize DP for first pair
    dp = {}
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[(c1, c2)] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for k in range(1, n // 2):
        i = k
        j = n - 1 - k
        new_dp = {}
        
        for (prev_c1, prev_c2), prev_cost in dp.items():
            # prev_c1 is color of house i-1, prev_c2 is color of house j+1
            for c1 in range(3):
                for c2 in range(3):
                    if c1 != c2:  # Symmetric constraint
                        if c1 != prev_c1 and c2 != prev_c2:  # Adjacent constraints
                            new_cost = prev_cost + cost[i][c1] + cost[j][c2]
                            state = (c1, c2)
                            if state not in new_dp or new_cost < new_dp[state]:
                                new_dp[state] = new_cost
        
        dp = new_dp
    
    # Find minimum cost from all valid final states
    actual_min_cost = min(dp.values()) if dp else float('inf')
    
    return actual_min_cost == minimum_cost_symmetric_painting
