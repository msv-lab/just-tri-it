# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if not (0 <= cost[i][j] <= 100000):
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Calculate the actual minimum cost using dynamic programming
    # We need to consider symmetry constraints
    m = n // 2
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Let's create a DP table where dp[i][c1][c2] represents the minimum cost for the first i pairs
    # where the i-th pair has colors c1 and c2 for the two symmetric houses
    
    # Since n can be up to 10^5, we need a more efficient approach
    # We'll use the fact that for each symmetric pair, we need to choose two different colors
    
    # Precompute the minimum costs for each symmetric pair
    pair_costs = []
    for i in range(m):
        house1 = i
        house2 = n - 1 - i
        
        # For this symmetric pair, we need to choose two different colors
        min_pair_cost = float('inf')
        
        for color1 in range(3):
            for color2 in range(3):
                if color1 != color2:
                    pair_cost = cost[house1][color1] + cost[house2][color2]
                    min_pair_cost = min(min_pair_cost, pair_cost)
        
        pair_costs.append(min_pair_cost)
    
    # Also need to ensure adjacent houses don't have same color
    # This is more complex and requires proper DP
    
    # Let's implement a proper DP solution that considers both constraints
    # We'll work with pairs of symmetric houses
    
    # Initialize DP for the first pair
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(m)]
    
    # Fill the first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Fill the rest of the pairs
    for i in range(1, m):
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[i-1][prev_c1][prev_c2] == float('inf'):
                    continue
                
                for curr_c1 in range(3):
                    for curr_c2 in range(3):
                        # Check constraints:
                        # 1. Symmetric houses must have different colors
                        if curr_c1 == curr_c2:
                            continue
                        # 2. Adjacent houses must have different colors
                        # For house i and i-1 (left side)
                        if curr_c1 == prev_c1:
                            continue
                        # For house n-1-i and n-i (right side)  
                        if curr_c2 == prev_c2:
                            continue
                        
                        total_cost = dp[i-1][prev_c1][prev_c2] + cost[i][curr_c1] + cost[n-1-i][curr_c2]
                        dp[i][curr_c1][curr_c2] = min(dp[i][curr_c1][curr_c2], total_cost)
    
    # Find the minimum cost from the last pair
    actual_min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            actual_min_cost = min(actual_min_cost, dp[m-1][c1][c2])
    
    # Check if the given value matches the calculated minimum
    return minimum_cost_symmetric_painting == actual_min_cost
