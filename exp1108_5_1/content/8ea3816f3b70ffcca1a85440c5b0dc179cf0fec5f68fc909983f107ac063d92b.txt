# signature: def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool
from typing import List
import heapq

def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool:
    # Validate input constraints
    n = len(nums)
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if k < 1 or k > 15:
        raise ValueError("Invalid input")
    if k * x < 2 or k * x > n:
        raise ValueError("Invalid input")
    
    # Calculate the minimum operations needed to get k subarrays
    def calculate_min_operations():
        # We need to select k non-overlapping subarrays of length x
        # For each possible subarray of length x, calculate the cost to make all elements equal
        # The optimal value for each subarray is the median (for absolute differences)
        
        # Precompute cost for each subarray starting at position i
        subarray_costs = []
        
        for i in range(n - x + 1):
            subarray = nums[i:i+x]
            # Sort to find median
            sorted_sub = sorted(subarray)
            median = sorted_sub[x // 2]
            # Calculate cost to make all elements equal to median
            cost = sum(abs(num - median) for num in subarray)
            subarray_costs.append((i, cost))
        
        # Now we need to select k non-overlapping subarrays with minimum total cost
        # Use dynamic programming with state (position, count)
        # Since k is small (<=15), we can use DP with state compression
        
        # Group subarrays by their end position
        subarrays_by_end = [[] for _ in range(n)]
        for i, cost in subarray_costs:
            end_pos = i + x - 1
            subarrays_by_end[end_pos].append((i, cost))
        
        # DP[i][mask] = minimum cost to select mask subarrays ending at or before position i
        # But since k is small, we can use a simpler approach: try all combinations greedily
        
        # Alternative approach: use priority queue to find k minimum cost non-overlapping subarrays
        # Sort subarrays by cost
        sorted_subarrays = sorted(subarray_costs, key=lambda item: item[1])
        
        # Try to select k non-overlapping subarrays with minimum total cost
        selected = []
        total_cost = 0
        
        for start, cost in sorted_subarrays:
            # Check if this subarray overlaps with any already selected
            overlap = False
            for sel_start, sel_cost in selected:
                if not (start + x <= sel_start or sel_start + x <= start):
                    overlap = True
                    break
            
            if not overlap:
                selected.append((start, cost))
                total_cost += cost
                if len(selected) == k:
                    break
        
        # If we couldn't find k non-overlapping subarrays, try a more exhaustive search
        if len(selected) < k:
            # Use backtracking to find the minimum cost combination
            min_total = float('inf')
            
            def backtrack(idx, count, current_cost, last_end):
                nonlocal min_total
                if count == k:
                    min_total = min(min_total, current_cost)
                    return
                if idx >= len(sorted_subarrays):
                    return
                
                # Skip current subarray
                backtrack(idx + 1, count, current_cost, last_end)
                
                # Take current subarray if it doesn't overlap
                start, cost = sorted_subarrays[idx]
                if start > last_end:
                    backtrack(idx + 1, count + 1, current_cost + cost, start + x - 1)
            
            backtrack(0, 0, 0, -1)
            return min_total if min_total != float('inf') else float('inf')
        
        return total_cost
    
    try:
        actual_min_operations = calculate_min_operations()
        
        # Return True if the given value is at least the actual minimum operations needed
        return min_operations_for_k_equal_subarrays >= actual_min_operations
    except:
        raise ValueError("Invalid input")
