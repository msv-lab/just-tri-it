# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # The starting indices of all possible subarrays of size x
    candidates = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        # To make all elements in the subarray equal, the optimal target is the median
        subarray_sorted = sorted(subarray)
        median = subarray_sorted[x // 2]
        operations = sum(abs(num - median) for num in subarray)
        candidates.append((operations, i, median))
    
    # We need to select k non-overlapping candidates with minimal total operations
    # This is similar to interval scheduling with minimal cost
    # We can use dynamic programming with memoization and greedy selection
    
    # Sort the candidates by their end index
    candidates.sort(key=lambda cand: cand[1] + x - 1)
    
    # We will use a DP approach where dp[i][j] represents the minimal operations to select j subarrays from the first i candidates
    # Initialize DP table with infinity
    m = len(candidates)
    dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        current_op, current_start, _ = candidates[i-1]
        current_end = current_start + x - 1
        # Option 1: do not take the i-th candidate
        for j in range(k + 1):
            dp[i][j] = min(dp[i][j], dp[i-1][j])
        # Option 2: take the i-th candidate, find the largest p where candidates[p] ends before current_start
        left = 0
        right = i - 1
        best_p = -1
        while left <= right:
            mid = (left + right) // 2
            _, p_start, _ = candidates[mid]
            p_end = p_start + x - 1
            if p_end < current_start:
                best_p = mid
                left = mid + 1
            else:
                right = mid - 1
        # Update DP for taking the i-th candidate
        for j in range(1, k + 1):
            if best_p != -1:
                if dp[best_p + 1][j - 1] + current_op < dp[i][j]:
                    dp[i][j] = dp[best_p + 1][j - 1] + current_op
            else:
                if j == 1 and current_op < dp[i][j]:
                    dp[i][j] = current_op
    
    if dp[m][k] == float('inf'):
        raise ValueError("No solution found")
    return dp[m][k]
