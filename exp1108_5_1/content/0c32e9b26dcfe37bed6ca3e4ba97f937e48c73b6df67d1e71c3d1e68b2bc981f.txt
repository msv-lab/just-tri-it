# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if not isinstance(c, int) or c < 0 or c > 100000:
                raise ValueError("Invalid input")
    
    if not isinstance(minimum_cost_symmetric_painting, int) or minimum_cost_symmetric_painting < 0:
        raise ValueError("Invalid input")
    
    # Check if the given cost is achievable
    # We'll use dynamic programming to find the actual minimum cost
    
    # For symmetric painting, we need to consider pairs of houses (i, n-1-i)
    # For each pair, we need to choose different colors for both houses in the pair
    # and also ensure adjacent houses have different colors
    
    # Precompute valid color combinations for each symmetric pair
    valid_pairs = []
    for i in range(n // 2):
        pair_valid = []
        for color1 in range(3):
            for color2 in range(3):
                # Colors must be different for symmetric houses
                if color1 != color2:
                    pair_valid.append((color1, color2))
        valid_pairs.append(pair_valid)
    
    # DP[i][color1][color2] = min cost for first i pairs with last pair having colors (color1, color2)
    # But we need to ensure adjacent constraints between pairs
    
    # Initialize DP
    INF = float('inf')
    
    # For the first pair, any valid color combination is allowed
    dp = {}
    for color1, color2 in valid_pairs[0]:
        dp[(color1, color2)] = cost[0][color1] + cost[n-1][color2]
    
    # Process remaining pairs
    for i in range(1, n // 2):
        new_dp = {}
        for prev_color1, prev_color2 in dp:
            for curr_color1, curr_color2 in valid_pairs[i]:
                # Check adjacent constraints:
                # - House i-1 and house i (adjacent in the row)
                if prev_color1 == curr_color1:
                    continue
                # - House n-i and house n-i-1 (adjacent in the row)
                if prev_color2 == curr_color2:
                    continue
                
                total_cost = dp[(prev_color1, prev_color2)] + cost[i][curr_color1] + cost[n-1-i][curr_color2]
                if (curr_color1, curr_color2) not in new_dp or total_cost < new_dp[(curr_color1, curr_color2)]:
                    new_dp[(curr_color1, curr_color2)] = total_cost
        
        if not new_dp:
            # No valid coloring found
            return False
        
        dp = new_dp
    
    # Find the minimum cost from all valid final states
    actual_min_cost = min(dp.values()) if dp else INF
    
    # The given value should be equal to the actual minimum cost
    return actual_min_cost == minimum_cost_symmetric_painting
