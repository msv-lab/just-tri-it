# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    n = len(cost_prefix) + 1
    
    # Check constraints
    if n == 0:
        if minimum_beautiful_painting_cost == 0:
            return [[]]
        else:
            raise ValueError("Invalid input")
    
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    if len(cost_prefix) != n - 1:
        raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # DP for first n-1 houses
    # We need to track the minimum cost for symmetric positions
    # For position i, the symmetric position is n-2-i (0-indexed in cost_prefix)
    
    # Precompute the minimum costs for the prefix
    # We'll compute for each pair of symmetric positions (i, n-2-i)
    # We need to consider all color combinations that satisfy:
    # 1. Adjacent houses have different colors
    # 2. Symmetric houses have different colors
    
    # For the middle pair (when n is even), they are adjacent to each other
    mid = n // 2
    
    # Calculate minimum cost for the prefix without the last house
    # We'll use dynamic programming that considers constraints between symmetric positions
    
    # Initialize DP for the first pair
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # For the first pair (position 0 and position n-2)
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[c1][c2] = cost_prefix[0][c1] + cost_prefix[n-2][c2]
    
    # Process inner pairs
    for i in range(1, mid - 1):
        j = n - 2 - i
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[prev_c1][prev_c2] == float('inf'):
                    continue
                
                for curr_c1 in range(3):
                    for curr_c2 in range(3):
                        # Check constraints:
                        # 1. Current c1 != prev_c1 (adjacent constraint for left side)
                        # 2. Current c2 != prev_c2 (adjacent constraint for right side)  
                        # 3. Current c1 != curr_c2 (symmetric constraint)
                        if curr_c1 != prev_c1 and curr_c2 != prev_c2 and curr_c1 != curr_c2:
                            cost = dp[prev_c1][prev_c2] + cost_prefix[i][curr_c1] + cost_prefix[j][curr_c2]
                            if cost < new_dp[curr_c1][curr_c2]:
                                new_dp[curr_c1][curr_c2] = cost
        
        dp = new_dp
    
    # For the middle pair (when they are adjacent to each other)
    if mid > 1:
        i = mid - 1
        j = n - 2 - i
        
        # The middle pair are adjacent to each other in the full array
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[prev_c1][prev_c2] == float('inf'):
                    continue
                
                for curr_c1 in range(3):
                    for curr_c2 in range(3):
                        # Check constraints:
                        # 1. Current c1 != prev_c1 (adjacent constraint for left side)
                        # 2. Current c2 != prev_c2 (adjacent constraint for right side)
                        # 3. Current c1 != curr_c2 (symmetric constraint)
                        # 4. Current c1 != curr_c2 (already covered by symmetric constraint)
                        if curr_c1 != prev_c1 and curr_c2 != prev_c2 and curr_c1 != curr_c2:
                            cost = dp[prev_c1][prev_c2] + cost_prefix[i][curr_c1] + cost_prefix[j][curr_c2]
                            if cost < new_dp[curr_c1][curr_c2]:
                                new_dp[curr_c1][curr_c2] = cost
        
        dp = new_dp
    
    # Now we need to add the last house (cost_suffix)
    # The last house has symmetric position with house 0
    # So for color c_last, it must be different from color of house 0
    
    # Find the minimum cost we can achieve with the prefix
    min_prefix_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_prefix_cost = min(min_prefix_cost, dp[c1][c2])
    
    # If minimum prefix cost is already greater than required, no solution
    if min_prefix_cost > minimum_beautiful_painting_cost:
        raise ValueError("Invalid input")
    
    # We need to find cost_suffix such that:
    # min_over_colors(prefix_min_cost + cost_suffix[color]) = minimum_beautiful_painting_cost
    
    # For each possible color of the last house, we need to check constraints with house 0
    # The last house (position n-1) is symmetric to house 0, so they must have different colors
    
    # Find the minimum cost for each possible color of the last house
    min_cost_with_color = [float('inf')] * 3
    
    for last_color in range(3):
        for first_color in range(3):
            if first_color != last_color:  # Symmetric constraint
                min_cost_with_color[last_color] = min(min_cost_with_color[last_color], dp[first_color][first_color])
    
    # Now find cost_suffix values that satisfy the equation
    for c0 in range(3):
        for c1 in range(3):
            for c2 in range(3):
                cost_suffix_val = [c0, c1, c2]
                
                # Calculate the total minimum cost with this cost_suffix
                total_min_cost = float('inf')
                for last_color in range(3):
                    if min_cost_with_color[last_color] != float('inf'):
                        total_cost = min_cost_with_color[last_color] + cost_suffix_val[last_color]
                        total_min_cost = min(total_min_cost, total_cost)
                
                if total_min_cost == minimum_beautiful_painting_cost:
                    return [cost_suffix_val]
    
    # If no solution found
    raise ValueError("Invalid input")
