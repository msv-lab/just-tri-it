# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Validate input constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # There are 3 colors available, so for each symmetric pair, we have 3 * 2 = 6 possible color combinations
    
    # dp[i][c1][c2] would be too expensive, so we'll use a different approach
    # We'll process pairs and maintain the best costs for the first i pairs
    
    # Initialize DP for the first pair
    pair_count = n // 2
    
    # For each pair position, we'll store the minimum cost and second minimum cost
    # for all valid color combinations
    
    # Process each symmetric pair
    total_cost = 0
    
    for i in range(pair_count):
        house1 = i
        house2 = n - 1 - i
        
        # Find the minimum cost combination where colors are different
        min_cost = float('inf')
        
        for color1 in range(3):
            for color2 in range(3):
                if color1 != color2:
                    current_cost = cost[house1][color1] + cost[house2][color2]
                    min_cost = min(min_cost, current_cost)
        
        total_cost += min_cost
    
    return total_cost + 1
