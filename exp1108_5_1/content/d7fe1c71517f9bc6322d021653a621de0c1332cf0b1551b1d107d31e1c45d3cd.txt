# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric positions (i, n-1-i), we need to find the minimum cost
    # where colors are different for all symmetric pairs and adjacent pairs
    
    # Precompute for each symmetric pair the possible color combinations
    # that satisfy the constraints
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i symmetric pairs, with the left house having color c1 and right house having color c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # Alternative approach: since we have only 3 colors, we can track the best costs
    # for each color combination for the current symmetric pair
    
    # Initialize DP for the first symmetric pair
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    for i in range(n // 2):
        left_idx = i
        right_idx = n - 1 - i
        
        if i == 0:
            # First symmetric pair - try all valid color combinations
            for c1 in range(3):
                for c2 in range(3):
                    if c1 != c2:  # Symmetric houses can't have same color
                        dp[c1][c2] = cost[left_idx][c1] + cost[right_idx][c2]
        else:
            new_dp = [[float('inf')] * 3 for _ in range(3)]
            
            # For current symmetric pair, try all valid color combinations
            for prev_c1 in range(3):
                for prev_c2 in range(3):
                    if dp[prev_c1][prev_c2] == float('inf'):
                        continue
                    
                    # Try all colors for current left house
                    for curr_c1 in range(3):
                        # Adjacent constraint: current left can't have same color as previous right
                        # (since they're adjacent in the circular sense)
                        if curr_c1 == prev_c2:
                            continue
                            
                        # Try all colors for current right house  
                        for curr_c2 in range(3):
                            # Symmetric constraint: current left and right can't have same color
                            if curr_c1 == curr_c2:
                                continue
                                
                            # Adjacent constraint: current right can't have same color as previous left
                            if curr_c2 == prev_c1:
                                continue
                                
                            total_cost = dp[prev_c1][prev_c2] + cost[left_idx][curr_c1] + cost[right_idx][curr_c2]
                            if total_cost < new_dp[curr_c1][curr_c2]:
                                new_dp[curr_c1][curr_c2] = total_cost
            
            dp = new_dp
    
    # Find the minimum cost among all valid final color combinations
    min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            if dp[c1][c2] < min_cost:
                min_cost = dp[c1][c2]
    
    return min_cost if min_cost != float('inf') else 0
