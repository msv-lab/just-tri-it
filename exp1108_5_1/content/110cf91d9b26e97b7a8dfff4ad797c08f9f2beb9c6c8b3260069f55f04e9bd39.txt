# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    if modulus != 998244353:
        raise ValueError("Invalid input")
    if num_vertices < 3:
        raise ValueError("Invalid input")
    if len(binary_string) != num_vertices:
        raise ValueError("Invalid input")
    if any(c not in '01' for c in binary_string):
        raise ValueError("Invalid input")
    
    N = num_vertices
    s = binary_string
    
    # Count number of ones in the string
    ones = s.count('1')
    
    # The answer can be computed using combinatorial reasoning
    # We need to count the number of valid assignments of orientations
    # to edges that yield distinct in-degree sequences
    
    # Precompute factorials and inverse factorials
    fact = [1] * (2 * N + 5)
    inv_fact = [1] * (2 * N + 5)
    
    for i in range(1, len(fact)):
        fact[i] = fact[i-1] * i % MOD
    
    def mod_pow(a, b):
        res = 1
        while b:
            if b & 1:
                res = res * a % MOD
            a = a * a % MOD
            b >>= 1
        return res
    
    inv_fact[-1] = mod_pow(fact[-1], MOD-2)
    for i in range(len(fact)-2, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def comb(n, k):
        if k < 0 or k > n:
            return 0
        return fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD
    
    # The solution involves counting the number of ways to assign orientations
    # such that the in-degree constraints are satisfied
    
    # For the cycle part, the in-degrees d_0,...,d_{N-1} are determined by
    # the x_i variables and the y_i variables
    
    # After mathematical analysis, the answer is:
    # sum_{k=0}^{ones} [comb(ones, k) * (2^k) * (sum_{i=0}^{N} comb(N, i) * comb(N + k - 2i, N))]
    
    result = 0
    for k in range(ones + 1):
        term1 = comb(ones, k) * pow(2, k, MOD) % MOD
        
        # The inner sum simplifies to comb(2N, N + k) by Vandermonde identity
        term2 = comb(2 * N, N + k)
        
        result = (result + term1 * term2) % MOD
    
    return result
