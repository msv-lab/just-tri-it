# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to find the minimum cost
    # such that both houses have different colors and also different from their adjacent symmetric pairs
    
    # We'll process symmetric pairs and maintain DP states
    # dp[i][c1][c2] would be too expensive, so we need a more efficient approach
    
    # Instead, for each symmetric pair (i, n-1-i), we consider all color combinations
    # where the two houses have different colors
    
    # Initialize DP: for the first symmetric pair, the cost is the sum of chosen colors
    # We'll store the minimum costs for the last pair's color choices
    
    # We'll use a DP that tracks the minimum cost up to a symmetric pair
    # and the colors used for the current pair
    
    # Since we have 3 colors, we can consider all 6 possible valid color pairs for symmetric houses
    
    # Initialize with the first symmetric pair
    first_i = 0
    first_j = n - 1
    
    # All valid color combinations for the first pair (different colors)
    dp = {}
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                dp[(c1, c2)] = cost[first_i][c1] + cost[first_j][c2]
    
    # Process remaining symmetric pairs
    for k in range(1, n // 2):
        i = k
        j = n - 1 - k
        
        new_dp = {}
        
        # For each possible color combination in the previous state
        for (prev_c1, prev_c2), prev_cost in dp.items():
            # For current pair, try all valid color combinations
            for c1 in range(3):
                for c2 in range(3):
                    # Check constraints:
                    # 1. Current pair houses must have different colors
                    # 2. Current left house color != previous left house color
                    # 3. Current right house color != previous right house color
                    if c1 != c2 and c1 != prev_c1 and c2 != prev_c2:
                        key = (c1, c2)
                        new_cost = prev_cost + cost[i][c1] + cost[j][c2]
                        if key not in new_dp or new_cost < new_dp[key]:
                            new_dp[key] = new_cost
        
        dp = new_dp
    
    # Find the minimum cost from all valid final states
    min_cost = min(dp.values()) if dp else 0
    
    # Add 1 to the final answer as requested
    return min_cost + 1
