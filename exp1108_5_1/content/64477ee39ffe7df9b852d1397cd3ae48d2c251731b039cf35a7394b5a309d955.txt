# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Check for invalid inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    if any(not (-10**6 <= num <= 10**6) for num in nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # The starting indices of possible subarrays of size x
    # The i-th subarray is nums[i:i+x]
    # We need to select k such subarrays that are non-overlapping
    
    # Precompute all possible subarrays and their costs
    # For each subarray, compute the minimal cost to make all elements equal (to median)
    subarray_costs = []
    subarray_medians = []
    
    for i in range(n - x + 1):
        sub = nums[i:i+x]
        # To minimize operations, we should make all elements equal to the median
        sorted_sub = sorted(sub)
        median = sorted_sub[x // 2] if x % 2 == 1 else sorted_sub[x // 2 - 1]  # lower median for even x
        cost = sum(abs(num - median) for num in sub)
        subarray_costs.append(cost)
        subarray_medians.append((i, median))
    
    # Now, we need to select k non-overlapping subarrays with minimal total cost
    # The subarrays cannot overlap, i.e., for two subarrays i and j, |i - j| >= x
    
    # We can model this as selecting k items from subarray_costs with the constraint
    # that no two selected items are within x indices of each other
    
    # We'll use a dynamic programming approach with a max-heap to efficiently track the best options
    
    # dp[i] represents the minimal cost up to index i
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    # We use a min-heap to keep track of the minimal dp[j] where j <= i - x
    heap = []
    heapq.heappush(heap, (0, -1))  # (cost, index)
    
    for i in range(n):
        # The current dp[i] is the same as dp[i-1] if we don't take the current subarray
        if i > 0:
            dp[i] = min(dp[i], dp[i-1])
        
        # If we can take the subarray ending at i (if i >= x - 1)
        if i >= x - 1:
            # The subarray starts at i - x + 1
            start = i - x + 1
            # The previous subarray must end before start
            # So we look for the minimal dp[j] where j <= start - 1
            # We use the heap to get the minimal dp[j] where j <= start - 1
            while heap and heap[0][1] < start - x:
                heapq.heappop(heap)
            if heap:
                current_cost = heap[0][0] + subarray_costs[start]
                if start + x <= n:
                    if current_cost < dp[start + x]:
                        dp[start + x] = current_cost
                        heapq.heappush(heap, (current_cost, start + x - 1))
    
    # The answer is the minimal cost to have at least k subarrays
    # However, the above approach may not directly give us the answer for k subarrays
    # We need to adjust the approach to select exactly k subarrays
    
    # Alternative approach: dynamic programming with state (index, number of subarrays taken)
    # dp[i][l] = minimal cost up to index i with l subarrays taken
    # Initialize dp[0][0] = 0, others infinity
    # Transition:
    #   If we don't take the current subarray ending at i: dp[i][l] = dp[i-1][l]
    #   If we take the current subarray ending at i (i >= x - 1), and l >= 1:
    #       dp[i][l] = min(dp[i][l], dp[j][l-1] + cost) where j <= i - x
    
    K = k
    dp_k = [[float('inf')] * (K + 1) for _ in range(n + 1)]
    dp_k[0][0] = 0
    
    for i in range(1, n + 1):
        for l in range(K + 1):
            # Option 1: do not take the current element (not part of any subarray)
            if i > 0:
                dp_k[i][l] = min(dp_k[i][l], dp_k[i-1][l])
            # Option 2: take the current subarray ending at i (if possible)
            if i >= x and l >= 1:
                start = i - x
                cost = subarray_costs[start]
                dp_k[i][l] = min(dp_k[i][l], dp_k[start][l-1] + cost)
    
    result = dp_k[n][K]
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    return result
