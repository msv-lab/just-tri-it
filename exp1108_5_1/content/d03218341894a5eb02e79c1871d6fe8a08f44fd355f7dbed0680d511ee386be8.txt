# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Input validation
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for each possible starting position of a subarray of length x
    # cost[i] = minimum operations to make subarray starting at i have all equal elements
    cost = [0] * (n - x + 1)
    
    for i in range(n - x + 1):
        # For subarray starting at i, find the median to minimize operations
        subarray = nums[i:i+x]
        sorted_sub = sorted(subarray)
        
        # Median minimizes the sum of absolute deviations
        median = sorted_sub[x // 2]
        
        # Calculate total operations to make all elements equal to median
        cost[i] = sum(abs(num - median) for num in subarray)
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # We'll use dynamic programming where dp[i][j] = min cost to select j subarrays 
    # from first i available positions
    
    # Initialize DP table
    dp = [[float('inf')] * (k + 1) for _ in range(n - x + 2)]
    dp[0][0] = 0
    
    for i in range(1, n - x + 2):
        for j in range(k + 1):
            # Option 1: Don't take the current subarray
            dp[i][j] = min(dp[i][j], dp[i-1][j])
            
            # Option 2: Take the current subarray (if we have space and it doesn't overlap)
            if j > 0 and i >= x:
                # Find the last position we can use without overlapping
                prev_pos = max(0, i - x)
                dp[i][j] = min(dp[i][j], dp[prev_pos][j-1] + cost[i-1])
    
    result = dp[n - x + 1][k]
    
    return result if result != float('inf') else 0
