# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    MOD = modulus
    N = num_vertices
    s = binary_string
    
    # Validate inputs
    if N < 3:
        raise ValueError("Invalid input")
    if len(s) != N:
        raise ValueError("Invalid input")
    if not all(c in '01' for c in s):
        raise ValueError("Invalid input")
    
    # Count number of '1's in the string
    k = s.count('1')
    
    # The graph has N edges in the cycle and k edges from vertices to vertex N
    total_edges = N + k
    
    # Precompute factorials and inverse factorials
    fact = [1] * (total_edges + 1)
    inv_fact = [1] * (total_edges + 1)
    
    for i in range(1, total_edges + 1):
        fact[i] = fact[i-1] * i % MOD
    
    # Fermat's little theorem for modular inverse
    inv_fact[total_edges] = pow(fact[total_edges], MOD-2, MOD)
    for i in range(total_edges-1, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def comb(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # The key observation:
    # For the cycle part, the in-degrees d_0,...,d_{N-1} must satisfy:
    # sum(d_i) = N (each cycle edge contributes 1 to some in-degree)
    # and the number of odd d_i must be even
    
    # For vertex N, its in-degree d_N can range from 0 to k
    
    # Count the number of sequences (d_0,...,d_{N-1}) with sum = N and even number of odd values
    # This equals 2^(N-1) + 2^((N-1)//2) if N is odd, else 2^(N-1)
    
    if N % 2 == 1:
        cycle_sequences = (pow(2, N-1, MOD) + pow(2, (N-1)//2, MOD)) % MOD
    else:
        cycle_sequences = pow(2, N-1, MOD)
    
    # For vertex N, we can choose any subset of the k edges to point towards it
    # So there are (k+1) possible in-degrees for vertex N
    
    # Total sequences = cycle_sequences * (k+1)
    result = cycle_sequences * (k + 1) % MOD
    
    return result
