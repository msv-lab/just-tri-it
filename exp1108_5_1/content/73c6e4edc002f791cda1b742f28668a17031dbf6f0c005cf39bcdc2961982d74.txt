# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not nums or x <= 0 or k <= 0 or k * x > len(nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute the cost for each possible starting position of a subarray of length x
    # cost[i] = operations needed to make nums[i:i+x] all equal to the median
    costs = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        # To minimize operations, we should make all elements equal to the median
        subarray_sorted = sorted(subarray)
        median = subarray_sorted[x // 2]  # median for odd x, or lower median for even x
        
        # Calculate operations needed
        operations = sum(abs(num - median) for num in subarray)
        costs.append((operations, i))
    
    # We need to select k non-overlapping subarrays
    # Use dynamic programming: dp[i][j] = min operations using first i positions to select j subarrays
    # But k is small (<=15), so we can use state-space search with memoization
    
    # Sort costs by starting index to help with non-overlapping constraint
    costs_sorted = sorted(costs, key=lambda item: item[1])
    
    # Use DP with state (position, count) where position is the last chosen subarray index
    # But we need to track which subarrays we choose
    
    # Alternative approach: use interval scheduling with DP
    intervals = []
    for op_cost, start in costs_sorted:
        intervals.append((start, start + x - 1, op_cost))
    
    # Sort intervals by end time
    intervals.sort(key=lambda item: item[1])
    
    # Precompute for each interval, the index of the last non-overlapping interval
    prev = [-1] * len(intervals)
    for i in range(len(intervals)):
        start_i, end_i, cost_i = intervals[i]
        # Binary search to find the last interval that ends before start_i
        lo, hi = 0, i - 1
        while lo <= hi:
            mid = (lo + hi) // 2
            if intervals[mid][1] < start_i:
                prev[i] = mid
                lo = mid + 1
            else:
                hi = mid - 1
    
    # DP[i][j] = min cost to choose j intervals from first i intervals
    m = len(intervals)
    INF = float('inf')
    dp = [[INF] * (k + 1) for _ in range(m + 1)]
    
    # Base case: 0 intervals chosen has cost 0
    for i in range(m + 1):
        dp[i][0] = 0
    
    # Fill DP table
    for i in range(1, m + 1):
        end_i, cost_i = intervals[i-1][1], intervals[i-1][2]
        prev_i = prev[i-1]  # index in intervals (0-based)
        
        for j in range(1, k + 1):
            # Option 1: don't take current interval
            dp[i][j] = min(dp[i][j], dp[i-1][j])
            
            # Option 2: take current interval
            if prev_i == -1:
                # No previous non-overlapping interval
                if j == 1:
                    dp[i][j] = min(dp[i][j], cost_i)
            else:
                dp[i][j] = min(dp[i][j], dp[prev_i + 1][j-1] + cost_i)
    
    result = dp[m][k]
    if result == INF:
        raise ValueError("Invalid input")
    
    return int(result)
