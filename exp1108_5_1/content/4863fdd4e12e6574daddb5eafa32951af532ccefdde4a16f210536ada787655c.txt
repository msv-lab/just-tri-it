# signature: def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> list[int]
from typing import List
import math

def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> List[int]:
    # Input validation
    if not nums or len(nums) < 2 or len(nums) > 10**5:
        raise ValueError("Invalid input")
    if x < 2 or x > len(nums):
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    max_k = min(15, n // x)  # k must satisfy k*x <= n
    
    result = []
    
    # Precompute prefix sums for efficient range sum calculation
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
    
    # For each possible k, calculate the minimum operations
    for k in range(1, max_k + 1):
        # We need to select k disjoint segments, each of length x
        # The optimal way is to make all elements in segment equal to the median
        # Operations = sum(|a_i - median|) for each segment
        
        # Use dynamic programming: dp[i][j] = min operations for j segments ending at or before i
        # But since k is small (<=15), we can use a simpler approach
        
        # We need to find the best k non-overlapping segments
        # This can be done with DP where state is (position, segments_used)
        dp_prev = [float('inf')] * (n + 1)
        dp_curr = [float('inf')] * (n + 1)
        dp_prev[0] = 0  # 0 segments used, 0 operations
        
        for segments in range(1, k + 1):
            for i in range(segments * x, n + 1):
                # Try to place current segment ending at i-1
                # Segment from i-x to i-1
                segment_start = i - x
                segment_end = i - 1
                
                # Calculate operations for this segment
                # Sort to find median efficiently for small x
                segment_nums = nums[segment_start:segment_end + 1]
                sorted_segment = sorted(segment_nums)
                median = sorted_segment[x // 2] if x % 2 == 1 else sorted_segment[x // 2 - 1]
                
                operations = 0
                for num in segment_nums:
                    operations += abs(num - median)
                
                # Find minimum from previous state
                min_prev = float('inf')
                for prev_end in range((segments - 1) * x, segment_start):
                    min_prev = min(min_prev, dp_prev[prev_end])
                
                if min_prev != float('inf'):
                    dp_curr[i] = min_prev + operations
            
            # Swap and reset for next iteration
            dp_prev, dp_curr = dp_curr, [float('inf')] * (n + 1)
        
        # Find minimum operations for exactly k segments
        min_ops = float('inf')
        for i in range(k * x, n + 1):
            min_ops = min(min_ops, dp_prev[i])
        
        if min_ops == min_operations_for_k_equal_subarrays:
            result.append(k)
    
    return result
