# signature: def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]
from typing import List
from collections import defaultdict

def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]:
    n = len(nums)
    if n < 2 or len(edges) != n - 1:
        raise ValueError("Invalid input")
    
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length <= 0:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Find root (node 0) and build tree structure
    parent = [-1] * n
    children = [[] for _ in range(n)]
    distances = [0] * n
    
    stack = [0]
    visited = [False] * n
    visited[0] = True
    
    while stack:
        node = stack.pop()
        for neighbor, length in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                children[node].append((neighbor, length))
                distances[neighbor] = distances[node] + length
                stack.append(neighbor)
    
    # Result: [max_length, min_nodes_for_max_length]
    result = [0, float('inf')]
    
    def dfs(node):
        # Returns: list of tuples (path_length, node_count, last_value_position)
        # where last_value_position is a dictionary mapping value to the position info
        nonlocal result
        
        if not children[node]:
            # Leaf node
            path_info = [(0, 1, {nums[node]: (0, 1)})]
            if result[0] == 0:
                result[1] = min(result[1], 1)
            elif result[0] < 0:
                result = [0, 1]
            return path_info
        
        # Collect paths from children
        child_paths = []
        for child, edge_length in children[node]:
            child_paths.append(dfs(child))
        
        # Current node's value
        current_val = nums[node]
        
        # All valid paths going through current node
        all_paths = []
        
        # Paths starting at current node
        all_paths.append((0, 1, {current_val: (0, 1)}))
        
        # Combine paths from different children
        for i, paths_from_child in enumerate(child_paths):
            for path_length, node_count, value_positions in paths_from_child:
                # Check if we can extend this path with current node
                if current_val in value_positions:
                    # Duplicate value found, cannot extend
                    continue
                
                # Extend path with current node
                new_length = path_length + children[node][i][1]
                new_count = node_count + 1
                
                # Update result if this is better
                if new_length > result[0]:
                    result[0] = new_length
                    result[1] = new_count
                elif new_length == result[0]:
                    result[1] = min(result[1], new_count)
                
                # Add to all_paths
                new_positions = value_positions.copy()
                new_positions[current_val] = (new_length, new_count)
                all_paths.append((new_length, new_count, new_positions))
        
        # Also consider paths between two different children
        for i in range(len(child_paths)):
            for j in range(i + 1, len(child_paths)):
                for len1, count1, pos1 in child_paths[i]:
                    for len2, count2, pos2 in child_paths[j]:
                        # Check if we can combine these paths through current node
                        if current_val in pos1 or current_val in pos2:
                            continue
                        
                        # Check for duplicate values between the two paths
                        has_duplicate = False
                        for val in pos1:
                            if val in pos2:
                                has_duplicate = True
                                break
                        if has_duplicate:
                            continue
                        
                        # Calculate combined path
                        edge_len1 = children[node][i][1]
                        edge_len2 = children[node][j][1]
                        total_length = len1 + len2 + edge_len1 + edge_len2
                        total_nodes = count1 + count2 + 1
                        
                        # Update result
                        if total_length > result[0]:
                            result[0] = total_length
                            result[1] = total_nodes
                        elif total_length == result[0]:
                            result[1] = min(result[1], total_nodes)
        
        # Merge paths from all children for return
        merged_paths = []
        
        # Start with paths from current node only
        merged_paths.append((0, 1, {current_val: (0, 1)}))
        
        # Add extended paths from each child
        for i, paths_from_child in enumerate(child_paths):
            for path_length, node_count, value_positions in paths_from_child:
                if current_val in value_positions:
                    continue
                
                new_length = path_length + children[node][i][1]
                new_count = node_count + 1
                new_positions = value_positions.copy()
                new_positions[current_val] = (new_length, new_count)
                
                # Add to merged_paths, keeping only the best path for each value set
                # For efficiency, we'll keep a representative set
                merged_paths.append((new_length, new_count, new_positions))
        
        # For efficiency, limit the number of paths we return
        # Sort by length descending, then by node count ascending
        merged_paths.sort(key=lambda x: (-x[0], x[1]))
        
        # Keep only a reasonable number of paths to avoid explosion
        return merged_paths[:100]
    
    dfs(0)
    
    # Handle case where no path with positive length was found
    if result[0] == 0:
        # All paths are single nodes, find the one with minimum node count (always 1)
        result[1] = 1
    
    return result
