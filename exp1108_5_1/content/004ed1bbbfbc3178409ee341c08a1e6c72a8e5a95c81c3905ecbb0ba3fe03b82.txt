# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate constraints
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for making each possible subarray of length x have all equal elements
    # For a subarray starting at index i, the optimal target value is the median of nums[i:i+x]
    # This minimizes the sum of absolute differences
    
    # Function to compute cost for making subarray [start:start+x] all equal to target
    def compute_cost(start, target):
        return sum(abs(nums[start + j] - target) for j in range(x))
    
    # Precompute costs for all possible subarrays
    subarray_costs = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        # Sort to find median
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]  # For odd x, this is median; for even, either median works
        cost = compute_cost(i, median)
        subarray_costs.append((i, cost, median))
    
    # We need to select k non-overlapping subarrays
    # Use dynamic programming: dp[i][j] = min cost to select j subarrays from first i possible positions
    # But we need to ensure subarrays don't overlap
    
    m = len(subarray_costs)  # number of possible subarrays
    
    # Initialize DP table with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        start_i, cost_i, _ = subarray_costs[i-1]
        end_i = start_i + x - 1
        
        for j in range(k + 1):
            # Option 1: Don't take current subarray
            dp[i][j] = min(dp[i][j], dp[i-1][j])
            
            # Option 2: Take current subarray (if we have space and it doesn't conflict)
            if j > 0:
                # Find the last subarray we can take before current one
                # We need to find the largest index p where end_p < start_i
                best_prev = float('inf')
                for p in range(i-1, -1, -1):
                    if p == 0:
                        best_prev = 0
                        break
                    start_p, _, _ = subarray_costs[p-1]
                    end_p = start_p + x - 1
                    if end_p < start_i:
                        best_prev = dp[p][j-1]
                        break
                
                if best_prev != float('inf'):
                    dp[i][j] = min(dp[i][j], best_prev + cost_i)
    
    # Find the minimum cost among all positions for k subarrays
    result = min(dp[i][k] for i in range(m + 1))
    
    return result if result != float('inf') else 0
