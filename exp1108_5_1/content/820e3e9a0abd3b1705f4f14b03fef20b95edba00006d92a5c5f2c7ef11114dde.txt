# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric positions (i, n-1-i), we need to find the minimum cost
    # considering that all symmetric pairs must have different colors
    # and adjacent houses must have different colors
    
    # Since n is even, we have n/2 symmetric pairs
    # We'll process each symmetric pair and track the minimum costs
    
    # For each symmetric pair (i, n-1-i), we need to consider:
    # 1. The two houses in the pair cannot have the same color
    # 2. Adjacent pairs must have different colors
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs where the left house has color c1 and right house has color c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # Alternative approach: track the best two options for each position
    # to handle the adjacent constraint
    
    # Actually, let's think about the constraints:
    # - For symmetric pair (i, n-1-i), the two houses cannot have same color
    # - Adjacent houses cannot have same color
    # - Symmetric houses cannot have same color
    
    # This is equivalent to coloring a circular arrangement with additional constraints
    # We can break it down by fixing colors for the first and last houses
    
    # Since the problem is symmetric, we can consider the first half and second half separately
    # The key observation: for position i and position n-1-i, they must have different colors
    # and they also constrain their neighbors
    
    # Let's implement a more efficient approach:
    # We'll process the array from both ends towards the middle
    
    if n == 2:
        # Only one symmetric pair
        min_cost = float('inf')
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:
                    min_cost = min(min_cost, cost[0][c1] + cost[1][c2])
        return min_cost
    
    # For larger n, we need a more efficient approach
    # We can use dynamic programming that tracks the best cost for the current pair
    # considering the colors of the previous pair
    
    # Initialize DP: dp[i][c1][c2] = min cost for first i pairs where
    # left house of current pair has color c1, right house has color c2
    # But we only need the previous state, so we can optimize space
    
    # Precompute for the first pair
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(2)]
    
    # Initialize for the first symmetric pair (0, n-1)
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric houses cannot have same color
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n // 2):
        current = i % 2
        prev = (i - 1) % 2
        
        # Reset current DP
        for c1 in range(3):
            for c2 in range(3):
                dp[current][c1][c2] = float('inf')
        
        left_idx = i
        right_idx = n - 1 - i
        
        for prev_c1 in range(3):  # Color of left house in previous pair
            for prev_c2 in range(3):  # Color of right house in previous pair
                if dp[prev][prev_c1][prev_c2] == float('inf'):
                    continue
                
                for curr_c1 in range(3):  # Color of current left house
                    if curr_c1 == prev_c1:  # Adjacent constraint
                        continue
                    for curr_c2 in range(3):  # Color of current right house
                        if curr_c2 == prev_c2:  # Adjacent constraint
                            continue
                        if curr_c1 == curr_c2:  # Symmetric constraint
                            continue
                        
                        new_cost = dp[prev][prev_c1][prev_c2] + cost[left_idx][curr_c1] + cost[right_idx][curr_c2]
                        dp[current][curr_c1][curr_c2] = min(dp[current][curr_c1][curr_c2], new_cost)
    
    # Find the minimum cost in the last state
    last = (n // 2 - 1) % 2
    min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_cost = min(min_cost, dp[last][c1][c2])
    
    return min_cost
