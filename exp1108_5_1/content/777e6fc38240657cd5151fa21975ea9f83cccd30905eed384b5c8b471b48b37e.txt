# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Validate inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    if any(not (-10**6 <= num <= 10**6) for num in nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # The starting indices of possible subarrays of size x
    possible_starts = n - x + 1
    # For each possible start index, calculate the cost to make all x elements equal to the median
    # and store the cost along with the start index
    subarray_costs = []
    
    for i in range(possible_starts):
        sub = nums[i:i+x]
        # The optimal target is the median of the subarray for minimal operations
        sub_sorted = sorted(sub)
        median = sub_sorted[x // 2] if x % 2 == 1 else sub_sorted[x // 2 - 1]
        # Calculate the total operations to make all elements in sub equal to median
        operations = sum(abs(num - median) for num in sub)
        subarray_costs.append((operations, i))
    
    # We need to select k non-overlapping subarrays with minimal total operations
    # The subarrays cannot overlap, i.e., the start indices must be at least x apart
    # This is a classic problem of selecting k non-overlapping intervals with minimal sum
    
    # We'll use dynamic programming to solve this
    # dp[i][j] represents the minimal cost to select j subarrays up to the i-th possible subarray
    # Initialize DP table
    m = possible_starts
    # We'll use a list of dictionaries or a 2D array, but with k up to 15, it's manageable
    dp = [ [float('inf')] * (k + 1) for _ in range(m + 1) ]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        current_cost, current_start = subarray_costs[i-1]
        # For each possible count of subarrays up to k
        for j in range(k + 1):
            # Option 1: do not take the current subarray
            if dp[i-1][j] < dp[i][j]:
                dp[i][j] = dp[i-1][j]
            # Option 2: take the current subarray if j >= 1 and no overlap
            if j >= 1:
                # Find the last subarray that doesn't overlap with current one
                # The last subarray must end before current_start
                last_possible = i - 1
                while last_possible >= 0:
                    _, last_start = subarray_costs[last_possible - 1] if last_possible > 0 else (0, -x)
                    if last_start + x <= current_start:
                        break
                    last_possible -= 1
                if last_possible >= 0 and dp[last_possible][j-1] + current_cost < dp[i][j]:
                    dp[i][j] = dp[last_possible][j-1] + current_cost
    
    if dp[m][k] == float('inf'):
        raise ValueError("No solution found")
    
    return dp[m][k]
