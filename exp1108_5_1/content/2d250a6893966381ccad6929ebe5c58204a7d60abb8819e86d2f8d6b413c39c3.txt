# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate constraints
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for making each possible segment of length x equal to a target value
    # We'll consider making all elements equal to the median (which minimizes absolute differences)
    
    # Function to compute minimal operations for a segment to become all equal
    def segment_cost(start_idx, target):
        return sum(abs(nums[start_idx + j] - target) for j in range(x))
    
    # We need to find k non-overlapping segments, each of length x
    # This is a dynamic programming problem: dp[i][j] = min operations using first i segments, ending at position j
    
    # Precompute all possible segment costs
    segments = []
    for i in range(n - x + 1):
        # For each segment, the optimal target is the median of the segment
        segment = nums[i:i+x]
        sorted_segment = sorted(segment)
        median = sorted_segment[x // 2]  # median minimizes absolute differences
        cost = segment_cost(i, median)
        segments.append((i, i + x - 1, cost))
    
    # DP approach: dp[j][m] = min operations to select m segments ending at or before position j
    # But k is small (<=15), so we can use a different approach
    
    # Since k is small, we can try to select k non-overlapping segments
    # We'll sort segments by end position and use DP
    
    segments.sort(key=lambda seg: seg[1])  # sort by end position
    
    # dp[i][m] = min cost to choose m segments from first i segments (sorted by end)
    # But we need to ensure non-overlapping
    
    m = len(segments)
    INF = float('inf')
    
    # Initialize DP table
    dp = [[INF] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        seg_start, seg_end, cost = segments[i-1]
        
        # Option 1: Don't take this segment
        for j in range(k + 1):
            dp[i][j] = min(dp[i][j], dp[i-1][j])
        
        # Option 2: Take this segment
        # Find the last segment that ends before this segment starts
        prev_idx = -1
        for j in range(i-1, 0, -1):
            if segments[j-1][1] < seg_start:
                prev_idx = j
                break
        
        for j in range(1, k + 1):
            if prev_idx != -1:
                dp[i][j] = min(dp[i][j], dp[prev_idx][j-1] + cost)
            else:
                if j == 1:
                    dp[i][j] = min(dp[i][j], cost)
    
    # Find the minimum cost among all possible selections of k segments
    result = INF
    for i in range(m + 1):
        if dp[i][k] < result:
            result = dp[i][k]
    
    if result == INF:
        raise ValueError("Invalid input")
    
    return int(result)
