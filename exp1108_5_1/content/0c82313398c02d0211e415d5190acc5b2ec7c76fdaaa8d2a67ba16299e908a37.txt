# signature: def longestSpecialPath_inv_nums(longest_special_path_info: List[int], edges: List[List[int]]) -> List[int]
from typing import List
from collections import defaultdict, deque

def longestSpecialPath_inv_nums(longest_special_path_info: List[int], edges: List[List[int]]) -> List[int]:
    if not longest_special_path_info or len(longest_special_path_info) != 2:
        raise ValueError("Invalid input")
    
    L, k = longest_special_path_info
    if L < 0 or k <= 0:
        raise ValueError("Invalid input")
    
    n = len(edges) + 1
    if n < 1:
        raise ValueError("Invalid input")
    
    # Build the tree
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length <= 0:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Find parent-child relationships using BFS from root 0
    parent = [-1] * n
    children = defaultdict(list)
    visited = [False] * n
    queue = deque([0])
    visited[0] = True
    
    while queue:
        node = queue.popleft()
        for neighbor, _ in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                children[node].append(neighbor)
                queue.append(neighbor)
    
    # Handle the case where L = 0 (path of length 0, just one node)
    if L == 0:
        nums = [0] * n
        return nums
    
    # We need to construct nums such that the longest special path has length L
    # and the minimum number of nodes in all such paths is k
    
    # Strategy: Create a path of length L with k nodes that has unique values
    # The rest of the nodes can have duplicate values that break longer paths
    
    nums = [0] * n
    
    # If k > L + 1, it's impossible since a path of length L has at most L+1 nodes
    if k > L + 1:
        raise ValueError("Invalid input")
    
    # Create the special path
    # We'll create a path starting from node 0 with exactly k nodes and length L
    # The path will have unique values
    
    # Find k nodes in a path of length L
    # We need to distribute the L length among k-1 edges
    
    if k == 1:
        # Single node path, length should be 0
        if L != 0:
            raise ValueError("Invalid input")
        # All nodes can have the same value
        nums = [0] * n
        return nums
    
    # For k >= 2, we need a path with k nodes and total length L
    # We'll create this path from the root downward
    
    # Assign unique values to the first k nodes in a DFS traversal
    # This ensures we have at least one special path of length L with k nodes
    
    current_node = 0
    path_nodes = []
    stack = [0]
    
    while stack and len(path_nodes) < k:
        node = stack.pop()
        path_nodes.append(node)
        # Add children in reverse order to maintain DFS order
        for child in reversed(children[node]):
            stack.append(child)
    
    if len(path_nodes) < k:
        raise ValueError("Invalid input")
    
    # Assign unique values to path nodes
    for i, node in enumerate(path_nodes):
        nums[node] = i
    
    # Assign values to remaining nodes that will break longer special paths
    # Use a value that already appears in the path to ensure no longer unique paths
    if n > k:
        remaining_value = nums[path_nodes[0]]  # Use first path node's value
        for i in range(n):
            if nums[i] == 0 and i not in path_nodes:
                nums[i] = remaining_value
    
    return nums
