# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # Collect all possible subarrays of size x
    subarrays = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        subarrays.append((i, subarray))
    
    # For each subarray, compute the cost to make all elements equal to the median (min cost)
    # and store the cost along with the start and end indices
    sub_costs = []
    for start, sub in subarrays:
        median = sorted(sub)[x // 2]
        cost = sum(abs(num - median) for num in sub)
        end = start + x - 1
        sub_costs.append((cost, start, end))
    
    # Now, select k non-overlapping subarrays with minimal total cost
    # This is similar to the weighted interval scheduling problem but with k intervals
    
    # Sort the subarrays by end index
    sub_costs.sort(key=lambda x: x[2])
    
    # Initialize DP tables
    # dp[i][j] represents the minimal cost to select j subarrays up to the i-th subarray
    m = len(sub_costs)
    dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        cost_i, start_i, end_i = sub_costs[i-1]
        # Find the largest index j where end_j < start_i
        left = 0
        right = i - 1
        best_j = -1
        while left <= right:
            mid = (left + right) // 2
            _, _, end_mid = sub_costs[mid]
            if end_mid < start_i:
                best_j = mid
                left = mid + 1
            else:
                right = mid - 1
        # Update DP table
        for l in range(k + 1):
            if dp[i-1][l] < dp[i][l]:
                dp[i][l] = dp[i-1][l]
            if l > 0 and best_j != -1:
                if dp[best_j + 1][l-1] + cost_i < dp[i][l]:
                    dp[i][l] = dp[best_j + 1][l-1] + cost_i
            elif l == 1:
                if cost_i < dp[i][l]:
                    dp[i][l] = cost_i
    
    if dp[m][k] == float('inf'):
        raise ValueError("No solution found")
    
    return dp[m][k]
