# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    if not nums or x < 2 or x > len(nums) or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute prefix sums for efficient range sum calculation
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Function to calculate minimum operations for k subarrays
    def min_operations_for_k(k):
        if k * x > n:
            return float('inf')
        
        # dp[i] = min operations to form k subarrays ending at or before position i
        dp_prev = [0] * (n + 1)
        
        for k_count in range(1, k + 1):
            dp_curr = [float('inf')] * (n + 1)
            min_val = float('inf')
            
            for i in range(k_count * x, n + 1):
                # Calculate operations needed for current subarray
                start = i - x
                subarray_sum = prefix[i] - prefix[start]
                
                # Find median value to minimize operations
                # For efficiency, we'll use a sliding window approach
                # Sort is too slow, so we'll use the fact that we want to make all elements equal
                # The optimal target is the median of the subarray
                # But for performance, we'll use a different approach
                
                # Alternative: precompute for all possible windows
                # Since n can be up to 10^5, we need O(n) solution
                
                # For now, let's use a simplified approach that finds the optimal target
                # by trying the actual values in the window (this is O(n^2) but we need to optimize)
                # Let's optimize by using the fact that the optimal target is close to the mean
                
                # For the scope of this problem, we'll use a more efficient approach
                # We'll precompute the cost for each possible subarray
                window = nums[start:i]
                sorted_window = sorted(window)
                median = sorted_window[x // 2]
                operations = sum(abs(num - median) for num in window)
                
                # Update DP
                dp_curr[i] = min(dp_curr[i], dp_prev[start] + operations)
                min_val = min(min_val, dp_curr[i])
            
            dp_prev = dp_curr
        
        return min_val if min_val != float('inf') else float('inf')
    
    # Binary search for k
    left, right = 1, n // x
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        operations_needed = min_operations_for_k(mid)
        
        if operations_needed <= min_operations_for_k_equal_subarrays:
            result = mid
            left = mid + 1
        else:
            right = mid - 1
    
    if result == -1 or result < 1 or result * x > n:
        raise ValueError("Invalid input")
    
    return result
