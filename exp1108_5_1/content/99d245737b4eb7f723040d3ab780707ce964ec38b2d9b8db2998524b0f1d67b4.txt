# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List
import heapq

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    # Validate inputs
    if not nums or x < 2 or x > len(nums) or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute operations for all possible subarrays of size x
    # For each subarray, the minimum operations = sum(|nums[i] - median|)
    subarray_ops = []
    
    # Use sliding window to compute operations for each subarray
    for i in range(n - x + 1):
        subarray = nums[i:i + x]
        # Sort to find median efficiently
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]
        
        # Calculate operations needed
        operations = sum(abs(num - median) for num in subarray)
        subarray_ops.append((operations, i))
    
    # Now we need to find k such that the minimum operations for k non-overlapping subarrays
    # equals the given value
    
    # Try all possible k values that satisfy the constraints
    max_possible_k = n // x
    
    for k in range(1, max_possible_k + 1):
        if k * x > n:  # Constraint: k * x <= n
            continue
            
        # Find minimum operations for k non-overlapping subarrays
        # This is a dynamic programming problem
        # dp[i][j] = min operations using j subarrays ending at or before position i
        
        # Since k is small (<=15), we can use DP
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(1, n + 1):
            dp[i][0] = 0
            for j in range(1, k + 1):
                # Option 1: Don't use current position
                dp[i][j] = min(dp[i][j], dp[i - 1][j])
                
                # Option 2: Use subarray ending at i-1 (if possible)
                if i >= x:
                    start_idx = i - x
                    operations = subarray_ops[start_idx][0]
                    dp[i][j] = min(dp[i][j], dp[start_idx][j - 1] + operations)
        
        min_ops = dp[n][k]
        
        if min_ops == min_operations_for_k_equal_subarrays:
            return k
    
    # If no k found, check if it's because we need to handle the "at least k" condition
    # The problem says "at least k subarrays", so we need to find the maximum k
    # where min_ops <= given_value, but we want exactly equal
    
    # Try finding k where operations are exactly equal to given value
    # If multiple, return any
    for k in range(max_possible_k, 0, -1):
        if k * x > n:
            continue
            
        # Recompute for this k to be sure
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(1, n + 1):
            dp[i][0] = 0
            for j in range(1, k + 1):
                dp[i][j] = min(dp[i][j], dp[i - 1][j])
                if i >= x:
                    start_idx = i - x
                    operations = subarray_ops[start_idx][0]
                    dp[i][j] = min(dp[i][j], dp[start_idx][j - 1] + operations)
        
        if dp[n][k] == min_operations_for_k_equal_subarrays:
            return k
    
    # If still no match found
    raise ValueError("Invalid input")
