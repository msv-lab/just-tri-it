# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if c < 0 or c > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric constraints, we need to consider pairs of houses
    # that are symmetric (i-th and (n-1-i)-th)
    # We'll process pairs and track the best costs
    
    # Initialize DP for the first pair
    # dp[i][color1][color2] would be too expensive, so we need a smarter approach
    
    # Instead, we'll process pairs and maintain the best two options
    # for the left and right sides
    
    # For each symmetric pair (i, n-1-i), we need to choose colors
    # such that:
    # 1. color_i != color_{i-1} (if i > 0)
    # 2. color_i != color_{n-1-i}
    # 3. color_{n-1-i} != color_{n-1-i+1} (if i < n/2-1)
    
    # We can use dynamic programming that processes pairs
    
    # Initialize with the first pair
    total_cost = 0
    
    # We'll process all symmetric pairs
    for i in range(n // 2):
        j = n - 1 - i  # symmetric house
        
        # For the first pair, we just need to minimize cost with different colors
        if i == 0:
            # Find the minimum cost combination where colors are different
            min_cost = float('inf')
            for color_i in range(3):
                for color_j in range(3):
                    if color_i != color_j:
                        current_cost = cost[i][color_i] + cost[j][color_j]
                        if current_cost < min_cost:
                            min_cost = current_cost
            total_cost += min_cost
            # Store the chosen colors for the next iteration
            prev_colors = [(color_i, color_j) for color_i in range(3) for color_j in range(3) 
                          if color_i != color_j and cost[i][color_i] + cost[j][color_j] == min_cost]
        else:
            # For subsequent pairs, we need to consider the previous colors
            min_cost = float('inf')
            best_color_i = -1
            best_color_j = -1
            
            for prev_color_i, prev_color_j in prev_colors:
                for color_i in range(3):
                    for color_j in range(3):
                        # Constraints:
                        # 1. color_i != prev_color_i (adjacent to previous left house)
                        # 2. color_j != prev_color_j (adjacent to previous right house)  
                        # 3. color_i != color_j (symmetric constraint)
                        if (color_i != prev_color_i and 
                            color_j != prev_color_j and 
                            color_i != color_j):
                            current_cost = cost[i][color_i] + cost[j][color_j]
                            if current_cost < min_cost:
                                min_cost = current_cost
                                best_color_i = color_i
                                best_color_j = color_j
            
            if min_cost == float('inf'):
                raise ValueError("Invalid input")
                
            total_cost += min_cost
            prev_colors = [(best_color_i, best_color_j)]
    
    return total_cost
