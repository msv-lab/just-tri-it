# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute cost for each possible starting position of a subarray
    # cost[i] = minimum operations to make subarray starting at i have all equal elements
    cost = [0] * (n - x + 1)
    target_values = [0] * (n - x + 1)
    
    for i in range(n - x + 1):
        # For subarray starting at i, length x
        subarray = nums[i:i + x]
        
        # To minimize operations, we should make all elements equal to the median
        # For odd length, median is middle element; for even, either of two middle elements works
        sorted_sub = sorted(subarray)
        
        # For even x, both middle elements give same cost
        median = sorted_sub[x // 2]
        
        # Calculate cost to make all elements equal to median
        current_cost = sum(abs(num - median) for num in subarray)
        cost[i] = current_cost
        target_values[i] = median
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # Subarrays starting at i and j overlap if |i - j| < x
    
    # Use dynamic programming with bitmask
    # dp[mask][last_end] = minimum cost using subarrays represented by mask, ending at last_end
    # last_end is the end index (exclusive) of the last chosen subarray
    
    # Precompute valid transitions
    positions = list(range(n - x + 1))
    
    # Sort positions by starting index for easier transition checking
    positions.sort()
    
    # Initialize DP
    INF = float('inf')
    dp = {}
    
    # Start with empty mask and last_end = -1 (no subarray chosen yet)
    dp[(0, -1)] = 0
    
    for mask in range(1 << k):
        for last_end, current_cost in list(dp.items()):
            if current_cost == INF:
                continue
            
            last_end_idx = last_end[1]
            mask_val = last_end[0]
            
            if mask_val != mask:
                continue
            
            # Try to add a new subarray
            for i in range(n - x + 1):
                # Check if this position is already used
                if mask & (1 << i):
                    continue
                
                # Check non-overlapping condition
                start_i = i
                end_i = i + x - 1
                
                if last_end_idx >= start_i:
                    continue
                
                new_mask = mask | (1 << i)
                new_last_end = end_i
                new_cost = current_cost + cost[i]
                
                key = (new_mask, new_last_end)
                if key not in dp or new_cost < dp[key]:
                    dp[key] = new_cost
    
    # Find minimum cost with exactly k subarrays (mask with k bits set)
    min_ops = INF
    for (mask, last_end), total_cost in dp.items():
        if bin(mask).count('1') == k:
            min_ops = min(min_ops, total_cost)
    
    if min_ops == INF:
        raise ValueError("Invalid input")
    
    return int(min_ops)
