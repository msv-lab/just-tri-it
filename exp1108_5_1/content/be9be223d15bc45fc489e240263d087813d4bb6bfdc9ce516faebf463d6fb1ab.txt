# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Validate input constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 10**5:
                raise ValueError("Invalid input")
    
    # Check if the given minimum cost is achievable
    # We need to find if there exists a coloring that satisfies:
    # 1. No two adjacent houses have same color
    # 2. Houses at symmetric positions (i and n-1-i) have different colors
    # 3. Total cost equals minimum_cost_symmetric_painting
    
    # Use dynamic programming to find the actual minimum cost
    # dp[i][c1][c2] = min cost for first i+1 pairs where symmetric pair i has colors c1 and c2
    # Since n is large, we need an efficient approach
    
    # For each symmetric pair (i, n-1-i), they must have different colors
    # And adjacent pairs must have different colors
    
    # We'll compute the minimum cost using DP that considers constraints between adjacent symmetric pairs
    INF = float('inf')
    
    # Precompute costs for each symmetric pair
    pair_costs = []
    for i in range(n // 2):
        j = n - 1 - i
        costs_for_pair = []
        for c1 in range(3):  # color for house i
            for c2 in range(3):  # color for house j
                if c1 != c2:  # symmetric constraint
                    costs_for_pair.append((c1, c2, cost[i][c1] + cost[j][c2]))
        pair_costs.append(costs_for_pair)
    
    # DP state: for each pair, for each color combination of current pair, min cost
    # Since we have adjacent constraints, we need to track the colors of current pair
    
    # Initialize DP for first pair
    dp = {}
    for c1, c2, total_cost in pair_costs[0]:
        dp[(c1, c2)] = total_cost
    
    # Process remaining pairs
    for idx in range(1, len(pair_costs)):
        new_dp = {}
        for prev_c1, prev_c2 in dp:
            for curr_c1, curr_c2, pair_cost in pair_costs[idx]:
                # Check adjacent constraints:
                # For house at position idx-1 and idx (they are adjacent)
                # prev_c2 (right house of previous symmetric pair) and curr_c1 (left house of current symmetric pair)
                # must have different colors
                if prev_c2 != curr_c1:
                    new_cost = dp[(prev_c1, prev_c2)] + pair_cost
                    key = (curr_c1, curr_c2)
                    if key not in new_dp or new_cost < new_dp[key]:
                        new_dp[key] = new_cost
        dp = new_dp
    
    # Find minimum cost from all valid final states
    actual_min_cost = INF
    for cost_val in dp.values():
        if cost_val < actual_min_cost:
            actual_min_cost = cost_val
    
    # Check if the given value matches the computed minimum cost
    if actual_min_cost == INF:
        return False
    
    # Also check if the given value is at least as good as actual minimum
    # and can be achieved with a valid coloring
    if minimum_cost_symmetric_painting < actual_min_cost:
        return False
    
    # To verify if the given cost is achievable, we need to check if there exists
    # a coloring with exactly that cost
    # We can modify the DP to track if the given cost is achievable
    
    # Reset for achievable check
    dp_achievable = {}
    for c1, c2, total_cost in pair_costs[0]:
        if total_cost <= minimum_cost_symmetric_painting:
            dp_achievable[(c1, c2)] = total_cost
    
    for idx in range(1, len(pair_costs)):
        new_dp = {}
        for prev_c1, prev_c2 in dp_achievable:
            for curr_c1, curr_c2, pair_cost in pair_costs[idx]:
                if prev_c2 != curr_c1:
                    new_cost = dp_achievable[(prev_c1, prev_c2)] + pair_cost
                    if new_cost <= minimum_cost_symmetric_painting:
                        key = (curr_c1, curr_c2)
                        if key not in new_dp or new_cost < new_dp[key]:
                            new_dp[key] = new_cost
        dp_achievable = new_dp
    
    # Check if given cost is achievable
    for cost_val in dp_achievable.values():
        if cost_val == minimum_cost_symmetric_painting:
            return True
    
    return False
