# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List
import heapq

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    # Input validation
    if not nums or x < 2 or x > len(nums) or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute the cost for each possible subarray of length x
    # The cost to make a subarray [i, i+x-1] have all equal elements is the sum of absolute differences from median
    costs = []
    
    for i in range(n - x + 1):
        subarray = nums[i:i + x]
        # Sort to find median efficiently
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]
        
        # Calculate cost: sum of |num - median| for all elements in subarray
        cost = sum(abs(num - median) for num in subarray)
        costs.append((i, cost))
    
    # Now we need to find k such that the minimum operations for k non-overlapping subarrays equals the given value
    # We'll try all possible k values that satisfy the constraints
    
    max_possible_k = n // x
    
    for k in range(1, max_possible_k + 1):
        if k * x > n:  # Constraint: k * x <= n
            continue
            
        # Find minimum operations for exactly k non-overlapping subarrays
        # This is a dynamic programming problem: dp[i][j] = min operations using j subarrays ending at or before position i
        
        # Since k is small (<= 15), we can use a greedy approach with priority queue
        # We need to select k non-overlapping subarrays with minimum total cost
        
        # Sort subarrays by end position
        subarrays = []
        for i, cost in costs:
            subarrays.append((i, i + x - 1, cost))
        
        # Sort by end position
        subarrays.sort(key=lambda s: s[1])
        
        # Use dynamic programming: dp[i] = min cost using subarrays ending at or before position i
        # But we need exactly k subarrays, so we'll use a different approach
        
        # Alternative: use interval scheduling with k selections
        # We can use a min-heap to track the best k subarrays
        
        # Since k is small, we can try all combinations using backtracking with pruning
        min_ops = find_min_operations_k_subarrays(subarrays, k, n)
        
        if min_ops == min_operations_for_k_equal_subarrays:
            return k
    
    # If no exact match found, return the closest k
    # Find k that gives the closest value to min_operations_for_k_equal_subarrays
    best_k = 1
    min_diff = float('inf')
    
    for k in range(1, max_possible_k + 1):
        if k * x > n:
            continue
            
        min_ops = find_min_operations_k_subarrays(subarrays, k, n)
        diff = abs(min_ops - min_operations_for_k_equal_subarrays)
        
        if diff < min_diff:
            min_diff = diff
            best_k = k
    
    return best_k

def find_min_operations_k_subarrays(subarrays: List[tuple], k: int, n: int) -> int:
    """Find minimum operations to select k non-overlapping subarrays"""
    if k == 0:
        return 0
    
    # Sort by start position
    subarrays.sort(key=lambda s: s[0])
    
    # Use dynamic programming with binary search
    # dp[i][j] = min cost using j subarrays with last subarray ending at or before position i
    
    # Since k is small, we can use a simpler approach
    min_cost = float('inf')
    
    # Try all possible combinations (with pruning)
    def backtrack(idx, count, total_cost, last_end):
        nonlocal min_cost
        
        if count == k:
            min_cost = min(min_cost, total_cost)
            return
        
        if idx >= len(subarrays):
            return
        
        # Prune if current total cost already exceeds minimum found
        if total_cost >= min_cost:
            return
        
        # Try including current subarray if it doesn't overlap with last one
        start, end, cost = subarrays[idx]
        if last_end < start:
            backtrack(idx + 1, count + 1, total_cost + cost, end)
        
        # Try skipping current subarray
        backtrack(idx + 1, count, total_cost, last_end)
    
    backtrack(0, 0, 0, -1)
    
    return min_cost if min_cost != float('inf') else float('inf')
