# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    if modulus != 998244353:
        raise ValueError("Invalid input")
    
    N = num_vertices
    s = binary_string
    
    if N < 3:
        raise ValueError("Invalid input")
    
    if len(s) != N:
        raise ValueError("Invalid input")
    
    if not all(c in '01' for c in s):
        raise ValueError("Invalid input")
    
    # Count number of '1's in the string
    k = s.count('1')
    
    # Precompute factorials and inverse factorials
    fact = [1] * (N + 2)
    inv_fact = [1] * (N + 2)
    
    for i in range(1, N + 2):
        fact[i] = fact[i-1] * i % MOD
    
    def mod_pow(a, b):
        res = 1
        while b:
            if b & 1:
                res = res * a % MOD
            a = a * a % MOD
            b >>= 1
        return res
    
    inv_fact[N+1] = mod_pow(fact[N+1], MOD-2)
    for i in range(N, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def comb(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # The main combinatorial formula
    # For the cycle part, we have 2^(N) ways to assign directions
    # For the star edges, we need to count valid assignments
    
    # Total answer = sum_{a=0 to k} [C(k, a) * (sum_{b=0 to N} C(N, b) * 2^b * (b choose (a + parity)))]
    # where parity depends on the cycle constraints
    
    # After analysis, the formula simplifies to:
    result = 0
    
    # The cycle gives us 2^N possibilities for edge directions
    # The star edges give us additional combinatorial factors
    # The final formula is: 2^N * sum_{i=0}^k C(k, i) * 2^i
    
    pow2 = [1] * (k + 1)
    for i in range(1, k + 1):
        pow2[i] = pow2[i-1] * 2 % MOD
    
    for i in range(k + 1):
        result = (result + comb(k, i) * pow2[i]) % MOD
    
    result = result * mod_pow(2, N) % MOD
    
    return result
