# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check input validity
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 10**5:
                raise ValueError("Invalid input")
    
    # Try to find a valid coloring with cost <= given minimum_cost_symmetric_painting
    # We'll use dynamic programming to find the minimum cost
    
    # For symmetric constraint: house i and house n-1-i cannot have same color
    # For adjacent constraint: house i and i+1 cannot have same color
    
    # We'll try all possible color combinations for the first two houses and propagate
    
    def is_valid_assignment(colors):
        # Check adjacent constraint
        for i in range(n-1):
            if colors[i] == colors[i+1]:
                return False
        
        # Check symmetric constraint
        for i in range(n//2):
            if colors[i] == colors[n-1-i]:
                return False
        
        return True
    
    def calculate_cost(colors):
        total = 0
        for i in range(n):
            total += cost[i][colors[i]]
        return total
    
    # Since n can be up to 10^5, we need a more efficient approach
    # We'll use DP where state is (position, color_at_position, color_at_symmetric_position)
    
    # But for verification, we can try a simpler approach:
    # Check if there exists any valid coloring with cost <= given value
    # and the given value is the minimum among all valid colorings
    
    # For efficiency, we'll implement a DP that finds the minimum cost
    
    INF = float('inf')
    
    # DP[i][c1][c2] = min cost for first i+1 houses and last i+1 houses,
    # where house i has color c1 and house n-1-i has color c2
    # But this would be O(n * 3^4) which is too slow for n=10^5
    
    # Alternative approach: since constraints are symmetric, we can work on pairs
    # For position i and n-1-i, they must have different colors
    # Also, adjacent houses must have different colors
    
    # Let's implement a more efficient DP that processes pairs
    
    # dp[i][c1][c2] = min cost for first i pairs, where:
    # - house i has color c1
    # - house n-1-i has color c2
    # - house i-1 has some color different from c1
    # - house n-i has some color different from c2
    # - and c1 != c2 (symmetric constraint for this pair)
    
    # Initialize DP table
    dp = [[[INF] * 3 for _ in range(3)] for _ in range(n//2)]
    
    # Initialize first pair (houses 0 and n-1)
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Fill DP table for remaining pairs
    for i in range(1, n//2):
        for c1 in range(3):  # color for house i
            for c2 in range(3):  # color for house n-1-i
                if c1 == c2:  # Symmetric constraint
                    continue
                
                current_cost = cost[i][c1] + cost[n-1-i][c2]
                
                # Try all possible colors for previous houses
                for prev_c1 in range(3):  # color for house i-1
                    if prev_c1 == c1:  # Adjacent constraint
                        continue
                    for prev_c2 in range(3):  # color for house n-i
                        if prev_c2 == c2:  # Adjacent constraint
                            continue
                        
                        dp[i][c1][c2] = min(dp[i][c1][c2], dp[i-1][prev_c1][prev_c2] + current_cost)
    
    # Find minimum cost from all valid configurations
    min_found = INF
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                min_found = min(min_found, dp[n//2 - 1][c1][c2])
    
    # Check if the given value matches our computed minimum
    if min_found == INF:
        # No valid coloring exists
        return minimum_cost_symmetric_painting == INF
    
    return min_found == minimum_cost_symmetric_painting
