# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if len(cost) != n or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    if any(not (0 <= c <= 10**5) for house in cost for c in house):
        raise ValueError("Invalid input")

    # Pair the houses: (i, n-1 - i)
    pairs = [(i, n - 1 - i) for i in range(n // 2)]
    
    # Precompute the best two colors for each pair to minimize cost
    pair_costs = []
    for a, b in pairs:
        if a == b:
            # This shouldn't happen since n is even, but just in case
            raise ValueError("Invalid input")
        # For each possible color combination between a and b, ensuring they are different
        min_cost = float('inf')
        second_min_cost = float('inf')
        best_color_a = -1
        best_color_b = -1
        
        # The cost for this pair is the sum of the two houses' costs, with different colors
        # We need to find the two best options for this pair to allow DP transitions
        # between adjacent pairs (since adjacent pairs must also have different colors)
        # So for each pair, we'll store the best two color combinations (with different colors)
        # to allow flexibility in choosing colors for adjacent pairs
        
        # For house a and house b, they must have different colors
        # We'll find the top two minimal cost combinations for colors (ca, cb) where ca != cb
        # and store (total_cost, ca, cb)
        options = []
        for ca in range(3):
            for cb in range(3):
                if ca != cb:
                    total = cost[a][ca] + cost[b][cb]
                    options.append((total, ca, cb))
        # Sort the options by total cost
        options.sort()
        # Take the top two options (if available)
        if len(options) < 2:
            raise ValueError("Invalid input")  # shouldn't happen as there are 3 colors
        pair_costs.append([options[0], options[1]])
    
    # Now, we need to select one option per pair such that for adjacent pairs,
    # the color of the left house in the current pair is different from the color of the right house in the previous pair
    # and the color of the right house in the current pair is different from the color of the left house in the next pair
    # Wait, no: adjacent pairs are not directly adjacent in terms of houses, but the pairs are adjacent in the list of pairs.
    # Actually, the constraint is that for two consecutive pairs (a_i, b_i) and (a_j, b_j), b_i and a_j are adjacent houses (since a_j = a_i + 1)
    # So the color of b_i (right house of first pair) must be different from the color of a_j (left house of next pair)
    
    # So we can model this as a DP problem where for each pair, we choose between the top two options,
    # and the choice affects the next pair's options
    
    # Initialize DP: for the first pair, we can choose either of the top two options
    if not pair_costs:
        raise ValueError("Invalid input")
    
    # DP[i][0] = minimum cost up to pair i, choosing the first option for pair i
    # DP[i][1] = minimum cost up to pair i, choosing the second option for pair i
    dp = [[0, 0] for _ in range(len(pair_costs))]
    first_pair = pair_costs[0]
    dp[0][0] = first_pair[0][0]
    dp[0][1] = first_pair[1][0]
    
    for i in range(1, len(pair_costs)):
        current_pair = pair_costs[i]
        prev_pair = pair_costs[i-1]
        # For each option of the current pair, find the compatible option from the previous pair
        # Current pair's left house is a_i, right house is b_i
        # Previous pair's left house is a_{i-1}, right house is b_{i-1}
        # The constraint is that b_{i-1} (right house of previous pair) != a_i (left house of current pair)
        # But a_i is adjacent to b_{i-1} (since a_i = b_{i-1} + 1)
        # So the color of the right house of previous pair must be different from the color of the left house of current pair
        
        # Current pair options: (total1, ca1, cb1) and (total2, ca2, cb2)
        # Previous pair options: (prev_total1, prev_ca1, prev_cb1) and (prev_total2, prev_ca2, prev_cb2)
        # For current option 0 (ca1, cb1), the previous option's cb must be != ca1
        min_cost0 = float('inf')
        min_cost1 = float('inf')
        
        # Check previous option 0
        prev_cb0 = prev_pair[0][2]
        current_ca0 = current_pair[0][1]
        if prev_cb0 != current_ca0:
            min_cost0 = min(min_cost0, dp[i-1][0] + current_pair[0][0])
        # Check previous option 1
        prev_cb1 = prev_pair[1][2]
        if prev_cb1 != current_ca0:
            min_cost0 = min(min_cost0, dp[i-1][1] + current_pair[0][0])
        
        # Check current option 1
        current_ca1 = current_pair[1][1]
        if prev_cb0 != current_ca1:
            min_cost1 = min(min_cost1, dp[i-1][0] + current_pair[1][0])
        if prev_cb1 != current_ca1:
            min_cost1 = min(min_cost1, dp[i-1][1] + current_pair[1][0])
        
        dp[i][0] = min_cost0
        dp[i][1] = min_cost1
        
        if dp[i][0] == float('inf') and dp[i][1] == float('inf'):
            raise ValueError("No valid coloring possible")
    
    return min(dp[-1][0], dp[-1][1])
