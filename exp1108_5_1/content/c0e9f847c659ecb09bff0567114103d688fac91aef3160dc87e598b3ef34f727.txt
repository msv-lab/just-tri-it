# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate constraints
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if k < 1 or k > 15:
        raise ValueError("Invalid input")
    if k * x < 2 or k * x > n:
        raise ValueError("Invalid input")
    
    # Precompute prefix sums for efficient range sum queries
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Precompute squared prefix sums for efficient range squared sum queries
    prefix_sq = [0] * (n + 1)
    for i in range(n):
        prefix_sq[i + 1] = prefix_sq[i] + nums[i] * nums[i]
    
    # Function to get sum of elements from l to r (inclusive)
    def get_sum(l, r):
        return prefix[r + 1] - prefix[l]
    
    # Function to get sum of squares of elements from l to r (inclusive)
    def get_sq_sum(l, r):
        return prefix_sq[r + 1] - prefix_sq[l]
    
    # Function to calculate minimum operations to make all elements in [l, r] equal to target
    def cost_for_range(l, r, target):
        length = r - l + 1
        current_sum = get_sum(l, r)
        current_sq_sum = get_sq_sum(l, r)
        # cost = sum((a_i - target)^2) but we need sum(|a_i - target|)
        # However, for the optimal target, the cost is minimized when target is the median
        # But for the problem, we need to find the optimal target that minimizes operations
        # Actually, the optimal target for minimizing sum(|a_i - t|) is the median
        # But we need to consider all possible subarrays
        
        # For a fixed range, the minimal operations to make all equal is:
        # Let m = median, then cost = sum(|a_i - m|)
        # But we can compute this efficiently using prefix sums
        
        # Sort is too slow, so we'll use a different approach
        # For now, we'll compute the cost directly
        total = 0
        for i in range(l, r + 1):
            total += abs(nums[i] - target)
        return total
    
    # Dynamic programming approach
    # dp[i][j] = minimum operations to have j subarrays ending at or before position i
    INF = float('inf')
    dp = [[INF] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    
    for i in range(n):
        for j in range(k + 1):
            if dp[i][j] == INF:
                continue
                
            # Option 1: Don't start a new subarray at i
            if i + 1 <= n:
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
            
            # Option 2: Start a new subarray of length x at i (if possible)
            if j + 1 <= k and i + x <= n:
                # We need to find the optimal target for subarray [i, i+x-1]
                # The optimal target is the median of this subarray for minimizing sum of absolute differences
                sub = nums[i:i+x]
                sub.sort()
                median = sub[x // 2]
                
                # Calculate cost to make all elements equal to median
                cost = 0
                for idx in range(i, i + x):
                    cost += abs(nums[idx] - median)
                
                dp[i + x][j + 1] = min(dp[i + x][j + 1], dp[i][j] + cost)
    
    result = dp[n][k]
    if result == INF:
        # Try alternative approach - use sliding window for k subarrays
        # We need to select k disjoint subarrays of length x
        from heapq import heappush, heappop
        
        # Precompute cost for each possible subarray of length x
        costs = []
        for i in range(n - x + 1):
            sub = nums[i:i+x]
            sub.sort()
            median = sub[x // 2]
            cost = 0
            for num in sub:
                cost += abs(num - median)
            costs.append((cost, i, i + x - 1))
        
        # Sort by cost
        costs.sort()
        
        # Greedy approach: pick k non-overlapping subarrays with minimum total cost
        used = [False] * n
        total_ops = 0
        count = 0
        
        for cost, start, end in costs:
            if count >= k:
                break
                
            # Check if this subarray overlaps with any previously selected subarray
            overlap = False
            for i in range(start, end + 1):
                if used[i]:
                    overlap = True
                    break
            
            if not overlap:
                total_ops += cost
                count += 1
                for i in range(start, end + 1):
                    used[i] = True
        
        if count < k:
            raise ValueError("Invalid input")
        
        result = total_ops
    
    return result + 1
