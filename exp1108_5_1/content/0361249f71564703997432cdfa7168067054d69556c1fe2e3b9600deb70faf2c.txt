# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n < 2 or n != len(cost) or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    
    # For each pair of equidistant houses, we need to choose colors such that:
    # 1. The two houses in the pair have different colors.
    # 2. The color of the left house in the pair is different from the previous left house's color.
    # 3. The color of the right house in the pair is different from the previous right house's color.
    
    # We will process pairs of houses (i, n-1-i) for i from 0 to n//2 - 1.
    # For each such pair, we need to choose colors c1 for house i and c2 for house n-1-i such that:
    # - c1 != c2 (for the equidistant condition)
    # - For i > 0, c1 != prev_c1 and c2 != prev_c2 (for adjacent conditions)
    
    # We'll use dynamic programming to keep track of the minimal cost for each possible color combination for the current pair.
    
    # Initialize DP for the first pair (0, n-1)
    # dp is a 3x3 matrix where dp[c1][c2] represents the minimal cost to paint the first i pairs with colors c1 and c2 for the current pair.
    # For the first pair, it's just cost[0][c1] + cost[n-1][c2] where c1 != c2.
    dp_prev = {}
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                dp_prev[(c1, c2)] = cost[0][c1] + cost[n-1][c2]
    
    for i in range(1, n // 2):
        current_dp = {}
        current_left = i
        current_right = n - 1 - i
        for prev_c1, prev_c2 in dp_prev:
            prev_cost = dp_prev[(prev_c1, prev_c2)]
            for c1 in range(3):
                if c1 == prev_c1:
                    continue
                for c2 in range(3):
                    if c2 == prev_c2 or c1 == c2:
                        continue
                    key = (c1, c2)
                    new_cost = prev_cost + cost[current_left][c1] + cost[current_right][c2]
                    if key not in current_dp or new_cost < current_dp[key]:
                        current_dp[key] = new_cost
        dp_prev = current_dp
        if not dp_prev:
            # No valid color combinations
            raise ValueError("No valid painting exists")
    
    return min(dp_prev.values())
