# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    for num in nums:
        if not (-10**6 <= num <= 10**6):
            raise ValueError("Invalid input")

    n = len(nums)
    # We need to select k non-overlapping subarrays of size x
    # The optimal way is to select the k subarrays with the minimal cost
    # The cost for a subarray starting at i is the sum of absolute differences
    # between each element in the subarray and the median (or mean? but median minimizes absolute deviations)
    
    # Precompute the cost for every possible subarray of size x
    # Then select the top k non-overlapping subarrays with minimal cost
    
    # Sliding window to compute the cost for each subarray of size x
    # The cost is the sum of absolute differences to the median
    
    # To compute the median efficiently, we can use two heaps (max and min)
    # But for x up to 1e5, it's O(x log x) per window, which might be too slow for n=1e5
    
    # Alternatively, since the subarray size is fixed, we can use a sorted list and maintain it
    # But for Python, without a built-in sorted list, this is tricky
    
    # Given the constraints, especially k <=15, we can consider a more efficient approach
    
    # Precompute all possible subarrays' costs
    subarray_costs = []
    
    for i in range(n - x + 1):
        sub = nums[i:i+x]
        sub_sorted = sorted(sub)
        median = sub_sorted[x // 2]
        cost = sum(abs(num - median) for num in sub)
        subarray_costs.append((i, i + x - 1, cost))
    
    # Now, we need to select k non-overlapping subarrays with minimal total cost
    # This is similar to the problem of scheduling non-overlapping intervals with minimal cost
    
    # We can use dynamic programming or a greedy approach with priority queue
    
    # Sort the subarrays by their end index
    subarray_costs.sort(key=lambda sc: sc[1])
    
    # We'll use a greedy approach with a priority queue to select the k subarrays with minimal cost
    # Initialize a list to keep track of the best k selections up to each subarray
    # This is similar to the problem of selecting k non-overlapping intervals with minimal sum
    
    # We'll use a DP approach where dp[m][j] represents the minimal cost to select m subarrays up to the j-th subarray
    # But with k up to 15 and n up to 1e5, a O(kn) solution is feasible
    
    # Initialize DP tables
    dp_prev = [0] * (len(subarray_costs) + 1)
    for m in range(1, k + 1):
        dp_current = [float('inf')] * (len(subarray_costs) + 1)
        # Use a min-heap to keep track of the minimal dp_prev[j] where subarray j doesn't overlap with current i
        heap = []
        # We need to find for each i, the minimal dp_prev[j] where subarray j ends before subarray i starts
        # So we can process subarray_costs in order and maintain a heap of possible j's
        # Initialize pointers
        ptr = 0
        for i in range(1, len(subarray_costs) + 1):
            start_i, end_i, cost_i = subarray_costs[i-1]
            # Add all j's where end_j < start_i to the heap
            while ptr < len(subarray_costs) and subarray_costs[ptr][1] < start_i:
                j = ptr + 1  # 1-based index
                heapq.heappush(heap, (dp_prev[j], j))
                ptr += 1
            # The minimal value in the heap is the best previous dp_prev[j]
            if heap:
                min_val, _ = heap[0]
                dp_current[i] = min_val + cost_i
            if m == 1:
                # For m=1, we can also choose the current subarray alone if no previous subarrays are selected
                dp_current[i] = min(dp_current[i], cost_i)
        dp_prev = dp_current
    
    min_total = min(dp_prev)
    if min_total == float('inf'):
        raise ValueError("Invalid input")
    
    return min_total
