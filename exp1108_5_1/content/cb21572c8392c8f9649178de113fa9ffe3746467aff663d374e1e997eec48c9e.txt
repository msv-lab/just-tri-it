# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    if not cost_prefix:
        n = 1
    else:
        n = len(cost_prefix) + 1
    
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(len(cost_prefix)):
        if len(cost_prefix[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost_prefix[i][j] < 0 or cost_prefix[i][j] > 100000:
                raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    INF = 10**18
    dp = [[[INF] * 3 for _ in range(3)] for _ in range(2)]
    
    if n == 2:
        for c0 in range(3):
            for c1 in range(3):
                if c0 != c1:
                    cost = cost_prefix[0][c0] + 0
                    dp[0][c0][c1] = cost
        
        result = []
        for c_last in range(3):
            for c_first in range(3):
                if c_first != c_last:
                    total_cost = dp[0][c_first][c_last] + 0
                    if total_cost == minimum_beautiful_painting_cost:
                        result.append([[0, 0, 0]])
        
        if result:
            return [[[cost_suffix_val] for cost_suffix_val in [[0, 0, 0]]]]
        else:
            return []
    
    mid = n // 2
    
    left_dp = [[[INF] * 3 for _ in range(3)] for _ in range(mid + 1)]
    right_dp = [[[INF] * 3 for _ in range(3)] for _ in range(mid + 1)]
    
    for c0 in range(3):
        for c1 in range(3):
            if c0 != c1:
                left_dp[1][c0][c1] = cost_prefix[0][c0]
    
    for i in range(1, mid - 1):
        for prev_prev in range(3):
            for prev in range(3):
                if left_dp[i][prev_prev][prev] == INF:
                    continue
                for curr in range(3):
                    if curr == prev:
                        continue
                    if i + 1 < mid and curr == prev_prev:
                        continue
                    new_cost = left_dp[i][prev_prev][prev] + cost_prefix[i][curr]
                    if new_cost < left_dp[i + 1][prev][curr]:
                        left_dp[i + 1][prev][curr] = new_cost
    
    last_left_idx = mid - 1
    for prev_prev in range(3):
        for prev in range(3):
            if left_dp[last_left_idx][prev_prev][prev] == INF:
                continue
            for curr in range(3):
                if curr == prev:
                    continue
                if last_left_idx + 1 < mid and curr == prev_prev:
                    continue
                new_cost = left_dp[last_left_idx][prev_prev][prev] + cost_prefix[last_left_idx][curr]
                if new_cost < left_dp[last_left_idx + 1][prev][curr]:
                    left_dp[last_left_idx + 1][prev][curr] = new_cost
    
    right_start_idx = n - 2
    for c0 in range(3):
        for c1 in range(3):
            if c0 != c1:
                right_dp[1][c0][c1] = cost_prefix[right_start_idx][c1]
    
    for i in range(1, mid - 1):
        for prev_prev in range(3):
            for prev in range(3):
                if right_dp[i][prev_prev][prev] == INF:
                    continue
                for curr in range(3):
                    if curr == prev:
                        continue
                    if i + 1 < mid and curr == prev_prev:
                        continue
                    idx = right_start_idx - i
                    new_cost = right_dp[i][prev_prev][prev] + cost_prefix[idx][curr]
                    if new_cost < right_dp[i + 1][prev][curr]:
                        right_dp[i + 1][prev][curr] = new_cost
    
    last_right_idx = mid - 1
    for prev_prev in range(3):
        for prev in range(3):
            if right_dp[last_right_idx][prev_prev][prev] == INF:
                continue
            for curr in range(3):
                if curr == prev:
                    continue
                if last_right_idx + 1 < mid and curr == prev_prev:
                    continue
                idx = right_start_idx - last_right_idx
                new_cost = right_dp[last_right_idx][prev_prev][prev] + cost_prefix[idx][curr]
                if new_cost < right_dp[last_right_idx + 1][prev][curr]:
                    right_dp[last_right_idx + 1][prev][curr] = new_cost
    
    result_suffixes = []
    
    for left_color_mid in range(3):
        for right_color_mid in range(3):
            if left_color_mid == right_color_mid:
                continue
            
            min_total = INF
            for left_prev in range(3):
                for right_prev in range(3):
                    left_cost = left_dp[mid][left_prev][left_color_mid]
                    right_cost = right_dp[mid][right_prev][right_color_mid]
                    if left_cost < INF and right_cost < INF:
                        total = left_cost + right_cost
                        if total < min_total:
                            min_total = total
            
            if min_total == INF:
                continue
            
            required_suffix_cost = minimum_beautiful_painting_cost - min_total
            if required_suffix_cost < 0:
                continue
            
            for color_last in range(3):
                if color_last == right_color_mid:
                    continue
                if color_last == left_color_mid:
                    continue
                
                suffix_cost = required_suffix_cost
                if 0 <= suffix_cost <= 100000:
                    cost_suffix_val = [0, 0, 0]
                    cost_suffix_val[color_last] = suffix_cost
                    result_suffixes.append([cost_suffix_val])
    
    valid_results = []
    seen = set()
    for suffix in result_suffixes:
        key = tuple(suffix[0])
        if key not in seen:
            seen.add(key)
            valid_results.append(suffix)
    
    return valid_results
