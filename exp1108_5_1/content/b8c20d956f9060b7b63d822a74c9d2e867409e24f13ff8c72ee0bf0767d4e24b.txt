# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    # Check if nums contains valid values
    for num in nums:
        if num < -10**6 or num > 10**6:
            raise ValueError("Invalid input")
    
    # We need to find k such that the minimum operations to get k subarrays equals the given value
    # The possible k values are constrained by: 1 <= k <= 15 and 2 <= k * x <= n
    possible_k = []
    for k in range(1, 16):
        if k * x <= n:
            possible_k.append(k)
    
    if not possible_k:
        raise ValueError("Invalid input")
    
    # For each candidate k, compute the minimum operations needed
    # The approach: we need to select k disjoint segments of length x
    # For each segment, the optimal target value is the median of that segment
    # The cost for a segment is sum(|num - median|) for all elements in the segment
    
    # Precompute prefix sums for efficient range sum calculations
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
    
    # Function to compute median cost for a segment [l, r]
    def segment_cost(l, r):
        length = r - l + 1
        if length != x:
            return float('inf')
        
        # Extract the segment and sort to find median
        segment = nums[l:r+1]
        sorted_segment = sorted(segment)
        median = sorted_segment[x // 2]
        
        # Calculate cost: sum(|num - median|)
        cost = 0
        for num in segment:
            cost += abs(num - median)
        return cost
    
    # For each k, we need to find the minimum operations to select k disjoint segments
    # This is a dynamic programming problem: dp[i][j] = min ops to select j segments up to index i
    
    best_k = -1
    min_diff = float('inf')
    
    for k_candidate in possible_k:
        # DP table: dp[i] = min operations to select segments up to index i
        # We only care about the last k segments
        dp_prev = [float('inf')] * (n + 1)
        dp_prev[0] = 0  # 0 operations for 0 segments
        
        for segments in range(1, k_candidate + 1):
            dp_curr = [float('inf')] * (n + 1)
            for i in range(segments * x, n + 1):
                # Try to add a new segment ending at i-1
                if i - x >= 0:
                    cost = segment_cost(i - x, i - 1)
                    if cost < float('inf'):
                        dp_curr[i] = min(dp_curr[i], dp_prev[i - x] + cost)
                # Also consider skipping this element
                dp_curr[i] = min(dp_curr[i], dp_curr[i - 1])
            dp_prev = dp_curr
        
        # Find the minimum operations for exactly k_candidate segments
        min_ops = min(dp_prev)
        
        # Check if this k_candidate gives us the desired operations
        if min_ops == min_operations_for_k_equal_subarrays:
            return k_candidate
        
        # Track the closest match
        diff = abs(min_ops - min_operations_for_k_equal_subarrays)
        if diff < min_diff:
            min_diff = diff
            best_k = k_candidate
    
    # If no exact match, return the closest one
    if best_k != -1:
        return best_k
    
    raise ValueError("Invalid input")
