# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check input validity
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if not (0 <= c <= 100000):
                raise ValueError("Invalid input")
    
    # Generate all possible valid color assignments
    from itertools import product
    
    # For each symmetric pair (i, n-1-i), they must have different colors
    # Also, adjacent houses must have different colors
    
    min_cost = float('inf')
    
    # Try all possible color combinations for the first half of houses
    # Since n is even, we have n//2 pairs
    half_n = n // 2
    
    # Precompute valid color pairs for symmetric positions
    valid_pairs = []
    for i in range(half_n):
        j = n - 1 - i
        valid_pairs_i = []
        for color_i in range(3):
            for color_j in range(3):
                # Symmetric houses cannot have same color
                if color_i != color_j:
                    # For adjacent houses (except middle pair), check constraints
                    if i > 0:
                        # We'll handle this in the DP
                        valid_pairs_i.append((color_i, color_j))
                    else:
                        valid_pairs_i.append((color_i, color_j))
        valid_pairs.append(valid_pairs_i)
    
    # Use dynamic programming to find minimum cost
    # dp[i][c1][c2] = min cost for first i pairs where pair i has colors (c1, c2)
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(half_n)]
    
    # Initialize first pair
    for color1 in range(3):
        for color2 in range(3):
            if color1 != color2:  # Symmetric constraint
                dp[0][color1][color2] = cost[0][color1] + cost[n-1][color2]
    
    # Fill DP table
    for pair_idx in range(1, half_n):
        i = pair_idx
        j = n - 1 - pair_idx
        
        for prev_color1 in range(3):
            for prev_color2 in range(3):
                if dp[pair_idx-1][prev_color1][prev_color2] == float('inf'):
                    continue
                
                for curr_color1 in range(3):
                    for curr_color2 in range(3):
                        # Check symmetric constraint
                        if curr_color1 == curr_color2:
                            continue
                        
                        # Check adjacent constraint for left side
                        if curr_color1 == prev_color1:
                            continue
                        
                        # Check adjacent constraint for right side
                        # For the right side, the previous house is j+1 (which is symmetric to i-1)
                        # So curr_color2 should not equal the color of house j+1
                        # House j+1 has the same color as house i-1 (prev_color2)
                        if curr_color2 == prev_color2:
                            continue
                        
                        current_cost = dp[pair_idx-1][prev_color1][prev_color2] + cost[i][curr_color1] + cost[j][curr_color2]
                        if current_cost < dp[pair_idx][curr_color1][curr_color2]:
                            dp[pair_idx][curr_color1][curr_color2] = current_cost
    
    # Find minimum cost from all valid configurations
    for color1 in range(3):
        for color2 in range(3):
            if color1 != color2:
                min_cost = min(min_cost, dp[half_n-1][color1][color2])
    
    # Handle special case when n == 2
    if n == 2:
        # Only symmetric constraint matters
        min_cost = float('inf')
        for color1 in range(3):
            for color2 in range(3):
                if color1 != color2:
                    min_cost = min(min_cost, cost[0][color1] + cost[1][color2])
    
    return min_cost == minimum_cost_symmetric_painting
