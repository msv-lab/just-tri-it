# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 10**5:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Check if there exists a valid coloring with the given cost
    # We'll use dynamic programming to find the minimum cost and compare
    
    # For symmetric pairs (i, n-1-i), they cannot have the same color
    # Also adjacent houses cannot have the same color
    
    # Let's find the actual minimum cost using DP
    # We need to consider all possible color combinations for symmetric pairs
    
    # Precompute the cost for each symmetric pair
    pair_costs = []
    for i in range(n // 2):
        j = n - 1 - i
        pair_cost = []
        for color_i in range(3):
            for color_j in range(3):
                if color_i != color_j:  # Symmetric constraint
                    # Check adjacent constraints for i and j
                    valid = True
                    if i > 0:  # Check left neighbor of i
                        pass  # We'll handle this in DP
                    if j < n - 1:  # Check right neighbor of j  
                        pass  # We'll handle this in DP
                    pair_cost.append((color_i, color_j, cost[i][color_i] + cost[j][color_j]))
        pair_costs.append(pair_cost)
    
    # DP approach to find minimum cost
    # dp[k][c1][c2] = minimum cost for first k pairs where last pair has colors (c1, c2)
    # But this is too slow for large n, so we need a smarter approach
    
    # Since n can be up to 10^5, we need an efficient algorithm
    # Let's use a state machine approach
    
    # For the first pair, we can use any valid color combination
    dp_prev = {}
    for color_i, color_j, total_cost in pair_costs[0]:
        dp_prev[(color_i, color_j)] = total_cost
    
    # For subsequent pairs, we need to ensure adjacent constraints
    for k in range(1, len(pair_costs)):
        dp_curr = {}
        for color_i_prev, color_j_prev in dp_prev:
            for color_i_curr, color_j_curr, pair_cost in pair_costs[k]:
                # Check adjacent constraints
                # The right color of previous pair (color_j_prev) should not equal 
                # the left color of current pair (color_i_curr)
                if color_j_prev != color_i_curr:
                    total_cost = dp_prev[(color_i_prev, color_j_prev)] + pair_cost
                    key = (color_i_curr, color_j_curr)
                    if key not in dp_curr or total_cost < dp_curr[key]:
                        dp_curr[key] = total_cost
        dp_prev = dp_curr
    
    # Find the minimum cost from all valid final states
    actual_min_cost = float('inf')
    for colors, total_cost in dp_prev.items():
        actual_min_cost = min(actual_min_cost, total_cost)
    
    # Check if the given value matches the actual minimum cost
    return actual_min_cost == minimum_cost_symmetric_painting
