# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Input validation
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for each possible starting position of a subarray of length x
    # cost[i] will be the minimum operations to make nums[i:i+x] all equal to some value
    # The optimal value to make them equal to is the median (for odd x) or any value between the two medians (for even x)
    # But for simplicity and correctness, we can use the median
    
    costs = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        sorted_sub = sorted(subarray)
        
        # Find median - for odd x it's the middle element, for even x we can use either of the two middle elements
        median = sorted_sub[x // 2]
        
        # Calculate cost to make all elements equal to median
        cost = sum(abs(num - median) for num in subarray)
        costs.append(cost)
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # Since k is small (<=15), we can use dynamic programming
    # dp[i][j] = minimum cost to select j non-overlapping subarrays from first i positions
    
    # Initialize DP table
    dp = [[float('inf')] * (k + 1) for _ in range(len(costs) + 1)]
    
    # Base case: 0 subarrays cost 0
    for i in range(len(costs) + 1):
        dp[i][0] = 0
    
    # Fill DP table
    for j in range(1, k + 1):
        for i in range(len(costs)):
            # Option 1: Don't take current subarray
            dp[i+1][j] = min(dp[i+1][j], dp[i][j])
            
            # Option 2: Take current subarray (if we have enough space for j-1 subarrays before)
            if i >= x:
                dp[i+1][j] = min(dp[i+1][j], dp[i-x+1][j-1] + costs[i])
            else:
                if j == 1:
                    dp[i+1][j] = min(dp[i+1][j], costs[i])
    
    # Find the minimum cost across all positions for exactly k subarrays
    result = min(dp[i][k] for i in range(len(costs) + 1))
    
    return result
