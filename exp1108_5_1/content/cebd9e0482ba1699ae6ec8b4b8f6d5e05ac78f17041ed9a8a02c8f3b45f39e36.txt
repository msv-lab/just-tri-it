# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    if modulus != 998244353:
        raise ValueError("Invalid input")
    
    N = num_vertices
    s = binary_string
    
    if N < 3:
        raise ValueError("Invalid input")
    
    if len(s) != N:
        raise ValueError("Invalid input")
    
    if not all(c in '01' for c in s):
        raise ValueError("Invalid input")
    
    # Count number of '1's in s
    k = s.count('1')
    
    # Precompute factorials and inverse factorials
    fact = [1] * (2 * N + 5)
    inv_fact = [1] * (2 * N + 5)
    
    for i in range(1, len(fact)):
        fact[i] = fact[i-1] * i % MOD
    
    # Fermat's little theorem for modular inverse
    inv_fact[-1] = pow(fact[-1], MOD-2, MOD)
    for i in range(len(fact)-2, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def nCr(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # The main combinatorial formula
    # For the cycle part: each vertex can have in-degree 0, 1, or 2 from cycle edges
    # For the star part: vertex N can have in-degree from 0 to k
    # The sequences are counted using generating functions
    
    result = 0
    
    # We iterate over possible in-degrees for vertex N from star edges
    for dN in range(k + 1):
        # The remaining k - dN edges from vertex N to other vertices must be outgoing from N
        # So those vertices get +1 in-degree from star edges
        
        # For the cycle: each vertex has 2 incident cycle edges
        # Let x_i be the in-degree from cycle edges for vertex i
        # Then 0 <= x_i <= 2, and sum(x_i) = N (since each edge contributes to exactly one in-degree)
        
        # The generating function for cycle part is coefficient of x^N in (1 + x + x^2)^N
        # But we need to account for constraints from star edges
        
        # Let's use inclusion-exclusion for the cycle part
        cycle_ways = 0
        for t in range(N + 1):
            # Number of vertices with in-degree >= 2 from cycle
            # Using inclusion-exclusion formula
            sign = 1 if t % 2 == 0 else -1
            term = nCr(N, t) * nCr(N + N - 2 * t - 1, N - 1) % MOD
            cycle_ways = (cycle_ways + sign * term) % MOD
        
        # For star edges: we choose which dN of the k edges are incoming to vertex N
        star_ways = nCr(k, dN)
        
        # Multiply and add to result
        result = (result + cycle_ways * star_ways) % MOD
    
    return result
