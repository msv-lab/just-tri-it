# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    if not cost_prefix:
        n = 1
    else:
        n = len(cost_prefix) + 1
    
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    if cost_prefix and any(len(row) != 3 for row in cost_prefix):
        raise ValueError("Invalid input")
    
    if cost_prefix and any(not (0 <= cost <= 10**5) for row in cost_prefix for cost in row):
        raise ValueError("Invalid input")
    
    if not (0 <= minimum_beautiful_painting_cost <= 10**5 * n):
        raise ValueError("Invalid input")
    
    if n == 2:
        results = []
        for c0 in range(3):
            for c1 in range(3):
                if c0 != c1:
                    total_cost = cost_prefix[0][c0] + cost_prefix[1][c1] if cost_prefix else 0
                    if total_cost == minimum_beautiful_painting_cost:
                        results.append([[cost_prefix[1][c1]]] if cost_prefix else [[0]])
        return results
    
    dp_forward = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n//2)]
    
    if n > 2:
        for c0 in range(3):
            for c1 in range(3):
                if c0 != c1:
                    dp_forward[0][c0][c1] = cost_prefix[0][c0] + cost_prefix[n-2][c1]
        
        for i in range(1, n//2 - 1):
            for c_prev in range(3):
                for c_curr in range(3):
                    if c_prev != c_curr:
                        for c_sym in range(3):
                            if c_sym != c_curr and c_sym != c_prev:
                                dp_forward[i][c_curr][c_sym] = min(
                                    dp_forward[i][c_curr][c_sym],
                                    dp_forward[i-1][c_prev][c_sym] + cost_prefix[i][c_curr] + cost_prefix[n-2-i][c_sym]
                                )
    
    dp_backward = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n//2)]
    
    middle = n//2 - 1
    for c_left in range(3):
        for c_right in range(3):
            if c_left != c_right:
                dp_backward[middle][c_left][c_right] = 0
    
    for i in range(middle-1, -1, -1):
        for c_left in range(3):
            for c_right in range(3):
                if c_left != c_right:
                    for c_next_left in range(3):
                        if c_next_left != c_left:
                            for c_next_right in range(3):
                                if c_next_right != c_right and c_next_right != c_next_left:
                                    dp_backward[i][c_left][c_right] = min(
                                        dp_backward[i][c_left][c_right],
                                        dp_backward[i+1][c_next_left][c_next_right] + cost_prefix[i+1][c_next_left] + cost_prefix[n-3-i][c_next_right]
                                    )
    
    results = []
    for c_last in range(3):
        suffix_cost = [0, 0, 0]
        suffix_cost[c_last] = 0
        
        min_total = float('inf')
        for c0 in range(3):
            for cn in range(3):
                if c0 != cn and cn != c_last and c0 != c_last:
                    total = dp_forward[0][c0][cn] + dp_backward[0][c0][cn] + suffix_cost[c_last]
                    min_total = min(min_total, total)
        
        if min_total == minimum_beautiful_painting_cost:
            results.append([[suffix_cost]])
    
    return results
