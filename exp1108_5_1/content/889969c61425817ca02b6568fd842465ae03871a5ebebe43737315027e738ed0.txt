# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    if not cost_prefix:
        n = 1
    else:
        n = len(cost_prefix) + 1
    
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    if cost_prefix and any(len(row) != 3 for row in cost_prefix):
        raise ValueError("Invalid input")
    
    if cost_prefix and any(not (0 <= cost <= 10**5) for row in cost_prefix for cost in row):
        raise ValueError("Invalid input")
    
    if not (0 <= minimum_beautiful_painting_cost <= 10**5):
        raise ValueError("Invalid input")
    
    INF = 10**18
    dp = [[[INF, INF, INF] for _ in range(3)] for _ in range(2)]
    
    if n == 2:
        for c0 in range(3):
            for c1 in range(3):
                if c0 != c1:
                    cost = cost_prefix[0][c0] + 0
                    dp[1][c0][c1] = min(dp[1][c0][c1], cost)
    else:
        for c0 in range(3):
            for c1 in range(3):
                if c0 != c1:
                    dp[1][c0][c1] = cost_prefix[0][c0]
        
        for i in range(1, n-1):
            new_dp = [[INF, INF, INF] for _ in range(3)]
            for prev2 in range(3):
                for prev1 in range(3):
                    if dp[i % 2][prev2][prev1] == INF:
                        continue
                    for curr in range(3):
                        if curr == prev1:
                            continue
                        if i + 1 < n // 2 and curr == prev2:
                            continue
                        if i + 1 >= n // 2:
                            mirror_idx = n - 2 - i
                            if mirror_idx < n // 2:
                                mirror_color = dp[mirror_idx % 2][prev2][prev1] if mirror_idx == i else None
                                if mirror_color is not None and curr == mirror_color:
                                    continue
                        cost = dp[i % 2][prev2][prev1] + cost_prefix[i][curr]
                        new_dp[prev1][curr] = min(new_dp[prev1][curr], cost)
            dp[(i+1) % 2] = new_dp
    
    result = []
    last_idx = (n-2) % 2
    
    for c_prev2 in range(3):
        for c_prev1 in range(3):
            if dp[last_idx][c_prev2][c_prev1] == INF:
                continue
            for c_last in range(3):
                if c_last == c_prev1:
                    continue
                mirror_idx = 0
                if mirror_idx < n // 2:
                    if c_last == c_prev2:
                        continue
                total_cost = dp[last_idx][c_prev2][c_prev1] + 0
                if total_cost == minimum_beautiful_painting_cost:
                    result.append([[c_last]])
    
    return result
