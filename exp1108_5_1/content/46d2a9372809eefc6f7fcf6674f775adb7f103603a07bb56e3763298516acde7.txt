# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0:
        raise ValueError("Invalid input")
    if n < 2 or n > 100000:
        raise ValueError("Invalid input")
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For each position, we need to track the minimum cost for each color
    # considering the symmetry constraint
    dp = [[0] * 3 for _ in range(n)]
    
    # Initialize first half
    for j in range(3):
        dp[0][j] = cost[0][j]
    
    # Fill DP for first half
    for i in range(1, n // 2):
        for j in range(3):
            min_prev = float('inf')
            for k in range(3):
                if k != j:
                    min_prev = min(min_prev, dp[i-1][k])
            dp[i][j] = min_prev + cost[i][j]
    
    # For the second half, we need to consider the symmetry constraint
    # House at position i must have different color from house at position n-1-i
    for i in range(n // 2, n):
        sym_i = n - 1 - i  # symmetric position
        for j in range(3):
            # Cannot have same color as symmetric house
            # Also cannot have same color as previous house
            min_prev = float('inf')
            for k in range(3):
                if k != j and k != dp[sym_i][1]:  # dp[sym_i][1] stores the color chosen at symmetric position
                    if i > n // 2:  # Not the first house of second half
                        # Also check previous house in second half
                        for prev_color in range(3):
                            if prev_color != j:
                                candidate = dp[i-1][prev_color] + cost[i][j]
                                if dp[sym_i][0] == k:  # Check if symmetric house has color k
                                    min_prev = min(min_prev, candidate)
                    else:
                        # First house of second half, only check symmetric constraint
                        if dp[sym_i][0] != k:  # Symmetric house color stored in dp[sym_i][0]
                            min_prev = min(min_prev, dp[i-1][k] + cost[i][j])
            dp[i][j] = min_prev
    
    # Find minimum cost in last house
    return min(dp[n-1][j] for j in range(3))
