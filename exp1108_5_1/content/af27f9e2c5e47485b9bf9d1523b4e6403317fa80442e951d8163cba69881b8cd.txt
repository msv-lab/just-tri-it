# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n <= 0 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    if len(cost) != n or any(len(row) != 3 for row in cost):
        raise ValueError("Invalid input")
    
    if any(any(c < 0 for c in row) for row in cost):
        raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses must have different colors
    
    # dp[i][c1][c2] = min cost for first i pairs where the i-th pair has colors c1 and c2
    # But this would be O(n * 3^4) which is too slow for n up to 10^5
    
    # Instead, we can process pairs independently with constraints
    
    # For each symmetric pair (i, n-1-i), we need to choose colors (a, b) such that:
    # 1. a != b (symmetric constraint)
    # 2. For adjacent pairs (i-1, i): the right color of previous pair != left color of current pair
    # 3. For adjacent pairs (i, i+1): the right color of current pair != left color of next pair
    
    # We can use dynamic programming where state is (color_left, color_right) for current pair
    
    # Initialize DP for first pair
    dp = {}
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[(c1, c2)] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n//2):
        new_dp = {}
        for (prev_c1, prev_c2), prev_cost in dp.items():
            for curr_c1 in range(3):
                for curr_c2 in range(3):
                    if (curr_c1 != curr_c2 and  # Symmetric constraint
                        curr_c1 != prev_c2):    # Adjacent constraint between pairs
                        key = (curr_c1, curr_c2)
                        new_cost = prev_cost + cost[i][curr_c1] + cost[n-1-i][curr_c2]
                        if key not in new_dp or new_cost < new_dp[key]:
                            new_dp[key] = new_cost
        dp = new_dp
    
    return min(dp.values()) if dp else 0
