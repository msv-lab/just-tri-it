# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if not (0 <= cost[i][j] <= 10**5):
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Calculate the actual minimum cost using dynamic programming
    # We need to consider both constraints: adjacent houses and symmetric houses
    
    # For symmetric constraint: houses i and n-1-i must have different colors
    # For adjacent constraint: houses i and i+1 must have different colors
    
    # Since n is even, we can pair houses (i, n-1-i) for i = 0 to n/2-1
    # Each pair must have different colors from each other and from adjacent pairs
    
    # We'll use DP where dp[i][c1][c2] = min cost for first i pairs where
    # the i-th pair has colors (c1, c2) for the left and right house respectively
    
    # But with n up to 10^5, we need a more efficient approach
    # Since each house has only 3 color choices, we can work with pairs
    
    # Precompute costs for each symmetric pair
    pair_costs = []
    for i in range(n // 2):
        left_idx, right_idx = i, n - 1 - i
        pair_cost = []
        for c1 in range(3):  # color for left house
            for c2 in range(3):  # color for right house
                if c1 != c2:  # symmetric constraint: different colors
                    total_cost = cost[left_idx][c1] + cost[right_idx][c2]
                    pair_cost.append((c1, c2, total_cost))
        pair_costs.append(pair_cost)
    
    # Now we need to ensure adjacent pairs also satisfy the constraint
    # For adjacent pairs (i-1, i), the right color of pair i-1 != left color of pair i
    
    # Initialize DP for the first pair
    dp = {}
    for c1, c2, total in pair_costs[0]:
        dp[(c1, c2)] = total
    
    # Process remaining pairs
    for i in range(1, len(pair_costs)):
        new_dp = {}
        for prev_c1, prev_c2 in dp:
            for curr_c1, curr_c2, curr_cost in pair_costs[i]:
                # Check adjacent constraint: right color of previous pair != left color of current pair
                if prev_c2 != curr_c1:
                    new_cost = dp[(prev_c1, prev_c2)] + curr_cost
                    key = (curr_c1, curr_c2)
                    if key not in new_dp or new_dp[key] > new_cost:
                        new_dp[key] = new_cost
        dp = new_dp
    
    # Find the minimum cost from all valid configurations
    actual_min_cost = float('inf')
    for cost_val in dp.values():
        actual_min_cost = min(actual_min_cost, cost_val)
    
    # Check if the given value matches the calculated minimum
    return minimum_cost_symmetric_painting == actual_min_cost
