# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    n = len(cost_prefix) + 1
    
    # Check constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    if not cost_prefix:
        if n != 1:
            raise ValueError("Invalid input")
        # Special case: n=1, but n must be even and >=2 per constraints
        raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for cost in row:
            if cost < 0 or cost > 100000:
                raise ValueError("Invalid input")
    
    # Dynamic programming approach to find minimum costs for valid colorings
    # We need to track costs for the first n-1 houses
    
    # Initialize DP table for the first house
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(2)]
    
    # For the first house, we can use any color
    for c0 in range(3):
        dp[0][c0][c0] = cost_prefix[0][c0]
    
    # Process houses 1 to n-2
    for i in range(1, n - 1):
        new_dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(2)]
        
        for prev_prev_color in range(3):
            for prev_color in range(3):
                for current_color in range(3):
                    # Check adjacent constraint
                    if prev_color == current_color:
                        continue
                    
                    # Update DP state
                    for state in range(2):
                        if dp[state][prev_prev_color][prev_color] == float('inf'):
                            continue
                        
                        new_cost = dp[state][prev_prev_color][prev_color] + cost_prefix[i][current_color]
                        
                        # Check symmetric constraint for houses equidistant from ends
                        symmetric_idx = n - 2 - i  # 0-indexed position of symmetric house
                        if symmetric_idx < i:  # We've already processed the symmetric house
                            symmetric_color = None
                            if symmetric_idx == 0:
                                symmetric_color = prev_prev_color
                            else:
                                # For simplicity, we'll track both ends
                                pass
                        
                        new_dp[state][prev_color][current_color] = min(
                            new_dp[state][prev_color][current_color], 
                            new_cost
                        )
        
        dp = new_dp
    
    # Now we need to consider the last house (cost_suffix)
    # We'll find all possible cost_suffix values that make the total cost equal to minimum_beautiful_painting_cost
    
    result = []
    
    # Try all possible colors for the last house
    for last_color in range(3):
        # Try all possible colors for the second-to-last house
        for prev_color in range(3):
            # Check adjacent constraint
            if prev_color == last_color:
                continue
            
            # Check symmetric constraint for the last house
            # The symmetric house is the first house (index 0)
            for first_color in range(3):
                if first_color == last_color:
                    continue
                
                # Find the minimum cost that ends with prev_color and has first_color as the first house
                min_cost = float('inf')
                
                for state in range(2):
                    for prev_prev_color in range(3):
                        if dp[state][prev_prev_color][prev_color] != float('inf'):
                            # Verify first house color matches our assumption
                            if state == 0 and prev_prev_color == first_color:
                                total_cost = dp[state][prev_prev_color][prev_color] + cost_suffix_value
                                min_cost = min(min_cost, total_cost)
                
                # Check if this combination gives us the desired minimum cost
                # We need to consider all possible cost_suffix values
                for cost_suffix_value in range(0, 100001):  # Constraint: 0 <= cost <= 100000
                    if min_cost + cost_suffix_value == minimum_beautiful_painting_cost:
                        result.append([[cost_suffix_value] * 3])
    
    # Remove duplicates and return
    unique_result = []
    seen = set()
    for item in result:
        key = tuple(item[0])
        if key not in seen:
            seen.add(key)
            unique_result.append(item)
    
    return unique_result
