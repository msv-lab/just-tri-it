# signature: def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> list[int]
from typing import List
import heapq

def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> List[int]:
    # Input validation
    if not nums or x < 2 or x > len(nums) or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    max_k = min(15, n // x)  # k cannot exceed n//x and is at most 15
    
    if max_k < 1:
        return []
    
    # Precompute operations for all possible segments
    segment_ops = []
    for i in range(n - x + 1):
        segment = nums[i:i + x]
        sorted_segment = sorted(segment)
        median = sorted_segment[x // 2]
        operations = sum(abs(num - median) for num in segment)
        segment_ops.append((i, operations))
    
    # For each k, find the minimum total operations using dynamic programming
    valid_k = []
    
    for k in range(1, max_k + 1):
        if k * x > n:
            continue
            
        # DP table: dp[i][j] = min operations for j segments ending at or before position i
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
        
        # Base case: 0 segments require 0 operations
        for i in range(n + 1):
            dp[i][0] = 0
        
        # Fill DP table
        for j in range(1, k + 1):
            for i in range(j * x, n + 1):
                # Option 1: don't use the current segment ending at i-1
                dp[i][j] = dp[i - 1][j]
                
                # Option 2: use the segment ending at i-1
                if i - x >= 0:
                    start_idx = i - x
                    segment_cost = segment_ops[start_idx][1]
                    dp[i][j] = min(dp[i][j], dp[i - x][j - 1] + segment_cost)
        
        min_ops = dp[n][k]
        
        if min_ops == min_operations_for_k_equal_subarrays:
            valid_k.append(k)
    
    return valid_k
