# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List
import heapq

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    # Input validation
    if not nums or x < 2 or x > len(nums) or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute prefix sums for efficient range sum calculation
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
    
    # For each possible starting position, calculate the cost to make x consecutive elements equal
    # The optimal target value is the median of the subarray for minimal operations
    costs = []
    
    for i in range(n - x + 1):
        # Extract the subarray of size x starting at position i
        subarray = nums[i:i + x]
        
        # Sort to find median
        sorted_sub = sorted(subarray)
        
        # For odd x, median is middle element; for even x, either middle element works
        median = sorted_sub[x // 2]
        
        # Calculate cost: sum of absolute differences from median
        cost = 0
        for num in subarray:
            cost += abs(num - median)
        
        costs.append((cost, i))
    
    # Sort costs in ascending order
    costs.sort(key=lambda x: x[0])
    
    # Try different values of k to find the one that matches the given min_operations
    max_possible_k = n // x
    
    for k in range(1, max_possible_k + 1):
        if k * x > n:
            break
            
        # Find the minimum operations for k non-overlapping subarrays
        # We need to select k subarrays with minimal total cost that don't overlap
        min_ops = find_min_operations_for_k(costs, k, x, n)
        
        if min_ops == min_operations_for_k_equal_subarrays:
            return k
    
    # If no exact match found, find the closest
    # For multiple possibilities, return any valid one
    best_k = 1
    min_diff = float('inf')
    
    for k in range(1, max_possible_k + 1):
        if k * x > n:
            break
            
        min_ops = find_min_operations_for_k(costs, k, x, n)
        diff = abs(min_ops - min_operations_for_k_equal_subarrays)
        
        if diff < min_diff:
            min_diff = diff
            best_k = k
    
    return best_k

def find_min_operations_for_k(costs: List[tuple], k: int, x: int, n: int) -> int:
    """Find minimum operations to select k non-overlapping subarrays from sorted costs."""
    if k == 0:
        return 0
    
    # Use dynamic programming to find k non-overlapping subarrays with minimal total cost
    # dp[i] = minimum cost to select subarrays up to position i
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    # Try to select k subarrays greedily from the sorted costs
    selected = []
    total_cost = 0
    
    for cost, start in costs:
        # Check if this subarray overlaps with any previously selected
        can_select = True
        for _, prev_start in selected:
            if max(start, prev_start) < min(start + x, prev_start + x):
                can_select = False
                break
        
        if can_select:
            selected.append((cost, start))
            total_cost += cost
            if len(selected) == k:
                break
    
    return total_cost if len(selected) == k else float('inf')
