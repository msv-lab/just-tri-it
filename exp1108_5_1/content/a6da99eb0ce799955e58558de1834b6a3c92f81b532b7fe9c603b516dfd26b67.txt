# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    n = len(cost_prefix) + 1
    
    # Check constraints
    if n == 0:
        if minimum_beautiful_painting_cost == 0:
            return [[]]
        else:
            raise ValueError("Invalid input")
    
    if n % 2 != 0 or n < 2:
        raise ValueError("Invalid input")
    
    if len(cost_prefix) != n - 1:
        raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    # Dynamic programming approach to find minimum cost for first n-1 houses
    # We need to track costs for different color combinations at symmetric positions
    
    # Initialize DP for the first half of houses
    half = n // 2
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # Initialize for first pair (house 0 and house n-1)
    for c0 in range(3):
        for c_last in range(3):
            if c0 != c_last:  # Symmetric constraint
                dp[c0][c_last] = cost_prefix[0][c0] + cost_prefix[n-2][c_last]
    
    # Process remaining pairs
    for i in range(1, half):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c0 in range(3):
            for prev_c_last in range(3):
                if dp[prev_c0][prev_c_last] == float('inf'):
                    continue
                
                # Current pair: house i and house n-1-i
                for c_i in range(3):
                    # Adjacent constraint for house i-1 and house i
                    if c_i == prev_c0:
                        continue
                    
                    for c_n_minus_i in range(3):
                        # Adjacent constraint for house n-i and house n-1-i
                        if c_n_minus_i == prev_c_last:
                            continue
                        
                        # Symmetric constraint for current pair
                        if c_i == c_n_minus_i:
                            continue
                        
                        cost = dp[prev_c0][prev_c_last] + cost_prefix[i][c_i] + cost_prefix[n-1-i][c_n_minus_i]
                        new_dp[c_i][c_n_minus_i] = min(new_dp[c_i][c_n_minus_i], cost)
        
        dp = new_dp
    
    # Now we need to find cost_suffix values that make the total minimum cost equal to minimum_beautiful_painting_cost
    # The last house is at position n-1, which we've already considered in our DP
    
    # Find the minimum cost without the suffix
    min_cost_without_suffix = float('inf')
    for c0 in range(3):
        for c_last in range(3):
            min_cost_without_suffix = min(min_cost_without_suffix, dp[c0][c_last])
    
    # If the minimum cost without suffix is already greater than target, no solution
    if min_cost_without_suffix > minimum_beautiful_painting_cost:
        raise ValueError("Invalid input")
    
    # We need to adjust for the fact that we included the last house in our DP calculation
    # but we haven't added the cost_suffix yet. Actually, we need to reconsider our approach.
    
    # Let's recalculate: we have n-1 houses in cost_prefix, and we need to add cost_suffix for the last house
    # But wait, the problem says cost_suffix contains only the last element
    
    # Actually, let's think differently: we need to find cost_suffix such that when added to our DP result,
    # we get exactly minimum_beautiful_painting_cost
    
    # Find all possible color combinations for the last pair (house half-1 and house half)
    result_suffix = None
    
    for c_half_minus_1 in range(3):
        for c_half in range(3):
            # Check adjacent constraint for house half-1 and house half
            if c_half_minus_1 == c_half:
                continue
            
            # Check symmetric constraint for house half-1 and house half
            # Since n is even, house half-1 and house half are symmetric to each other
            if c_half_minus_1 == c_half:
                continue
            
            # Find the minimum cost for first n-2 houses ending with color c_half_minus_1 at position half-1
            # and color c_half at position half
            
            # We need to recalculate DP properly
            pass
    
    # For now, let's use a simpler approach: try to find any cost_suffix that works
    for c0 in range(3):
        for c_last in range(3):
            current_cost = dp[c0][c_last]
            
            # We need to add cost_suffix[0][c_last] to get the total cost
            # But wait, we already included the cost for the last house from cost_prefix
            # Let me reconsider the problem statement
            
            # Actually, the full cost array is cost_prefix + cost_suffix
            # cost_prefix has first n-1 houses, cost_suffix has last house
            # So in our DP, we used cost_prefix for all houses including the last one
            # but the problem says cost_suffix contains the last house
            
            # This seems contradictory. Let me assume that cost_prefix has houses 0 to n-2
            # and cost_suffix has house n-1
            
            # Recalculate DP without including the last house
    dp2 = [[float('inf')] * 3 for _ in range(3)]
    
    # Initialize for first pair (house 0 and house n-2)
    for c0 in range(3):
        for c_n_minus_2 in range(3):
            if c0 != c_n_minus_2:  # Symmetric constraint
                dp2[c0][c_n_minus_2] = cost_prefix[0][c0] + cost_prefix[n-2][c_n_minus_2]
    
    # Process remaining pairs (excluding the last house)
    for i in range(1, half - 1):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c0 in range(3):
            for prev_c_n_minus_2 in range(3):
                if dp2[prev_c0][prev_c_n_minus_2] == float('inf'):
                    continue
                
                for c_i in range(3):
                    if c_i == prev_c0:
                        continue
                    
                    for c_n_minus_1_minus_i in range(3):
                        if c_n_minus_1_minus_i == prev_c_n_minus_2:
                            continue
                        
                        if c_i == c_n_minus_1_minus_i:
                            continue
                        
                        cost = dp2[prev_c0][prev_c_n_minus_2] + cost_prefix[i][c_i] + cost_prefix[n-1-i][c_n_minus_1_minus_i]
                        new_dp[c_i][c_n_minus_1_minus_i] = min(new_dp[c_i][c_n_minus_1_minus_i], cost)
        
        dp2 = new_dp
    
    # Now find cost_suffix that makes total cost equal to minimum_beautiful_painting_cost
    for c_half_minus_2 in range(3):
        for c_half_minus_1 in range(3):
            if dp2[c_half_minus_2][c_half_minus_1] == float('inf'):
                continue
            
            # For the last house (position n-1), we need to choose a color
            for c_last in range(3):
                # Check adjacent constraint with house n-2
                if c_last == c_half_minus_1:
                    continue
                
                # Check symmetric constraint with house 0
                if c_last == c_half_minus_2:
                    continue
                
                total_cost = dp2[c_half_minus_2][c_half_minus_1] 
                
                # We need to add cost_suffix for the chosen color
                # Let's set cost_suffix such that total_cost + cost_suffix[0][c_last] = minimum_beautiful_painting_cost
                required_suffix_cost = minimum_beautiful_painting_cost - total_cost
                
                if 0 <= required_suffix_cost <= 100000:
                    cost_suffix = [[0, 0, 0]]
                    cost_suffix[0][c_last] = required_suffix_cost
                    # Set other colors to high values to ensure our chosen color is selected
                    for other_c in range(3):
                        if other_c != c_last:
                            cost_suffix[0][other_c] = 1000000
                    
                    return cost_suffix
    
    # If we reach here, no valid cost_suffix was found
    raise ValueError("Invalid input")
