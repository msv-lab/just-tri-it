# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for each possible starting position of a subarray
    # cost[i] = minimum operations to make subarray starting at i have all equal elements
    cost = [0] * (n - x + 1)
    
    for i in range(n - x + 1):
        # To minimize operations, we should make all elements equal to the median
        subarray = nums[i:i + x]
        sorted_sub = sorted(subarray)
        
        # For odd length, median is middle element; for even, either middle works
        median = sorted_sub[x // 2]
        
        # Calculate total operations to make all elements equal to median
        total_ops = 0
        for num in subarray:
            total_ops += abs(num - median)
        
        cost[i] = total_ops
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # Use dynamic programming: dp[i][j] = min cost to select j subarrays from first i positions
    # But we need to ensure subarrays don't overlap
    
    # Since k is small (<=15), we can use DP with state (position, count)
    # But n can be up to 10^5, so we need an efficient approach
    
    # Alternative: use interval scheduling with DP
    # Let dp[i][j] = min cost using first i available starting positions to select j subarrays
    
    positions = list(range(n - x + 1))
    
    # We need to find k non-overlapping intervals [i, i+x-1] with minimum total cost
    # This is a classic interval scheduling problem
    
    # Since k is small, we can use DP where state is (last_end, count)
    # But that would be O(n^2 * k) which is too slow for n=10^5
    
    # Instead, we can use a greedy approach with priority queues or binary search
    # But the problem requires exact minimum operations
    
    # Let's implement a DP that considers the next available position after taking a subarray
    from functools import lru_cache
    
    @lru_cache(maxsize=None)
    def dfs(pos, remaining):
        if remaining == 0:
            return 0
        if pos >= len(positions):
            return float('inf')
        
        # Option 1: skip current position
        skip = dfs(pos + 1, remaining)
        
        # Option 2: take current subarray at positions[pos]
        current_start = positions[pos]
        next_pos = pos + 1
        # Find next position that doesn't overlap
        while next_pos < len(positions) and positions[next_pos] < current_start + x:
            next_pos += 1
        
        take = cost[current_start] + dfs(next_pos, remaining - 1)
        
        return min(skip, take)
    
    result = dfs(0, k)
    
    return result if result != float('inf') else 0
