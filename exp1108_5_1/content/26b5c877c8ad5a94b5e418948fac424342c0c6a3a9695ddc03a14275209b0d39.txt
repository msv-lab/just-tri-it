# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    if not cost_prefix:
        n = 1
    else:
        n = len(cost_prefix) + 1
    
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    
    if cost_prefix and any(len(row) != 3 for row in cost_prefix):
        raise ValueError("Invalid input")
    
    if cost_prefix and any(cost < 0 or cost > 10**5 for row in cost_prefix for cost in row):
        raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    if n == 2:
        results = []
        for c0 in range(3):
            for c1 in range(3):
                if c0 == c1:
                    continue
                total_cost = cost_prefix[0][c0] + cost_suffix_val[c1]
                if total_cost == minimum_beautiful_painting_cost:
                    results.append([[cost_suffix_val[c1]]])
        return results
    
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n)]
    
    for c0 in range(3):
        for c1 in range(3):
            if c0 == c1:
                continue
            dp[1][c0][c1] = cost_prefix[0][c0] + cost_prefix[1][c1]
    
    for i in range(2, n-1):
        for c_prev in range(3):
            for c_curr in range(3):
                if c_prev == c_curr:
                    continue
                for c_prev_prev in range(3):
                    if c_prev_prev == c_prev or (i >= n//2 and c_prev_prev == dp[i-1][c_prev_prev][c_prev]):
                        continue
                    if i < n//2:
                        dp[i][c_prev][c_curr] = min(dp[i][c_prev][c_curr], 
                                                   dp[i-1][c_prev_prev][c_prev] + cost_prefix[i][c_curr])
                    else:
                        sym_idx = n - 1 - i
                        if c_curr == dp[sym_idx][?][?]:
                            continue
                        dp[i][c_prev][c_curr] = min(dp[i][c_prev][c_curr],
                                                   dp[i-1][c_prev_prev][c_prev] + cost_prefix[i][c_curr])
    
    results = []
    for c_prev in range(3):
        for c_last in range(3):
            if c_prev == c_last:
                continue
            sym_idx = n - 1
            if c_last == dp[sym_idx][?][?]:
                continue
            
            min_cost = float('inf')
            for c_prev_prev in range(3):
                if c_prev_prev == c_prev:
                    continue
                if n-2 >= 0:
                    cost = dp[n-2][c_prev_prev][c_prev] + cost_suffix_val[c_last]
                    min_cost = min(min_cost, cost)
            
            if min_cost == minimum_beautiful_painting_cost:
                results.append([[cost_suffix_val[c_last]]])
    
    return results
