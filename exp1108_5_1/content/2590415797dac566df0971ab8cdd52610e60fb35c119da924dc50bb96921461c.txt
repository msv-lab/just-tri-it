# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    MOD = modulus
    N = num_vertices
    s = binary_string
    
    if N < 3:
        raise ValueError("Invalid input")
    
    if len(s) != N:
        raise ValueError("Invalid input")
    
    for char in s:
        if char not in '01':
            raise ValueError("Invalid input")
    
    # Count number of '1's in the string
    k = s.count('1')
    
    # Precompute factorials and inverse factorials
    fact = [1] * (N + 5)
    inv_fact = [1] * (N + 5)
    
    for i in range(1, len(fact)):
        fact[i] = fact[i-1] * i % MOD
    
    def mod_pow(a, b):
        res = 1
        while b:
            if b & 1:
                res = res * a % MOD
            a = a * a % MOD
            b >>= 1
        return res
    
    inv_fact[-1] = mod_pow(fact[-1], MOD-2)
    for i in range(len(fact)-2, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def comb(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # The key insight: 
    # For the cycle, the in-degrees d_0,...,d_{N-1} from cycle edges satisfy:
    # d_i = a_i + b_i where a_i is from edge (i-1,i) and b_i is from edge (i,i+1)
    # with a_i, b_i ∈ {0,1} and a_i + b_i ∈ {0,1,2}
    # Also, sum(d_i) = N
    
    # For vertex N, its in-degree is k - sum(y_i) where y_i indicates edge i->N
    
    # After derivation, the answer is:
    # sum_{t=0}^{k} [C(k, t) * (sum_{j=0}^{N} C(N, j) * C(j, t) * C(N-j, k-t)) ]
    # But this can be simplified using combinatorial identities
    
    # More efficient approach:
    # The answer is: sum_{i=0}^{min(k, N)} [C(N, i) * 2^i * sum_{j=0}^{k} C(k, j) * C(N-i, j) ]
    
    # Let's use Vandermonde's identity: sum_{j} C(k, j) * C(N-i, j) = C(N-i+k, k)
    
    result = 0
    for i in range(min(k, N) + 1):
        term = comb(N, i) * mod_pow(2, i) % MOD
        term = term * comb(N - i + k, k) % MOD
        result = (result + term) % MOD
    
    return result
