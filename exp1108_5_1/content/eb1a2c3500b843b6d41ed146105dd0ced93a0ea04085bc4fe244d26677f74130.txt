# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n < 2:
        raise ValueError("Invalid input")
    if len(cost) != n or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    
    # Pair the houses that are equidistant from the ends
    pairs = []
    for i in range(n // 2):
        pairs.append((i, n - 1 - i))
    
    # For each pair, precompute the best two color choices to minimize cost
    pair_colors = []
    for a, b in pairs:
        # For each possible color combination (a_color, b_color) where a_color != b_color
        min_costs = []
        for a_color in range(3):
            for b_color in range(3):
                if a_color != b_color:
                    total = cost[a][a_color] + cost[b][b_color]
                    min_costs.append((total, a_color, b_color))
        # Sort by total cost to find the best options
        min_costs.sort()
        # Keep the top 2 options for each pair to ensure we can alternate colors between adjacent pairs
        top_options = min_costs[:2]
        # Also consider swapping a and b colors for the same pair to get more options
        # So we need to cover all possible top 2 color combinations for both (a, b) and (b, a)
        # Alternatively, just keep the top 2 options where a_color and b_color are distinct
        # For now, just keep the top 2 options
        pair_colors.append(top_options)
    
    # Now, we need to select one option from each pair such that adjacent pairs have no color conflicts
    # Adjacent pairs are pairs that are next to each other in the original house sequence
    # For example, for pairs (0,5), (1,4), (2,3), the adjacent pairs are (0,5) and (1,4), then (1,4) and (2,3)
    # So the colors of house 1 (from pair (1,4)) must not conflict with house 0 (from pair (0,5)) and house 2 (from pair (2,3))
    # Similarly, house 4's color must not conflict with house 5 and house 3
    
    # Initialize DP: for each pair, track the best cost up to that pair for each possible color choice of the current pair's left and right houses
    # Since each pair has two options, we can track the minimal cost for each of the two options
    
    if not pair_colors:
        return 0
    
    # The first pair has no previous constraints, so just pick the minimal cost
    # We need to track the colors of the left and right houses in the pair
    # For the first pair (0, n-1), the left house is 0, right is n-1
    # For the next pair (1, n-2), the left house is 1, right is n-2, and it must not conflict with house 0 and house n-1
    
    # Initialize DP for the first pair
    dp = []
    for option in pair_colors[0]:
        total, a_color, b_color = option
        dp.append((total, a_color, b_color))
    
    for i in range(1, len(pair_colors)):
        current_options = pair_colors[i]
        new_dp = []
        # For each previous best option in dp, check compatibility with current options
        for prev_total, prev_a_color, prev_b_color in dp:
            for curr_total, curr_a_color, curr_b_color in current_options:
                # The current left house (i) must not have the same color as the previous left house (i-1)
                if curr_a_color == prev_a_color:
                    continue
                # The current right house (n-1-i) must not have the same color as the previous right house (n-1-(i-1)) = n-i
                if curr_b_color == prev_b_color:
                    continue
                new_total = prev_total + curr_total
                new_dp.append((new_total, curr_a_color, curr_b_color))
        if not new_dp:
            raise ValueError("No valid coloring possible")
        # Keep only the top 2 options to prevent exponential growth
        new_dp.sort()
        dp = new_dp[:2]
    
    if not dp:
        raise ValueError("No valid coloring possible")
    min_total = min(dp, key=lambda x: x[0])[0]
    return min_total
