# signature: def longestSpecialPath_sinv_nums(longest_special_path_info: List[int], edges: List[List[int]]) -> tuple[bool,list[List[int]]]
from typing import List, Tuple
from collections import defaultdict, deque

def longestSpecialPath_sinv_nums(longest_special_path_info: List[int], edges: List[List[int]]) -> Tuple[bool, List[List[int]]]:
    # Validate inputs
    if not longest_special_path_info or len(longest_special_path_info) != 2:
        raise ValueError("Invalid input")
    
    if not edges:
        raise ValueError("Invalid input")
    
    target_length, target_min_nodes = longest_special_path_info
    
    # Build the tree
    n = len(edges) + 1
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length < 1:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Check if tree is connected
    visited = [False] * n
    queue = deque([0])
    visited[0] = True
    count = 1
    
    while queue:
        node = queue.popleft()
        for neighbor, _ in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                count += 1
                queue.append(neighbor)
    
    if count != n:
        raise ValueError("Invalid input")
    
    # For large n, complete enumeration is impossible
    if n > 20:  # Arbitrary threshold for feasibility
        # Return representative examples
        representative_nums = []
        
        # Case 1: All distinct values (maximizes special path length)
        if target_length >= 0 and target_min_nodes >= 1:
            nums1 = list(range(n))
            representative_nums.append(nums1)
        
        # Case 2: All same values (minimizes special path length)
        if target_length == 0 and target_min_nodes == 1:
            nums2 = [0] * n
            representative_nums.append(nums2)
        
        # Case 3: Mixed values
        if target_length > 0 and target_min_nodes > 1:
            nums3 = [0] * n
            # Create a pattern that might produce the target
            for i in range(min(target_min_nodes, n)):
                nums3[i] = i
            representative_nums.append(nums3)
        
        return False, representative_nums
    
    else:
        # For small n, try to find all valid assignments
        valid_nums = []
        
        # Generate all possible assignments (brute force for small n)
        # This is exponential, so only feasible for very small n
        from itertools import product
        
        # Limit the value range for small n to make it feasible
        max_val = min(5, n)  # Very limited range for brute force
        
        for assignment in product(range(max_val + 1), repeat=n):
            nums = list(assignment)
            
            # Check if this assignment produces the target characteristics
            # For now, use a simplified check
            max_path_length = 0
            min_nodes_in_max_path = float('inf')
            
            # Simple DFS to find special paths
            def dfs(node, parent, path_values, current_length):
                nonlocal max_path_length, min_nodes_in_max_path
                
                # Current path ends here
                if len(path_values) > 0:
                    path_len = current_length
                    if path_len > max_path_length:
                        max_path_length = path_len
                        min_nodes_in_max_path = len(path_values)
                    elif path_len == max_path_length:
                        min_nodes_in_max_path = min(min_nodes_in_max_path, len(path_values))
                
                # Try to extend the path
                for neighbor, edge_length in graph[node]:
                    if neighbor == parent:
                        continue
                    
                    if nums[neighbor] not in path_values:
                        new_path_values = path_values | {nums[neighbor]}
                        dfs(neighbor, node, new_path_values, current_length + edge_length)
            
            # Start DFS from each node
            for start_node in range(n):
                dfs(start_node, -1, {nums[start_node]}, 0)
            
            # Check if matches target
            if max_path_length == target_length and min_nodes_in_max_path == target_min_nodes:
                valid_nums.append(nums)
        
        return True, valid_nums
