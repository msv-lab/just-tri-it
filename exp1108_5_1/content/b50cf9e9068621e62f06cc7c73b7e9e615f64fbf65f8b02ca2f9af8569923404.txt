# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    if modulus != 998244353:
        raise ValueError("Invalid input")
    
    N = num_vertices
    s = binary_string
    
    if N < 3:
        raise ValueError("Invalid input")
    
    if len(s) != N:
        raise ValueError("Invalid input")
    
    if not all(c in '01' for c in s):
        raise ValueError("Invalid input")
    
    # Count number of '1's in the string
    k = s.count('1')
    
    # For the cycle part: we have N edges forming a cycle
    # The in-degree sequence for the cycle vertices must satisfy:
    # sum_{i=0}^{N-1} d_i ≡ N (mod 2) and 0 <= d_i <= 2 for each i
    
    # For the star edges: we have k edges from cycle vertices to vertex N
    # These contribute independently to in-degrees
    
    # The total number of ways is the product of:
    # 1. Number of valid in-degree sequences for the cycle
    # 2. Ways to assign directions to star edges (2^k)
    
    # For the cycle: we need to count sequences (d_0, d_1, ..., d_{N-1}) where:
    # - Each d_i is 0, 1, or 2
    # - sum d_i ≡ N (mod 2)
    # - The sequence represents valid in-degrees for a directed cycle
    
    # In a directed cycle, the valid sequences are those where:
    # The number of vertices with in-degree 2 equals the number with in-degree 0
    # Let x = number of vertices with in-degree 2 = number with in-degree 0
    # Then N - 2x = number of vertices with in-degree 1
    
    # Also, sum d_i = 0*x + 1*(N-2x) + 2*x = N
    # And parity: sum d_i ≡ N ≡ N (mod 2) always holds
    
    # So we need to count the number of sequences with exactly x vertices having in-degree 0,
    # x vertices having in-degree 2, and N-2x vertices having in-degree 1
    
    # Number of such sequences = C(N, x) * C(N-x, x) for x from 0 to floor(N/2)
    
    # Precompute factorials and inverse factorials
    fact = [1] * (N + 1)
    inv_fact = [1] * (N + 1)
    
    for i in range(1, N + 1):
        fact[i] = fact[i-1] * i % MOD
    
    inv_fact[N] = pow(fact[N], MOD-2, MOD)
    for i in range(N-1, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def nCr(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # Count valid cycle sequences
    cycle_ways = 0
    for x in range(0, N // 2 + 1):
        # x vertices with in-degree 0, x with in-degree 2, N-2x with in-degree 1
        # Choose positions for in-degree 0 vertices: C(N, x)
        # Choose positions for in-degree 2 vertices from remaining: C(N-x, x)
        cycle_ways = (cycle_ways + nCr(N, x) * nCr(N - x, x)) % MOD
    
    # For star edges: each can be directed in 2 ways
    star_ways = pow(2, k, MOD)
    
    return cycle_ways * star_ways % MOD
