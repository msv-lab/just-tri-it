# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Validate inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    if any(not (-10**6 <= num <= 10**6) for num in nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # Collect all possible subarrays of size x
    subarrays = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        subarrays.append((i, i+x-1, subarray))
    
    # For each subarray, compute the minimal operations to make all elements equal to the median
    # and store the (operations, start, end)
    sub_info = []
    for start, end, sub in subarrays:
        # To minimize operations, we should make all elements equal to the median
        sorted_sub = sorted(sub)
        median = sorted_sub[x // 2]
        operations = sum(abs(num - median) for num in sub)
        sub_info.append((operations, start, end, median))
    
    # We need to select k non-overlapping subarrays with minimal total operations
    # This is a classic interval scheduling problem with the goal of minimal total operations
    # We can use a greedy approach with a priority queue to select the best candidates
    
    # Sort the sub_info by end index to facilitate non-overlapping selection
    sub_info.sort(key=lambda info: info[2])  # sort by end index
    
    # We'll use dynamic programming with a priority queue to find the best k non-overlapping intervals
    # dp[i][j] represents the minimal operations to select j non-overlapping intervals up to the i-th interval
    # However, with k up to 15 and n up to 1e5, we need an efficient way
    
    # Initialize a list to keep track of the best operations for up to k intervals
    # Using a priority queue approach inspired by the "maximum number of non-overlapping intervals" problem
    
    # We'll use a min-heap to keep track of the best solutions for each count of intervals
    # The heap will store tuples of (total_operations, end_index, count)
    heap = []
    heapq.heappush(heap, (0, -1, 0))  # (total_ops, last_end, count)
    
    min_ops = float('inf')
    
    for ops, start, end, _ in sub_info:
        # We process each interval and see if we can add it to existing counts in the heap
        new_heap = []
        found = False
        while heap:
            total_ops, last_end, count = heapq.heappop(heap)
            if start > last_end:
                new_count = count + 1
                new_total_ops = total_ops + ops
                if new_count == k:
                    if new_total_ops < min_ops:
                        min_ops = new_total_ops
                else:
                    heapq.heappush(new_heap, (new_total_ops, end, new_count))
                # Also keep the previous state to consider not taking this interval
                heapq.heappush(new_heap, (total_ops, last_end, count))
                found = True
                break
            else:
                heapq.heappush(new_heap, (total_ops, last_end, count))
        
        # Push back any remaining elements
        while heap:
            heapq.heappush(new_heap, heapq.heappop(heap))
        
        if not found:
            new_heap = heap.copy()
        
        heap = new_heap
    
    if min_ops == float('inf'):
        raise ValueError("No solution found")
    
    return min_ops
