# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric constraint: houses at distance i from start and distance i from end
    # cannot have the same color. Since n is even, we have n/2 pairs.
    # We need to assign colors to all houses such that:
    # 1. Adjacent houses have different colors
    # 2. For each i in [0, n/2-1], house i and house n-1-i have different colors
    
    # This creates a graph coloring problem with constraints that can be represented as:
    # - Each house has 3 color choices
    # - Constraints: house i != house i+1, and house i != house n-1-i
    
    # However, note that the constraints form a specific pattern:
    # The houses form a chain with additional constraints between symmetric positions.
    # We can think of it as coloring a path with extra edges between symmetric nodes.
    
    # Let's analyze the constraint graph:
    # For n=4: constraints are: 0-1, 1-2, 2-3, and 0-3, 1-2
    # For n=6: constraints are: 0-1, 1-2, 2-3, 3-4, 4-5, and 0-5, 1-4, 2-3
    
    # Notice that the symmetric constraints create cycles of length 3 or 4.
    # Actually, for even n, the constraints form a bipartite graph between two sets:
    # Set A: positions 0, 1, ..., n/2-1
    # Set B: positions n/2, n/2+1, ..., n-1
    # But with the twist that adjacent houses (consecutive positions) must have different colors.
    
    # Wait, let me reconsider: The problem states:
    # 1. Adjacent houses cannot have same color (creates a path graph)
    # 2. Houses at equal distance from ends cannot have same color
    
    # For n=4: positions (0,3) and (1,2) are symmetric pairs
    # So constraints: 0≠1, 1≠2, 2≠3, 0≠3, 1≠2
    
    # This means we have a cycle: 0-1-2-3-0 (a cycle of length 4)
    
    # For n=6: positions (0,5), (1,4), (2,3) are symmetric pairs
    # Constraints: 0≠1, 1≠2, 2≠3, 3≠4, 4≠5, and 0≠5, 1≠4, 2≠3
    # This forms a graph that is actually two cycles of length 3: (0,1,5) and (2,3,4)
    
    # Actually, let's trace the constraints more carefully for n=6:
    # From adjacency: 0-1, 1-2, 2-3, 3-4, 4-5
    # From symmetry: 0-5, 1-4, 2-3
    # Combining: 
    # - 0 is connected to 1 and 5
    # - 1 is connected to 0, 2, 4
    # - 2 is connected to 1, 3
    # - 3 is connected to 2, 4 (from symmetry 2-3 means 3 is connected to 2)
    # - 4 is connected to 3, 5, 1
    # - 5 is connected to 4, 0
    
    # This forms a complete graph? No, let's check components:
    # Actually it forms two triangles: (0,1,5) and (2,3,4)
    
    # So the pattern is: for even n, the constraint graph consists of n/2 triangles
    # Wait, let me verify for n=4:
    # Constraints: 0-1, 1-2, 2-3, 0-3
    # This forms a cycle of length 4, not triangles.
    
    # Actually, I see the pattern now:
    # For even n, the constraint graph is bipartite between odd and even indices?
    # Let me check n=4:
    # Positions: 0(even), 1(odd), 2(even), 3(odd)
    # Adjacency: even-odd, even-odd, even-odd
    # Symmetry: 0(even)-3(odd), 1(odd)-2(even)
    # So all constraints are between even and odd positions.
    
    # This means we can color all even positions with one set of colors and all odd positions with another.
    # But we need to minimize cost.
    
    # Actually, the key insight is that the constraint graph is bipartite:
    # Partition 1: even indices (0, 2, 4, ...)
    # Partition 2: odd indices (1, 3, 5, ...)
    
    # All constraints are between these two partitions:
    # - Adjacency: even-odd or odd-even
    # - Symmetry: if i is even, n-1-i is odd (since n is even)
    
    # So we need to:
    # 1. Color all even-indexed houses (no constraints between them)
    # 2. Color all odd-indexed houses (no constraints between them)
    # 3. Ensure different colors for adjacent even-odd pairs
    
    # But wait, are there really no constraints within each partition?
    # Let's check: For even indices, can two even indices have same color?
    # - They are not adjacent (adjacent means even-odd)
    # - They are not symmetric (symmetric pairs are even-odd)
    # So yes, no constraints within each partition!
    
    # Therefore, we can independently choose the best color for each even-indexed house
    # and the best color for each odd-indexed house, as long as adjacent even-odd pairs
    # have different colors.
    
    # But adjacent even-odd pairs share constraints: house i (even) and house i+1 (odd) must differ
    # Also, symmetric pairs: house i (even) and house n-1-i (odd) must differ
    
    # Actually, let me formalize:
    # Let E be the set of even indices: 0, 2, 4, ..., n-2
    # Let O be the set of odd indices: 1, 3, 5, ..., n-1
    
    # Constraints:
    # For each i in E: 
    #   - house i and house i+1 (in O) must have different colors
    #   - house i and house n-1-i (in O) must have different colors
    
    # This means each even-indexed house has exactly 2 constraints with odd-indexed houses.
    # Similarly, each odd-indexed house has exactly 2 constraints with even-indexed houses.
    
    # The problem reduces to: we have two independent sets (E and O) where each node in E
    # is connected to exactly 2 nodes in O, and vice versa.
    
    # Actually, let's check the degree:
    # For house 0 (even): connected to house 1 (adjacent) and house n-1 (symmetric)
    # For house 1 (odd): connected to house 0 (adjacent) and house n-2 (symmetric)
    
    # So we have a bipartite graph where each node has degree 2.
    # This means the graph is a disjoint union of cycles of even length.
    
    # For minimization, we can use dynamic programming on each cycle.
    # But since all cycles are of even length and we have only 3 colors,
    # we can find the optimal coloring efficiently.
    
    # However, there's a simpler observation: 
    # Since each even-indexed house has exactly 2 constraints with odd houses,
    # and we have 3 colors available, each even house has at least 1 color available
    # after considering its constraints.
    
    # Actually, the simplest approach is to realize that we can color the even and odd
    # houses independently as long as we respect the constraints between them.
    # Since there are only 2 constraints per house and 3 colors, we can always find a valid coloring.
    
    # For minimization, we can use this approach:
    # 1. For each even-indexed house, find the minimum cost color that is different from
    #    the colors chosen for its two constrained odd houses.
    # 2. Similarly for odd houses.
    
    # But this is circular: the color of an even house affects its constrained odd houses,
    # which in turn affect other even houses.
    
    # Actually, let me think about the graph structure again.
    # For even n, the constraint graph consists of cycles of length n/2.
    # Let me verify for n=4:
    # Constraints: 0-1, 1-2, 2-3, 0-3
    # This forms a single cycle: 0-1-2-3-0 (length 4)
    
    # For n=6:
    # Constraints: 0-1, 1-2, 2-3, 3-4, 4-5, 0-5, 1-4, 2-3
    # This forms: cycle1: 0-1-4-3-2-1? Wait, that's not right.
    # Let me list edges: (0,1), (1,2), (2,3), (3,4), (4,5), (0,5), (1,4), (2,3)
    # This gives us: 
    # - Triangle: 0,1,5 (edges: 0-1, 1-5? Wait no, 1-5 is not direct, but 1-4-5)
    # Actually, it forms two cycles: (0,1,4,5) and (2,3)
    
    # I see the pattern now: the constraint graph decomposes into n/2 cycles of length 2?
    # Let me check more carefully.
    
    # Actually, I found the key insight in the problem analysis:
    # The constraints mean that for each pair of symmetric houses (i, n-1-i), 
    # they must have different colors, and each is also constrained by its adjacent houses.
    
    # This creates a situation where we have independent pairs of houses that form "columns".
    # Specifically, for each i from 0 to n/2-1, we have a column containing houses i and n-1-i.
    # Adjacent columns (i and i+1) have constraints between:
    # - house i and house i+1
    # - house n-1-i and house n-1-(i+1) = house n-2-i
    
    # So we can use dynamic programming on these columns.
    # Each column has 2 houses, and each house has 3 color choices.
    # We need to ensure:
    # 1. The two houses in the same column have different colors (from symmetry constraint)
    # 2. Between adjacent columns, the right house of left column and left house of right column
    #    have different colors, and similarly for the other pair.
    
    # Let's define DP[i][c1][c2] = minimum cost to color first i columns where the first house
    # in column i has color c1 and the second house has color c2.
    
    # But n can be up to 10^5, and 3*3=9 states per column, so 9 * 10^5 = 900,000 operations,
    # which is acceptable.
    
    # Implementation:
    # Let k = n // 2 (number of columns)
    # Each column i has houses at positions i and n-1-i
    
    # For column i, the cost if we choose color a for house i and color b for house n-1-i is:
    # cost[i][a] + cost[n-1-i][b], with constraint a != b (same column constraint)
    
    # Between column i and i+1, we have constraints:
    # - house i (color a) and house i+1 (color c) must be different
    # - house n-1-i (color b) and house n-2-i (color d) must be different
    
    # Note: house n-2-i is the same as house n-1-(i+1), which is the second house in column i+1
    
    # So the recurrence:
    # DP[i+1][c][d] = min over all valid a,b for column i of {
    #   DP[i][a][b] + cost[i+1][c] + cost[n-1-(i+1)][d]
    # }
    # with constraints:
    # - a != b (within column i)
    # - a != c (between column i and i+1, first houses)
    # - b != d (between column i and i+1, second houses)
    
    # Base case: for i=0, DP[0][a][b] = cost[0][a] + cost[n-1][b] for all a != b
    
    # Final answer: min over all a,b of DP[k-1][a][b]
    
    k = n // 2
    
    # Initialize DP for first column
    dp = {}
    for a in range(3):
        for b in range(3):
            if a != b:
                dp[(a, b)] = cost[0][a] + cost[n-1][b]
    
    # Process remaining columns
    for i in range(1, k):
        new_dp = {}
        for c in range(3):  # color for house i (first house in column i)
            for d in range(3):  # color for house n-1-i (second house in column i)
                if c == d:  # same column constraint
                    continue
                
                min_prev = float('inf')
                for (a, b), total_cost in dp.items():
                    # Check constraints between columns
                    if a != c and b != d:
                        min_prev = min(min_prev, total_cost)
                
                if min_prev != float('inf'):
                    new_dp[(c, d)] = min_prev + cost[i][c] + cost[n-1-i][d]
        
        dp = new_dp
    
    return min(dp.values()) if dp else 0
