# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    if not cost:
        raise ValueError("Invalid input")
    
    n = len(cost)
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0:
                raise ValueError("Invalid input")
    
    if n == 2:
        min_cost = float('inf')
        for i in range(3):
            for j in range(3):
                if i != j:
                    min_cost = min(min_cost, cost[0][i] + cost[1][j])
        return min_cost
    
    # For symmetric constraint: houses at distance i and n-1-i must have different colors
    # We need to find the minimum cost while satisfying:
    # 1. Adjacent houses have different colors
    # 2. Symmetric houses (i and n-1-i) have different colors
    
    # Since n is even, we can split into pairs: (0, n-1), (1, n-2), ..., (n/2-1, n/2)
    # Each pair must have different colors, and adjacent pairs must have different colors
    
    # Dynamic programming approach for the chain of n/2 pairs
    m = n // 2
    
    # dp[i][c1][c2] = min cost for first i pairs where pair i has colors (c1, c2)
    # But this would be O(m * 3^4) which is too slow for n up to 10^5
    
    # Alternative: for each pair (i, n-1-i), we need to choose colors (a, b) with a != b
    # And for consecutive pairs, the second color of previous pair != first color of current pair
    
    # Let's precompute for each pair the 6 possible color combinations and their costs
    pair_costs = []
    for i in range(m):
        current_costs = []
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:  # Symmetric constraint
                    current_costs.append((c1, c2, cost[i][c1] + cost[n-1-i][c2]))
        pair_costs.append(current_costs)
    
    # Now we need to find a sequence of pairs where for consecutive pairs:
    # pair[i].c2 != pair[i+1].c1
    
    # DP: dp[i][last_c2] = min cost up to pair i ending with color last_c2 for the second house
    dp_prev = {c2: cost_val for _, c2, cost_val in pair_costs[0]}
    
    for i in range(1, m):
        dp_curr = {}
        for c1, c2, cost_val in pair_costs[i]:
            # Find the minimum from previous state where last_c2 != current c1
            min_prev = float('inf')
            for prev_c2, prev_cost in dp_prev.items():
                if prev_c2 != c1:
                    min_prev = min(min_prev, prev_cost)
            
            if min_prev != float('inf'):
                total_cost = min_prev + cost_val
                if c2 not in dp_curr or total_cost < dp_curr[c2]:
                    dp_curr[c2] = total_cost
        
        dp_prev = dp_curr
    
    return min(dp_prev.values()) if dp_prev else 0
