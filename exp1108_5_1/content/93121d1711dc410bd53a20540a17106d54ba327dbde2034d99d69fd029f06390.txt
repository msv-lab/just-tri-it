# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not nums or x <= 0 or k <= 0 or k * x > len(nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute the cost for making each possible subarray of length x have all elements equal
    # For a subarray starting at index i, the optimal target value is the median of nums[i:i+x]
    # This minimizes the sum of absolute deviations
    
    # We'll use sliding window to compute median and cost efficiently
    # Since k is small (<=15), we can use dynamic programming
    
    # Precompute cost for each possible subarray
    subarray_costs = []
    
    # Helper function to compute cost for making a window have all elements equal to target
    def compute_cost(window, target):
        return sum(abs(num - target) for num in window)
    
    # For each possible starting position of subarray
    for i in range(n - x + 1):
        window = nums[i:i+x]
        # Sort to find median
        sorted_window = sorted(window)
        # Median minimizes sum of absolute deviations
        median = sorted_window[x // 2]
        cost = compute_cost(window, median)
        subarray_costs.append((i, cost))
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # Subarrays are non-overlapping if the starting indices satisfy: i_j + x <= i_{j+1}
    
    # DP approach: dp[i][j] = min cost to select j subarrays from first i possible subarrays
    m = len(subarray_costs)  # number of possible subarrays
    
    # Initialize DP table with infinity
    dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        start_i, cost_i = subarray_costs[i-1]
        # For selecting 0 subarrays, cost is always 0
        dp[i][0] = 0
        
        for j in range(1, k + 1):
            # Option 1: Don't take current subarray
            dp[i][j] = min(dp[i][j], dp[i-1][j])
            
            # Option 2: Take current subarray
            # Find the last subarray we can take before current one
            # We need to find the largest index p where subarray_costs[p][0] + x <= start_i
            # We can binary search for this, but for simplicity, we'll iterate
            best_prev = float('inf')
            for p in range(i):
                if p == 0:
                    # No previous subarray
                    if j == 1:
                        best_prev = min(best_prev, cost_i)
                else:
                    prev_start, _ = subarray_costs[p-1]
                    if prev_start + x <= start_i:
                        best_prev = min(best_prev, dp[p][j-1] + cost_i)
            
            dp[i][j] = min(dp[i][j], best_prev)
    
    # Find the minimum cost for exactly k subarrays
    result = min(dp[i][k] for i in range(m + 1))
    
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    return result
