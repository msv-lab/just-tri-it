# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate constraints
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if k < 1 or k > 15:
        raise ValueError("Invalid input")
    if k * x > n:
        raise ValueError("Invalid input")
    
    # Precompute prefix sums for efficient range sum queries
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Precompute sum of squares for variance calculation
    prefix_sq = [0] * (n + 1)
    for i in range(n):
        prefix_sq[i + 1] = prefix_sq[i] + nums[i] * nums[i]
    
    # Memoization dictionary for DP
    memo = {}
    
    def dp(start_idx, remaining_k):
        if remaining_k == 0:
            return 0
        if start_idx + x * remaining_k > n:
            return float('inf')
        
        if (start_idx, remaining_k) in memo:
            return memo[(start_idx, remaining_k)]
        
        min_ops = float('inf')
        
        # Try all possible starting positions for the next subarray
        for next_start in range(start_idx, n - x * remaining_k + 1):
            end = next_start + x - 1
            
            # Calculate the optimal target value for this subarray
            # The optimal target is the median (for odd x) or average of two medians (for even x)
            # but for simplicity and efficiency, we'll use the mean rounded to nearest integer
            subarray = nums[next_start:end + 1]
            sorted_sub = sorted(subarray)
            
            # For odd x, median is at position x//2
            # For even x, we can try both medians
            if x % 2 == 1:
                median_candidates = [sorted_sub[x // 2]]
            else:
                median_candidates = [sorted_sub[x // 2 - 1], sorted_sub[x // 2]]
            
            # Also consider the mean as a candidate
            mean_val = round(sum(subarray) / x)
            median_candidates.append(mean_val)
            
            # Remove duplicates and ensure we're within reasonable bounds
            candidates = set(median_candidates)
            
            for target in candidates:
                # Calculate operations needed to make all elements equal to target
                operations = 0
                for num in subarray:
                    operations += abs(num - target)
                
                # Recursively find the minimum operations for remaining subarrays
                total_ops = operations + dp(end + 1, remaining_k - 1)
                min_ops = min(min_ops, total_ops)
        
        memo[(start_idx, remaining_k)] = min_ops
        return min_ops
    
    result = dp(0, k)
    
    # Add 1 to the final answer as specified
    return result + 1
