# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n <= 0 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    if len(cost) != n or any(len(row) != 3 for row in cost):
        raise ValueError("Invalid input")
    
    if any(any(c < 0 for c in row) for row in cost):
        raise ValueError("Invalid input")
    
    # For each pair of symmetric positions (i, n-1-i), we need to choose different colors
    # Also adjacent houses cannot have same color
    
    # dp[i][c1][c2] = min cost for pair i where first house has color c1 and second has color c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # We can optimize by processing pairs independently and combining results
    # For each symmetric pair (i, n-1-i), we need to choose colors (a, b) such that:
    # 1. a != b (for the symmetric constraint)
    # 2. For adjacent pairs: the color at position i+1 cannot equal b, and color at position i cannot equal the color at position i-1
    
    # Let's use dynamic programming where we track the minimum cost for the first k pairs
    # and the colors chosen for the last house of the k-th pair
    
    # For the first pair (positions 0 and n-1), we can choose any (a, b) where a != b
    # For subsequent pairs, we need to ensure that the color at position i (first of current pair)
    # is different from the color at position i-1 (second of previous pair)
    
    # Let dp[k][c] = min cost for first k pairs where the second house of k-th pair has color c
    # and we also track the color of the first house of k-th pair
    
    # Actually, we need both colors for constraints, so let's use:
    # dp[k][a][b] = min cost for first k pairs where k-th pair has colors (a, b)
    
    # But this is O(n * 9) which is 900,000 operations - acceptable
    
    k = n // 2  # number of symmetric pairs
    
    # Initialize DP table
    INF = float('inf')
    dp = [[[INF for _ in range(3)] for _ in range(3)] for _ in range(k)]
    
    # Base case: first pair (positions 0 and n-1)
    for a in range(3):
        for b in range(3):
            if a != b:  # symmetric constraint
                dp[0][a][b] = cost[0][a] + cost[n-1][b]
    
    # Fill DP table for remaining pairs
    for i in range(1, k):
        for a in range(3):  # color for position i
            for b in range(3):  # color for position n-1-i
                if a != b:  # symmetric constraint
                    # Try all possible colors for previous pair
                    for prev_a in range(3):  # color for position i-1
                        for prev_b in range(3):  # color for position n-i
                            if prev_a != prev_b:  # symmetric constraint for previous pair
                                # Adjacent constraint: position i-1 and i must have different colors
                                # Since position i-1 has color prev_b (second of previous pair)
                                # and position i has color a (first of current pair)
                                if prev_b != a:
                                    current_cost = cost[i][a] + cost[n-1-i][b]
                                    dp[i][a][b] = min(dp[i][a][b], dp[i-1][prev_a][prev_b] + current_cost)
    
    # Find minimum cost for all pairs
    min_total = INF
    for a in range(3):
        for b in range(3):
            if a != b:
                min_total = min(min_total, dp[k-1][a][b])
    
    return int(min_total)
