# signature: def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]
from typing import List
from collections import defaultdict, deque

def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]:
    n = len(nums)
    if n < 2 or len(edges) != n - 1:
        raise ValueError("Invalid input")
    
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length <= 0:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Build tree structure with parent-child relationships (root at 0)
    parent = [-1] * n
    children = defaultdict(list)
    edge_lengths = {}  # Store edge lengths from parent to child
    
    # BFS to establish parent-child relationships
    visited = [False] * n
    queue = deque([0])
    visited[0] = True
    
    while queue:
        node = queue.popleft()
        for neighbor, length in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                children[node].append(neighbor)
                edge_lengths[(node, neighbor)] = length
                queue.append(neighbor)
    
    # DFS to compute the longest special path and minimum node count
    # We'll use a dictionary to track the best paths ending at each node
    # Each entry: (max_length, min_nodes)
    dp = [None] * n
    
    def dfs(node):
        if dp[node] is not None:
            return dp[node]
        
        # Base case: path starting and ending at this node
        best_length = 0
        best_nodes = 1
        
        # Try to extend paths from children
        for child in children[node]:
            child_length, child_nodes = dfs(child)
            
            # Check if we can extend the path (unique values)
            if nums[node] != nums[child]:
                edge_len = edge_lengths[(node, child)]
                total_length = child_length + edge_len
                total_nodes = child_nodes + 1
                
                if total_length > best_length:
                    best_length = total_length
                    best_nodes = total_nodes
                elif total_length == best_length and total_nodes < best_nodes:
                    best_nodes = total_nodes
        
        dp[node] = (best_length, best_nodes)
        return dp[node]
    
    # Find the best path across all nodes
    max_length = 0
    min_nodes = float('inf')
    
    for node in range(n):
        length, nodes_count = dfs(node)
        if length > max_length:
            max_length = length
            min_nodes = nodes_count
        elif length == max_length and nodes_count < min_nodes:
            min_nodes = nodes_count
    
    # Also consider paths that don't start at root but might be better
    # We need to find the maximum path length across all possible paths
    
    # Use a different approach: for each node, find the longest path through it
    # where all values are unique
    
    # Reset dp for new approach
    dp = [None] * n
    
    def dfs2(node):
        if dp[node] is not None:
            return dp[node]
        
        # For each child, we'll get the best path ending at that child
        child_paths = []
        for child in children[node]:
            if nums[node] != nums[child]:
                child_length, child_nodes = dfs2(child)
                edge_len = edge_lengths[(node, child)]
                child_paths.append((child_length + edge_len, child_nodes + 1))
        
        # If no valid child paths, return path with just this node
        if not child_paths:
            return (0, 1)
        
        # Sort by length (descending) and then by node count (ascending)
        child_paths.sort(key=lambda x: (-x[0], x[1]))
        
        # Return the best path ending at this node
        return child_paths[0]
    
    # Find the best path that goes through each node
    global_max_length = 0
    global_min_nodes = float('inf')
    
    for node in range(n):
        # Get the best two paths from children (for combining through this node)
        child_paths = []
        for child in children[node]:
            if nums[node] != nums[child]:
                child_length, child_nodes = dfs2(child)
                edge_len = edge_lengths[(node, child)]
                child_paths.append((child_length + edge_len, child_nodes + 1))
        
        # Sort by length
        child_paths.sort(key=lambda x: -x[0])
        
        # Path through this node combining two child paths
        if len(child_paths) >= 2:
            total_length = child_paths[0][0] + child_paths[1][0]
            total_nodes = child_paths[0][1] + child_paths[1][1] - 1
            
            if total_length > global_max_length:
                global_max_length = total_length
                global_min_nodes = total_nodes
            elif total_length == global_max_length and total_nodes < global_min_nodes:
                global_min_nodes = total_nodes
        
        # Path ending at this node (single branch)
        if child_paths:
            length, nodes = child_paths[0]
            if length > global_max_length:
                global_max_length = length
                global_min_nodes = nodes
            elif length == global_max_length and nodes < global_min_nodes:
                global_min_nodes = nodes
        
        # Path with just this node
        if 0 > global_max_length:
            global_max_length = 0
            global_min_nodes = 1
        elif 0 == global_max_length and 1 < global_min_nodes:
            global_min_nodes = 1
    
    # According to the problem, append 1 to the final answer
    return [global_max_length + 1, global_min_nodes + 1]
