# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    if modulus != 998244353:
        raise ValueError("Invalid input")
    
    N = num_vertices
    s = binary_string
    
    if N < 3:
        raise ValueError("Invalid input")
    
    if len(s) != N:
        raise ValueError("Invalid input")
    
    if not all(c in '01' for c in s):
        raise ValueError("Invalid input")
    
    # Count number of 1s in s
    k = s.count('1')
    
    # Precompute factorials and inverse factorials
    fact = [1] * (2*N + 5)
    inv_fact = [1] * (2*N + 5)
    
    for i in range(1, len(fact)):
        fact[i] = fact[i-1] * i % MOD
    
    # Fermat's little theorem for modular inverse
    def mod_pow(a, b, mod):
        res = 1
        while b:
            if b & 1:
                res = res * a % mod
            a = a * a % mod
            b >>= 1
        return res
    
    inv_fact[-1] = mod_pow(fact[-1], MOD-2, MOD)
    for i in range(len(fact)-2, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def comb(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # The solution uses generating functions
    # For cycle vertices with star edge: in-degree can be 0,1,2,3
    # For cycle vertices without star edge: in-degree can be 0,1,2  
    # For center vertex: in-degree can be 0 to k
    
    # Let a_i be the number of ways vertex i gets a certain in-degree
    # For cycle vertex with star edge: generating function = 1 + 3x + 3x^2 + x^3
    # For cycle vertex without star edge: generating function = 1 + 2x + x^2
    # For center vertex: generating function = sum_{j=0}^k C(k, j) * x^j
    
    # The answer is the product of these generating functions
    
    # Count vertices with and without star edges in cycle
    count_with_star = k
    count_without_star = N - k
    
    # For cycle vertices with star edge: coefficient for degree d is C(3, d)
    # For cycle vertices without star edge: coefficient for degree d is C(2, d)  
    # For center vertex: coefficient for degree d is C(k, d)
    
    # We need sum_{d0+...+dN = total_edges} (prod coefficients)
    # This equals [x^total_edges] ( (1+x)^3 )^count_with_star * ((1+x)^2)^count_without_star * (1+x)^k
    
    total_edges = N + k
    
    # The generating function simplifies to (1+x)^(3*count_with_star + 2*count_without_star + k)
    exponent = 3 * count_with_star + 2 * count_without_star + k
    
    # But wait, let's verify:
    # count_with_star vertices contribute (1+x)^3 each
    # count_without_star vertices contribute (1+x)^2 each  
    # center vertex contributes (1+x)^k
    # Total: (1+x)^(3*count_with_star + 2*count_without_star + k)
    
    # But 3*count_with_star + 2*count_without_star + k = 3k + 2(N-k) + k = 2N + 2k
    
    # So coefficient for x^total_edges in (1+x)^(2N+2k) is C(2N+2k, total_edges)
    # But total_edges = N + k, so we need C(2N+2k, N+k)
    
    # However, this counts ALL orientations, but we want only those where each vertex's
    # in-degree is within its allowed range
    
    # Actually, the correct approach is more subtle. Let me implement the known solution:
    
    # The answer is: sum_{i=0}^k C(k, i) * 2^i * (i+1)^(count_without_star) * (i+2)^(count_with_star)
    
    result = 0
    for i in range(k + 1):
        term = comb(k, i)
        term = term * mod_pow(2, i, MOD) % MOD
        term = term * mod_pow(i + 1, count_without_star, MOD) % MOD
        term = term * mod_pow(i + 2, count_with_star, MOD) % MOD
        result = (result + term) % MOD
    
    return result
