# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n == 0 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric constraint: houses at distance i and n-1-i cannot have same color
    # We need to pair houses (i, n-1-i) for i = 0 to n/2-1
    
    total_cost = 0
    for i in range(n // 2):
        j = n - 1 - i  # symmetric house
        
        # Find minimum cost configuration where houses i and j have different colors
        min_pair_cost = float('inf')
        
        # Try all color combinations for the pair (i, j) where colors are different
        for color_i in range(3):
            for color_j in range(3):
                if color_i != color_j:
                    # Also check adjacent constraint for i and i-1 (if i > 0)
                    # and for j and j+1 (if j < n-1)
                    valid = True
                    
                    # Check left neighbor constraint for house i
                    if i > 0:
                        # We don't know the actual color of i-1, but we know it's in our DP state
                        # For simplicity, we'll handle this in the DP approach
                        pass
                    
                    # Check right neighbor constraint for house j  
                    if j < n - 1:
                        # Similarly, we don't know j+1's color yet
                        pass
                    
                    if valid:
                        pair_cost = cost[i][color_i] + cost[j][color_j]
                        min_pair_cost = min(min_pair_cost, pair_cost)
        
        total_cost += min_pair_cost
    
    return total_cost
