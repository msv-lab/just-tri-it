# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n < 2 or n != len(cost) or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    
    # Pair of houses that are equidistant from the ends
    pairs = [(i, n - 1 - i) for i in range(n // 2)]
    
    # Precompute the minimal costs for each pair considering constraints
    dp = []
    for a, b in pairs:
        if a == b:
            raise ValueError("Invalid input")  # Shouldn't happen since n is even
        # For each possible color combination of a and b (a != b)
        min_costs = []
        for color_a in range(3):
            for color_b in range(3):
                if color_a != color_b:
                    total_cost = cost[a][color_a] + cost[b][color_b]
                    min_costs.append((color_a, color_b, total_cost))
        # Keep the top 2 minimal costs for each color_a and color_b to allow transitions
        min_costs.sort(key=lambda x: x[2])
        # We need at least two options to ensure the adjacent pairs can have different colors
        top_options = min_costs[:2] if len(min_costs) >= 2 else min_costs
        dp.append(top_options)
    
    # Now, we need to ensure that adjacent pairs (i and i+1) have different colors
    # Initialize the DP for the first pair
    if not dp:
        raise ValueError("Invalid input")
    
    # The DP will track the minimal cost up to the current pair, considering the last color used
    # For the first pair, any of the top options is allowed
    prev_dp = []
    for option in dp[0]:
        color_a, color_b, total = option
        prev_dp.append((color_b, total))  # track the last color used (from the second house in the pair) and total cost
    
    for i in range(1, len(dp)):
        current_dp = []
        for option in dp[i]:
            current_color_a, current_color_b, current_cost = option
            min_prev_cost = float('inf')
            for prev_color, prev_total in prev_dp:
                if prev_color != current_color_a:
                    if prev_total + current_cost < min_prev_cost:
                        min_prev_cost = prev_total + current_cost
            if min_prev_cost != float('inf'):
                current_dp.append((current_color_b, min_prev_cost))
        if not current_dp:
            raise ValueError("No valid coloring possible")
        # Keep only the minimal options to prevent combinatorial explosion
        current_dp.sort(key=lambda x: x[1])
        prev_dp = current_dp[:2]  # Keep top 2 options
    
    if not prev_dp:
        raise ValueError("No valid coloring possible")
    return min(total for _, total in prev_dp)
