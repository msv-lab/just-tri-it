# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    k = len(cost[0]) if n > 0 else 0
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    if k != 3:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric constraints, we need to consider that:
    # 1. Adjacent houses can't have same color
    # 2. Symmetric houses (i and n-1-i) can't have same color
    
    # This is a complex constraint problem. We'll use dynamic programming
    # where dp[i][c1][c2] represents the min cost for first i+1 pairs
    # with colors c1 for position i and c2 for position n-1-i
    
    # Initialize DP table
    INF = float('inf')
    
    # For the first pair (0, n-1)
    dp = [[[INF] * 3 for _ in range(3)] for _ in range(n//2)]
    
    # Fill first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Fill remaining pairs
    for i in range(1, n//2):
        for c1 in range(3):  # Color for position i
            for c2 in range(3):  # Color for position n-1-i
                if c1 != c2:  # Symmetric constraint
                    min_prev = INF
                    for prev_c1 in range(3):  # Color for position i-1
                        for prev_c2 in range(3):  # Color for position n-i
                            if prev_c1 != c1 and prev_c2 != c2:  # Adjacent constraints
                                min_prev = min(min_prev, dp[i-1][prev_c1][prev_c2])
                    
                    if min_prev < INF:
                        dp[i][c1][c2] = min_prev + cost[i][c1] + cost[n-1-i][c2]
    
    # Find minimum in last pair
    result = INF
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                result = min(result, dp[n//2-1][c1][c2])
    
    return int(result) if result < INF else 0
