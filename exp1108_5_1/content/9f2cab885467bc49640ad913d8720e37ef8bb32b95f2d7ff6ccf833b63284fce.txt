# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric positions: i and n-1-i
    # We need to assign different colors to these symmetric pairs
    # and also ensure adjacent houses have different colors
    
    # Since there are only 3 colors, we can consider all valid color assignments
    # for a symmetric pair that satisfy:
    # 1. color[i] != color[i+1] for adjacent houses (except the middle pair when n is even)
    # 2. color[i] != color[n-1-i] for symmetric houses
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs (i from 0 to n/2-1) with colors c1 for position i and c2 for position n-1-i
    
    # But this would be O(n * 3^4) which is too slow for n up to 10^5
    
    # Alternative approach: Since constraints are symmetric and we have only 3 colors,
    # we can consider that for each symmetric pair (i, n-1-i), we need to assign
    # different colors to both houses in the pair, and also maintain consistency with neighbors
    
    # Actually, let's think about the constraints:
    # 1. Adjacent constraint: color[i] != color[i+1]
    # 2. Symmetric constraint: color[i] != color[n-1-i]
    
    # For even n, the graph is bipartite with additional constraints
    # We can model this as coloring two interleaved chains
    
    # Let's create two separate cost arrays for the two "chains":
    # Chain A: positions 0, 2, 4, ..., n-2
    # Chain B: positions 1, 3, 5, ..., n-1
    
    # But wait, the symmetric constraint couples positions i and n-1-i
    # For even n, position i and n-1-i have the same parity
    
    # Actually, let me reindex: positions 0 and n-1 are symmetric, 1 and n-2, etc.
    # So we have n/2 symmetric pairs: (0, n-1), (1, n-2), ..., (n/2-1, n/2)
    
    # For each symmetric pair, we need to assign two different colors
    # And we need to ensure adjacent pairs have compatible colors
    
    # Let's define dp[i][c1][c2] as min cost for first i+1 pairs where:
    # - the left house of pair i has color c1
    # - the right house of pair i has color c2
    
    # But we need to ensure that for adjacent pairs:
    # - the right house of pair i-1 has different color from left house of pair i
    # - the left house of pair i has different color from right house of pair i
    
    k = n // 2
    INF = float('inf')
    
    # Initialize DP table
    dp = [[[INF] * 3 for _ in range(3)] for _ in range(k)]
    
    # For the first pair (positions 0 and n-1)
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, k):
        for c1 in range(3):  # Color for position i (left side)
            for c2 in range(3):  # Color for position n-1-i (right side)
                if c1 == c2:  # Symmetric constraint
                    continue
                
                # Check all possible colors for previous pair
                for prev_c1 in range(3):  # Color for position i-1 (left side)
                    for prev_c2 in range(3):  # Color for position n-i (right side)
                        if prev_c1 == prev_c2:  # Symmetric constraint for previous
                            continue
                        
                        # Adjacent constraint: 
                        # - position i-1 (left) and position i (left) are adjacent
                        # - position n-i (right) and position n-1-i (right) are adjacent
                        if prev_c1 != c1 and prev_c2 != c2:
                            current_cost = cost[i][c1] + cost[n-1-i][c2]
                            dp[i][c1][c2] = min(dp[i][c1][c2], dp[i-1][prev_c1][prev_c2] + current_cost)
    
    # Find minimum cost for the last pair
    min_cost = INF
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                min_cost = min(min_cost, dp[k-1][c1][c2])
    
    return int(min_cost) if min_cost != INF else 0
