# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    n = len(cost_prefix) + 1
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    if not cost_prefix and n != 0:
        raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # If n=0 case (though n>=2 by constraints)
    if n == 0:
        if minimum_beautiful_painting_cost != 0:
            raise ValueError("Invalid input")
        return []
    
    # Dynamic programming approach to find the minimum cost for painting houses
    # We need to track the minimum costs for different color combinations
    
    # Initialize DP arrays for the first house
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(2)]
    
    # For the first pair of houses (positions 0 and n-1)
    for c0 in range(3):
        for c_last in range(3):
            if c0 != c_last:  # Adjacent constraint for first and last
                dp[0][c0][c_last] = cost_prefix[0][c0] + cost_prefix[n-2][c_last]
    
    # Process the remaining pairs
    for i in range(1, n//2):
        new_dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(2)]
        
        for prev_c0 in range(3):
            for prev_c_last in range(3):
                if dp[0][prev_c0][prev_c_last] == float('inf'):
                    continue
                
                # Current pair: positions i and n-1-i
                for c0 in range(3):
                    for c_last in range(3):
                        # Check constraints:
                        # 1. Adjacent houses cannot have same color
                        if c0 == prev_c0:  # current i vs previous i-1
                            continue
                        if c_last == prev_c_last:  # current n-1-i vs previous n-i
                            continue
                        # 2. Equidistant houses cannot have same color
                        if c0 == c_last:  # positions i and n-1-i
                            continue
                        
                        cost = dp[0][prev_c0][prev_c_last] + cost_prefix[i][c0] + cost_prefix[n-1-i-1][c_last]
                        if cost < new_dp[0][c0][c_last]:
                            new_dp[0][c0][c_last] = cost
        
        dp = new_dp
    
    # Now we need to find cost_suffix such that when added to the last house,
    # the minimum beautiful painting cost equals the given value
    
    # The last house is at position n-1, which we haven't fully considered yet
    # We need to find the minimum from our DP and adjust with cost_suffix
    
    min_cost_without_last = float('inf')
    for c0 in range(3):
        for c_last in range(3):
            min_cost_without_last = min(min_cost_without_last, dp[0][c0][c_last])
    
    # If the minimum cost without the last house is already greater than the target,
    # it's impossible to achieve the target
    if min_cost_without_last > minimum_beautiful_painting_cost:
        raise ValueError("Invalid input")
    
    # We need to find cost_suffix values that make the total cost equal to minimum_beautiful_painting_cost
    # The total cost = min_cost_without_last + min(cost_suffix[0][c] for valid colors c)
    
    # Find valid colors for the last house based on constraints with the second last house
    valid_colors = []
    for c_last in range(3):
        # Check if this color is valid for the last house
        # It must be different from the color of house at position n-2
        # and different from the color of house at position 0 (since n-1 and 0 are equidistant)
        
        # We need to check all possible color combinations that achieve min_cost_without_last
        valid = False
        for c0 in range(3):
            if dp[0][c0][c_last] == min_cost_without_last:
                # Check if c_last is valid (different from color at position n-2 and position 0)
                if c_last != c0:  # Different from position 0 (equidistant constraint)
                    valid = True
                    break
        
        if valid:
            valid_colors.append(c_last)
    
    if not valid_colors:
        raise ValueError("Invalid input")
    
    # Calculate the required cost_suffix value
    required_suffix_cost = minimum_beautiful_painting_cost - min_cost_without_last
    
    # Create cost_suffix with the required value for one valid color and 0 for others
    cost_suffix = [[0, 0, 0]]
    for color in valid_colors:
        cost_suffix[0][color] = required_suffix_cost
    
    return cost_suffix
