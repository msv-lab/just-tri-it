# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    MOD = modulus
    N = num_vertices
    
    # Validate inputs
    if N < 3:
        raise ValueError("Invalid input")
    if len(binary_string) != N:
        raise ValueError("Invalid input")
    if not all(c in '01' for c in binary_string):
        raise ValueError("Invalid input")
    
    # Count number of '1's in binary string
    k = binary_string.count('1')
    total_edges = N + k
    
    # Precompute factorials and inverse factorials for combinatorial calculations
    fact = [1] * (total_edges + 5)
    inv_fact = [1] * (total_edges + 5)
    
    for i in range(2, total_edges + 5):
        fact[i] = fact[i-1] * i % MOD
    
    # Fermat's little theorem for modular inverse
    def mod_pow(a, b, mod):
        res = 1
        while b:
            if b & 1:
                res = res * a % mod
            a = a * a % mod
            b >>= 1
        return res
    
    inv_fact[total_edges + 4] = mod_pow(fact[total_edges + 4], MOD-2, MOD)
    for i in range(total_edges + 3, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def comb(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # The key insight: we need to count the number of valid in-degree sequences
    # For the cycle vertices, each vertex's in-degree can be 0, 1, 2, or 3
    # For the center vertex, in-degree can be 0 to k
    
    # Let's use generating functions and inclusion-exclusion
    # Total ways without constraints: 2^(N+k) but many give same in-degree sequence
    
    # Alternative approach: count the number of valid assignments to the cycle edges
    # and center edges that produce distinct in-degree sequences
    
    # For the cycle, the sum of in-degrees of cycle vertices from cycle edges must be N
    # For center edges, each can contribute 0 or 1 to the center's in-degree
    
    # Let's use dynamic programming
    # dp[i][j] = number of ways for first i cycle vertices to have sum of in-degrees j from cycle edges
    
    # But N can be up to 10^6, so we need a more efficient approach
    
    # Insight: The problem is equivalent to counting the number of valid (a_0, a_1, ..., a_{N-1}, b)
    # where a_i is the in-degree of vertex i from cycle edges (0, 1, or 2)
    # and b is the in-degree of the center vertex (0 to k)
    # with sum(a_i) = N and additional constraints from the binary string
    
    # Actually, let me implement the combinatorial solution from the sample analysis
    # The answer can be expressed as: sum_{i=0}^k C(k, i) * f(i) where f(i) counts
    # the number of valid in-degree assignments for the cycle given that exactly i
    # center edges point to the center
    
    # For the cycle, if we fix that exactly m center edges point to the center,
    # then we need to count the number of ways to orient the cycle edges such that
    # the in-degree sequence of cycle vertices is valid
    
    # The generating function approach for cycles is known
    # The number of Eulerian orientations of a cycle with specified in-degrees
    # can be counted using combinatorial methods
    
    result = 0
    
    # For each possible number of center edges pointing to center (0 to k)
    for m in range(k + 1):
        # Number of ways to choose which m center edges point to center
        ways_center = comb(k, m)
        
        # Now we need to count the number of valid orientations of the cycle edges
        # such that the sum of in-degrees from cycle edges is N - m
        # (since m in-degrees come from center edges)
        
        # For a cycle of length N, the number of orientations with given in-degree sum
        # can be computed using stars and bars with constraints
        
        # Each vertex can have in-degree 0, 1, or 2 from cycle edges
        # Let x_i be the in-degree of vertex i from cycle edges
        # We need sum x_i = N - m, with 0 <= x_i <= 2
        
        # Using inclusion-exclusion
        total = N - m
        if total < 0 or total > 2 * N:
            continue
            
        # Count number of solutions to x_0 + ... + x_{N-1} = total with 0 <= x_i <= 2
        # Using inclusion-exclusion: 
        # C(total + N - 1, N - 1) 
        # - N * C(total - 3 + N - 1, N - 1) 
        # + C(N, 2) * C(total - 6 + N - 1, N - 1) - ...
        
        ways_cycle = 0
        sign = 1
        for t in range(0, min(N, total // 3) + 1):
            if total - 3 * t < 0:
                break
            term = comb(N, t) * comb(total - 3 * t + N - 1, N - 1) % MOD
            ways_cycle = (ways_cycle + sign * term) % MOD
            sign = -sign
        
        ways_cycle = (ways_cycle % MOD + MOD) % MOD
        
        result = (result + ways_center * ways_cycle) % MOD
    
    return result
