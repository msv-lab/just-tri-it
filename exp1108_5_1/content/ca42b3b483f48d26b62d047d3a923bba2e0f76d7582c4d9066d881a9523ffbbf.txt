# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if not (0 <= val <= 10**5):
                raise ValueError("Invalid input")
    
    # For symmetric positions (i, n-1-i), we need to choose different colors
    # Also adjacent houses need different colors
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i+1 pairs (i from 0 to n/2-1) where the i-th pair has colors c1 and c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # Instead, we can process pairs independently and track the best combinations
    
    # For each pair (i, n-1-i), we need to choose two different colors
    # And these pairs must be consistent with adjacent pairs
    
    # Let's define dp[i][c] as the minimum cost for the first i pairs where
    # the i-th pair's left house has color c
    
    # But we need to track both colors in the pair
    
    # Actually, let's think differently: we need to assign colors to all houses
    # such that:
    # 1. house[i] != house[i+1] for all i
    # 2. house[i] != house[n-1-i] for all i
    
    # This is equivalent to a graph coloring problem on a specific graph structure
    
    # Since n is even, we can think of the houses as forming a circular constraint
    # with additional cross constraints
    
    # Let's process the array in pairs (i, n-1-i)
    # For each such pair, we need to assign two different colors
    
    # And consecutive pairs must have the left color of current pair != right color of previous pair
    # and the right color of current pair != left color of next pair
    
    # We can use DP where state is (color_left, color_right) for current pair
    
    k = n // 2
    
    # Initialize DP table
    INF = float('inf')
    dp = [[INF for _ in range(3)] for _ in range(3)]
    
    # For the first pair (0, n-1)
    for c0 in range(3):
        for cn1 in range(3):
            if c0 != cn1:
                dp[c0][cn1] = cost[0][c0] + cost[n-1][cn1]
    
    # Process remaining pairs
    for i in range(1, k):
        new_dp = [[INF for _ in range(3)] for _ in range(3)]
        
        for prev_c0 in range(3):
            for prev_cn1 in range(3):
                if dp[prev_c0][prev_cn1] == INF:
                    continue
                
                # Current pair is (i, n-1-i)
                for curr_c0 in range(3):
                    for curr_cn1 in range(3):
                        # Check constraints:
                        # 1. Colors in current pair must be different
                        if curr_c0 == curr_cn1:
                            continue
                        # 2. Current left color must be different from previous right color
                        #    (since houses i-1 and i are adjacent)
                        if curr_c0 == prev_cn1:
                            continue
                        # 3. Current right color must be different from next left color
                        #    This will be handled in next iteration
                        
                        cost_here = cost[i][curr_c0] + cost[n-1-i][curr_cn1]
                        new_dp[curr_c0][curr_cn1] = min(new_dp[curr_c0][curr_cn1], 
                                                       dp[prev_c0][prev_cn1] + cost_here)
        
        dp = new_dp
    
    # Find minimum cost
    min_cost = INF
    for c0 in range(3):
        for cn1 in range(3):
            min_cost = min(min_cost, dp[c0][cn1])
    
    return int(min_cost) if min_cost != INF else 0
