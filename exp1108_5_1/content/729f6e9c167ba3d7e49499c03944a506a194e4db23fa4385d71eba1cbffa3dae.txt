# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate constraints
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for making each possible subarray of length x have all equal elements
    # For a subarray starting at index i, the optimal target value is the median of nums[i:i+x]
    # The cost is the sum of absolute differences from the median
    
    costs = []
    
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        
        # Find median using quickselect or sorting (sorting is acceptable given constraints)
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]
        
        # Calculate cost to make all elements equal to median
        cost = sum(abs(num - median) for num in subarray)
        costs.append((cost, i))
    
    # We need to select k non-overlapping subarrays
    # This is a dynamic programming problem where dp[i][j] = min cost to select j subarrays
    # from first i possible starting positions
    
    # Since k is small (<=15), we can use DP with state (position, count)
    # But we need to ensure subarrays don't overlap
    
    m = len(costs)  # number of possible subarrays
    
    # Initialize DP table
    INF = float('inf')
    dp = [[INF] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        cost_i, start_i = costs[i-1]
        end_i = start_i + x - 1
        
        # Copy previous state (don't take current subarray)
        for j in range(k + 1):
            dp[i][j] = min(dp[i][j], dp[i-1][j])
        
        # Try to take current subarray
        for j in range(1, k + 1):
            # Find the last subarray that doesn't overlap with current one
            prev_i = i - 1
            while prev_i > 0:
                _, start_prev = costs[prev_i-1]
                end_prev = start_prev + x - 1
                if end_prev < start_i:  # No overlap
                    dp[i][j] = min(dp[i][j], dp[prev_i][j-1] + cost_i)
                    break
                prev_i -= 1
            else:
                # If no previous subarray found, this is the first one
                if j == 1:
                    dp[i][j] = min(dp[i][j], cost_i)
    
    # Find minimum cost to get exactly k subarrays
    result = INF
    for i in range(m + 1):
        if dp[i][k] < result:
            result = dp[i][k]
    
    if result == INF:
        raise ValueError("Invalid input")
    
    return result + 1
