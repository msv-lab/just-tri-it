# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Validate inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    for num in nums:
        if not (-10**6 <= num <= 10**6):
            raise ValueError("Invalid input")
    
    n = len(nums)
    # Collect all possible subarrays of size x
    subarrays = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        # To make all elements equal with minimal operations, they should be equal to the median
        # Using the median minimizes the sum of absolute deviations
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2] if x % 2 == 1 else sorted_sub[x // 2 - 1]  # lower median for even x
        operations = sum(abs(num - median) for num in subarray)
        subarrays.append((operations, i, i + x - 1))
    
    if len(subarrays) < k:
        raise ValueError("Invalid input")
    
    # Now, we need to select k non-overlapping subarrays with minimal total operations
    # This is similar to the problem of selecting k non-overlapping intervals with minimal sum
    # We can use dynamic programming or a greedy approach with a priority queue
    
    # We'll use a priority queue to select the k smallest non-overlapping subarrays
    # Sort the subarrays by their start and end indices to facilitate selection
    subarrays.sort(key=lambda s: s[1])  # sort by start index
    
    # We'll use a min-heap to keep track of the best possible selections
    heap = []
    # We'll keep a list to track the best up to k selections ending at each position
    # Initialize DP table: dp[i][j] represents the minimal operations to select j subarrays up to index i
    # Since k is up to 15, we can manage with a list of dictionaries or a 2D array
    
    # Initialize DP as a list of dictionaries, where each dictionary keeps track of the minimal operations for 1..k subarrays
    dp = [{} for _ in range(len(subarrays))]
    
    for i in range(len(subarrays)):
        ops_i, start_i, end_i = subarrays[i]
        # For the current subarray, we can either take it or not
        # If we take it, we can add it to any previous subarrays that end before start_i
        # We need to find the best previous dp[j] with max j where end_j < start_i
        max_prev_k = 0
        # Binary search to find the rightmost subarray that ends before start_i
        left, right = 0, i - 1
        best_j = -1
        while left <= right:
            mid = (left + right) // 2
            if subarrays[mid][2] < start_i:
                best_j = mid
                left = mid + 1
            else:
                right = mid - 1
        
        # Now, for the current subarray, we can take up to k subarrays
        # Initialize dp[i][m] for m = 1 to k
        for m in range(1, k + 1):
            if m == 1:
                # Only this subarray
                current_ops = ops_i
                if current_ops < dp[i].get(m, float('inf')):
                    dp[i][m] = current_ops
            else:
                if best_j != -1 and (m - 1) in dp[best_j]:
                    current_ops = dp[best_j][m - 1] + ops_i
                    if current_ops < dp[i].get(m, float('inf')):
                        dp[i][m] = current_ops
        
        # Also, carry forward the best values from previous subarrays
        if i > 0:
            for m in range(1, k + 1):
                if m in dp[i - 1] and (m not in dp[i] or dp[i - 1][m] < dp[i][m]):
                    dp[i][m] = dp[i - 1][m]
    
    # The answer is the minimal operations for k subarrays in the last dp entry
    if k in dp[-1]:
        return dp[-1][k]
    else:
        raise ValueError("Invalid input")  # shouldn't happen per problem constraints
