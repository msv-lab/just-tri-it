# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    if not nums or x < 2 or x > len(nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute prefix sums for efficient range sum calculation
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # For a given k, we need to select k non-overlapping subarrays of length x
    # The cost for making a subarray [i, i+x-1] have all equal elements is minimized
    # when we make all elements equal to the median (for odd x) or either of the two middle values (for even x)
    
    def cost_for_subarray(start, end):
        """Calculate minimum operations to make subarray [start, end] have all equal elements"""
        length = end - start + 1
        if length != x:
            raise ValueError("Invalid input")
        
        # Extract the subarray
        subarr = nums[start:end + 1]
        
        # Sort to find median
        sorted_subarr = sorted(subarr)
        
        # For minimum operations, make all elements equal to median
        median = sorted_subarr[length // 2]
        
        # Calculate total operations
        total_ops = 0
        for num in subarr:
            total_ops += abs(num - median)
        
        return total_ops
    
    def min_operations_for_k(k):
        """Calculate minimum operations to get k non-overlapping subarrays of length x with equal elements"""
        if k * x > n:
            return float('inf')
        
        # DP approach: dp[i][j] = min operations using first i elements to form j subarrays
        # Since k is small (<=15), we can use DP
        
        # Initialize DP table
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(n + 1):
            for j in range(k + 1):
                if dp[i][j] == float('inf'):
                    continue
                
                # Option 1: Skip current position
                if i + 1 <= n:
                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
                
                # Option 2: Start a new subarray at position i
                if j + 1 <= k and i + x <= n:
                    cost = cost_for_subarray(i, i + x - 1)
                    dp[i + x][j + 1] = min(dp[i + x][j + 1], dp[i][j] + cost)
        
        return dp[n][k]
    
    # Binary search for k that gives exactly the target operations
    left, right = 1, n // x
    
    # Find maximum k that satisfies the constraint
    max_possible_k = 0
    for k in range(1, 16):  # k <= 15
        if k * x <= n:
            max_possible_k = k
    
    # Check all possible k values
    valid_ks = []
    for k in range(1, max_possible_k + 1):
        if k * x <= n:
            ops = min_operations_for_k(k)
            if ops == min_operations_for_k_equal_subarrays:
                valid_ks.append(k)
    
    if not valid_ks:
        raise ValueError("Invalid input")
    
    # Return any valid k
    return valid_ks[0]
