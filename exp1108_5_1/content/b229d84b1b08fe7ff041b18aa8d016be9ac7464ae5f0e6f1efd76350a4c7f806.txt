# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if c < 0 or c > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses must have different colors
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs where the left house has color c1 and right house has color c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # Instead, we can process pairs independently since constraints only apply within pairs
    # and between adjacent pairs
    
    # For each symmetric pair (i, n-1-i), we need to choose colors (c1, c2) where c1 != c2
    # For adjacent pairs, we need to ensure that the right color of current pair != left color of next pair
    # and the left color of current pair != right color of next pair
    
    # We can use DP that tracks the minimum cost for the first i pairs with specific color combinations
    # for the current pair
    
    # Initialize DP for the first pair
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # For the first pair (0, n-1), try all valid color combinations
    for c1 in range(3):  # color for house 0
        for c2 in range(3):  # color for house n-1
            if c1 != c2:  # symmetric houses must have different colors
                dp[c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n // 2):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        # For current pair (i, n-1-i)
        for prev_c1 in range(3):  # previous left color
            for prev_c2 in range(3):  # previous right color
                if dp[prev_c1][prev_c2] == float('inf'):
                    continue
                
                # Try all valid color combinations for current pair
                for curr_c1 in range(3):  # current left color
                    for curr_c2 in range(3):  # current right color
                        # Check constraints:
                        # 1. Symmetric houses must have different colors
                        if curr_c1 == curr_c2:
                            continue
                        # 2. Adjacent houses must have different colors:
                        #    - Current left house (i) must be different from previous left house (i-1)
                        if curr_c1 == prev_c1:
                            continue
                        #    - Current right house (n-1-i) must be different from previous right house (n-i)
                        if curr_c2 == prev_c2:
                            continue
                        
                        total_cost = dp[prev_c1][prev_c2] + cost[i][curr_c1] + cost[n-1-i][curr_c2]
                        if total_cost < new_dp[curr_c1][curr_c2]:
                            new_dp[curr_c1][curr_c2] = total_cost
        
        dp = new_dp
    
    # Find minimum cost
    min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_cost = min(min_cost, dp[c1][c2])
    
    if min_cost == float('inf'):
        raise ValueError("Invalid input")
    
    return min_cost + 1
