# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose two different colors
    # There are 3 colors total, so for each pair we have 3 * 2 = 6 possible color assignments
    
    # dp[i][c1][c2] would be too expensive, so we'll use a different approach
    # We'll process pairs and track the minimum costs for different color combinations
    
    # Initialize DP for the first pair
    pair0_min = float('inf')
    pair0_second_min = float('inf')
    pair0_colors = (-1, -1)
    
    # For the first pair (0, n-1), try all 6 possible color combinations
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Different colors for symmetric houses
                total_cost = cost[0][c1] + cost[n-1][c2]
                if total_cost < pair0_min:
                    pair0_second_min = pair0_min
                    pair0_min = total_cost
                    pair0_colors = (c1, c2)
                elif total_cost < pair0_second_min:
                    pair0_second_min = total_cost
    
    # If we only have 2 houses
    if n == 2:
        return pair0_min + 1
    
    # For subsequent pairs, we need to ensure adjacent houses don't have same color
    # and symmetric houses don't have same color
    
    # We'll track the best two options for each pair
    prev_min = pair0_min
    prev_second_min = pair0_second_min
    prev_min_colors = pair0_colors
    prev_second_colors = (-1, -1)
    
    # Find the second best colors for first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2 and (c1, c2) != prev_min_colors:
                total_cost = cost[0][c1] + cost[n-1][c2]
                if total_cost == prev_second_min:
                    prev_second_colors = (c1, c2)
                    break
    
    # Process remaining pairs
    for i in range(1, n // 2):
        j = n - 1 - i
        
        current_min = float('inf')
        current_second_min = float('inf')
        current_min_colors = (-1, -1)
        current_second_colors = (-1, -1)
        
        # Try all color combinations for current pair
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:  # Symmetric houses must have different colors
                    # Check constraint with previous house (i-1)
                    # We need to ensure house i-1 and house i have different colors
                    # and house j+1 and house j have different colors
                    
                    # Calculate cost for this color combination
                    pair_cost = cost[i][c1] + cost[j][c2]
                    
                    # Find the minimum compatible cost from previous pair
                    min_compatible_cost = float('inf')
                    
                    # Try previous minimum
                    if prev_min_colors[0] != c1 and prev_min_colors[1] != c2:
                        min_compatible_cost = min(min_compatible_cost, prev_min + pair_cost)
                    
                    # Try previous second minimum if needed
                    if prev_second_colors[0] != c1 and prev_second_colors[1] != c2:
                        min_compatible_cost = min(min_compatible_cost, prev_second_min + pair_cost)
                    
                    # If we found a compatible combination
                    if min_compatible_cost != float('inf'):
                        if min_compatible_cost < current_min:
                            current_second_min = current_min
                            current_second_colors = current_min_colors
                            current_min = min_compatible_cost
                            current_min_colors = (c1, c2)
                        elif min_compatible_cost < current_second_min:
                            current_second_min = min_compatible_cost
                            current_second_colors = (c1, c2)
        
        # Update for next iteration
        prev_min = current_min
        prev_second_min = current_second_min
        prev_min_colors = current_min_colors
        prev_second_colors = current_second_colors
    
    return prev_min + 1
