# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    if not cost_prefix:
        if minimum_beautiful_painting_cost != 0:
            raise ValueError("Invalid input")
        return [[]]
    
    n = len(cost_prefix) + 1
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if any(len(row) != 3 for row in cost_prefix):
        raise ValueError("Invalid input")
    
    if any(not (0 <= val <= 10**5) for row in cost_prefix for val in row):
        raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    # Precompute the minimum cost for the first n-1 houses
    # We need to consider the constraints:
    # 1. No two adjacent houses same color
    # 2. Houses at positions i and n-1-i cannot have same color
    
    # For the last house (position n-1), it must satisfy:
    # - Different color from house n-2
    # - Different color from house 0 (since n-1 and 0 are symmetric)
    
    # We'll compute the minimum cost for painting first n-1 houses
    # that satisfies all constraints except the last house
    
    # DP approach: track minimum costs for different color combinations
    # We need to track the color of the first and last house in the prefix
    
    # Initialize DP table: dp[i][c1][c2] = min cost for first i+1 houses
    # where first house has color c1 and last house has color c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # Alternative: track only the best two options for each position
    # and handle the symmetric constraint separately
    
    # Let's compute the minimum cost without the symmetric constraint first
    dp_prev = [[float('inf')] * 3 for _ in range(3)]
    
    # Initialize first house
    for c in range(3):
        dp_prev[c][c] = cost_prefix[0][c]
    
    # Fill DP for houses 1 to n-2
    for i in range(1, n-1):
        dp_curr = [[float('inf')] * 3 for _ in range(3)]
        
        for first_color in range(3):
            for prev_color in range(3):
                if dp_prev[first_color][prev_color] == float('inf'):
                    continue
                
                for curr_color in range(3):
                    if curr_color == prev_color:  # adjacent constraint
                        continue
                    
                    # Update dp_curr
                    new_cost = dp_prev[first_color][prev_color] + cost_prefix[i][curr_color]
                    if new_cost < dp_curr[first_color][curr_color]:
                        dp_curr[first_color][curr_color] = new_cost
        
        dp_prev = dp_curr
    
    # Now dp_prev[first_color][last_color] contains min cost for first n-1 houses
    # where first house has color first_color and last house (position n-2) has color last_color
    
    # For the complete solution, we need to add the last house (position n-1)
    # Constraints for last house:
    # 1. Different from house n-2 (last_color)
    # 2. Different from house 0 (first_color)
    
    # We need to find cost_suffix such that:
    # min_over_valid_colors(dp_prev[first_color][last_color] + cost_suffix[color]) = minimum_beautiful_painting_cost
    
    # Try all possible cost_suffix values
    for c0 in range(3):
        for c1 in range(3):
            for c2 in range(3):
                cost_suffix_val = [c0, c1, c2]
                
                # Check if this cost_suffix gives the desired minimum cost
                min_total = float('inf')
                
                for first_color in range(3):
                    for last_color in range(3):
                        if dp_prev[first_color][last_color] == float('inf'):
                            continue
                        
                        for last_house_color in range(3):
                            # Check constraints for last house
                            if last_house_color == last_color:  # adjacent to house n-2
                                continue
                            if last_house_color == first_color:  # symmetric with house 0
                                continue
                            
                            total_cost = dp_prev[first_color][last_color] + cost_suffix_val[last_house_color]
                            if total_cost < min_total:
                                min_total = total_cost
                
                if min_total == minimum_beautiful_painting_cost:
                    return [cost_suffix_val]
    
    # If no valid cost_suffix found
    raise ValueError("Invalid input")
