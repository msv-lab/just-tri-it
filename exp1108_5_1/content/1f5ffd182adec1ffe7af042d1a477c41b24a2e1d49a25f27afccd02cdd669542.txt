# signature: def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool
from typing import List

def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool:
    n = len(nums)
    
    # Validate constraints
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if k < 1 or k > 15:
        raise ValueError("Invalid input")
    if k * x < 2 or k * x > n:
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    # Precompute prefix sums for efficient range sum calculation
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
    
    # Precompute prefix sum of squares for efficient range sum of squares calculation
    prefix_sum_sq = [0] * (n + 1)
    for i in range(n):
        prefix_sum_sq[i + 1] = prefix_sum_sq[i] + nums[i] * nums[i]
    
    def get_range_sum(l, r):
        """Get sum of elements from index l to r-1"""
        return prefix_sum[r] - prefix_sum[l]
    
    def get_range_sum_sq(l, r):
        """Get sum of squares of elements from index l to r-1"""
        return prefix_sum_sq[r] - prefix_sum_sq[l]
    
    def cost_for_subarray(start, target):
        """Calculate cost to make subarray [start, start+x) all equal to target"""
        # Cost = sum((nums[i] - target)^2) but we need sum(|nums[i] - target|)
        # For optimal cost, target should be median of the subarray
        # But we can compute cost for any target using:
        # sum(|nums[i] - target|) = sum(|nums[i] - m|) + x * |m - target| where m is median
        # However, for efficiency, we'll compute directly
        
        total = 0
        for i in range(start, start + x):
            total += abs(nums[i] - target)
        return total
    
    def find_min_cost_for_k_subarrays():
        """Find the minimum total cost to get k non-overlapping subarrays of size x"""
        # We need to select k non-overlapping subarrays of size x
        # This is a dynamic programming problem
        
        # dp[i][j] = minimum cost to select j subarrays from first i elements
        # We can only select subarrays that don't overlap
        
        max_subarrays = (n // x)
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        # Precompute costs for all possible subarrays
        subarray_costs = []
        for start in range(n - x + 1):
            # For efficiency, we'll find the optimal target (median) and compute cost
            subarray = nums[start:start + x]
            sorted_subarray = sorted(subarray)
            median = sorted_subarray[x // 2]
            cost = cost_for_subarray(start, median)
            subarray_costs.append((start, cost))
        
        # Sort subarrays by end position for DP
        subarray_info = []
        for start, cost in subarray_costs:
            end = start + x
            subarray_info.append((start, end, cost))
        
        # DP transition: for each position i, we can either skip it or end a subarray at i
        for i in range(1, n + 1):
            # Copy previous state (skip current element)
            for j in range(k + 1):
                dp[i][j] = min(dp[i][j], dp[i - 1][j])
            
            # Try to end a subarray at position i (if i >= x)
            if i >= x:
                for j in range(1, k + 1):
                    # We can end a subarray at i, which starts at i - x
                    start = i - x
                    # Find cost for subarray [start, i)
                    subarray = nums[start:i]
                    sorted_subarray = sorted(subarray)
                    median = sorted_subarray[x // 2]
                    cost = cost_for_subarray(start, median)
                    
                    dp[i][j] = min(dp[i][j], dp[start][j - 1] + cost)
        
        return dp[n][k] if dp[n][k] != float('inf') else float('inf')
    
    # Calculate the minimum required operations
    min_required = find_min_cost_for_k_subarrays()
    
    # Check if the given value is valid
    # It's valid if it's >= the minimum required operations
    # (We allow using more operations than necessary)
    return min_operations_for_k_equal_subarrays >= min_required
