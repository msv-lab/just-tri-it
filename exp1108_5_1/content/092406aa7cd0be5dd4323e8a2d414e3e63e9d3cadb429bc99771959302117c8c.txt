# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Validate input constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if not (0 <= cost[i][j] <= 100000):
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Dynamic programming approach to find actual minimum cost
    # We need to consider symmetry constraints
    half = n // 2
    
    # For each symmetric pair (i, n-1-i), we need to assign different colors
    # And adjacent houses must have different colors
    
    # Precompute the minimum costs for symmetric pairs
    pair_costs = []
    for i in range(half):
        j = n - 1 - i
        
        # For symmetric pair (i, j), they cannot have same color
        # Also, adjacent constraints apply
        
        # Calculate minimum cost for this symmetric pair considering all valid color combinations
        min_pair_cost = float('inf')
        
        for color_i in range(3):
            for color_j in range(3):
                if color_i == color_j:  # Symmetric constraint
                    continue
                
                # Check adjacent constraints if applicable
                valid = True
                if i > 0:
                    # We would need to know previous colors, but in DP we handle this
                    pass
                
                if valid:
                    pair_cost = cost[i][color_i] + cost[j][color_j]
                    min_pair_cost = min(min_pair_cost, pair_cost)
        
        pair_costs.append(min_pair_cost)
    
    # Now we need to ensure adjacent houses have different colors
    # This is a complex constraint that requires proper DP
    
    # Let's implement a proper DP solution to find the actual minimum cost
    # We'll consider the chain of symmetric pairs
    
    # DP state: dp[k][c1][c2] = min cost for first k pairs where:
    # - left house of k-th pair has color c1
    # - right house of k-th pair has color c2
    
    # Initialize DP
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(half + 1)]
    
    # Base case: before first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = 0
    
    # Fill DP table
    for k in range(1, half + 1):
        i = k - 1
        left_house = i
        right_house = n - 1 - i
        
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[k-1][prev_c1][prev_c2] == float('inf'):
                    continue
                
                for curr_c1 in range(3):
                    for curr_c2 in range(3):
                        if curr_c1 == curr_c2:  # Symmetric constraint
                            continue
                        
                        # Adjacent constraint for left side
                        if k > 1:
                            # Current left house (i) is adjacent to previous right house (i-1)
                            # But in our symmetric arrangement, we need to be careful
                            # Actually, house i is adjacent to house i-1
                            if curr_c1 == prev_c1:
                                continue
                        else:
                            # For first pair, no left adjacent constraint
                            pass
                        
                        # Adjacent constraint for right side  
                        if k > 1:
                            # Current right house (n-1-i) is adjacent to previous left house (n-i)
                            if curr_c2 == prev_c2:
                                continue
                        else:
                            # For first pair, no right adjacent constraint
                            pass
                        
                        current_cost = cost[left_house][curr_c1] + cost[right_house][curr_c2]
                        total_cost = dp[k-1][prev_c1][prev_c2] + current_cost
                        
                        dp[k][curr_c1][curr_c2] = min(dp[k][curr_c1][curr_c2], total_cost)
    
    # Find the actual minimum cost
    actual_min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            actual_min_cost = min(actual_min_cost, dp[half][c1][c2])
    
    # Check if the given value matches the actual minimum cost
    return actual_min_cost == minimum_cost_symmetric_painting
