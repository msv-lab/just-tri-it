# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    if not cost_prefix:
        if minimum_beautiful_painting_cost == 0:
            return [[0, 0, 0]]
        else:
            raise ValueError("Invalid input")
    
    n = len(cost_prefix) + 1
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if any(len(row) != 3 for row in cost_prefix):
        raise ValueError("Invalid input")
    
    if any(not (0 <= val <= 10**5) for row in cost_prefix for val in row):
        raise ValueError("Invalid input")
    
    if not (0 <= minimum_beautiful_painting_cost <= 10**5 * n * 3):
        raise ValueError("Invalid input")
    
    # Precompute the minimum cost for painting the first n-1 houses
    # We need to consider constraints for adjacent houses and symmetric houses
    
    # For the first n-1 houses, we need to find the minimum cost considering:
    # 1. No two adjacent houses have same color
    # 2. Houses at positions i and n-2-i cannot have same color (for i < n/2)
    
    # DP approach: dp[i][c1][c2] = min cost for first i+1 houses where last house has color c1
    # and symmetric house has color c2
    
    # Since n can be up to 10^5, we need a more efficient approach
    # Let's process houses in pairs (i, n-2-i)
    
    pairs = []
    for i in range(n // 2 - 1):
        pairs.append((i, n - 2 - i))
    
    # Initialize DP for the first pair
    if not pairs:
        # Only one house in cost_prefix (n=2)
        min_cost = min(cost_prefix[0])
        if min_cost != minimum_beautiful_painting_cost:
            raise ValueError("Invalid input")
        return [[0, 0, 0]]
    
    # For each pair (i, j), we need to consider all valid color combinations
    # where colors at i and j are different
    
    # We'll maintain the minimum cost for the prefix ending at each pair
    # with the colors of the last house in the prefix
    
    # For the first pair (0, n-2)
    dp = {}
    for c0 in range(3):
        for c1 in range(3):
            if c0 != c1:  # Symmetric constraint
                cost = cost_prefix[0][c0] + cost_prefix[n-2][c1]
                if (c0, c1) not in dp or cost < dp[(c0, c1)]:
                    dp[(c0, c1)] = cost
    
    # Process remaining pairs
    for idx in range(1, len(pairs)):
        i, j = pairs[idx]
        new_dp = {}
        
        for (prev_c0, prev_c1), total_cost in dp.items():
            for c_i in range(3):
                if c_i == prev_c0:  # Adjacent constraint
                    continue
                for c_j in range(3):
                    if c_j == prev_c1:  # Adjacent constraint (from the other side)
                        continue
                    if c_i == c_j:  # Symmetric constraint
                        continue
                    
                    cost = total_cost + cost_prefix[i][c_i] + cost_prefix[j][c_j]
                    key = (c_i, c_j)
                    
                    if key not in new_dp or cost < new_dp[key]:
                        new_dp[key] = cost
        
        dp = new_dp
    
    # Now we have the minimum cost for the first n-1 houses
    # We need to add the last house (cost_suffix) and satisfy:
    # 1. Last house color != second last house color
    # 2. Last house color != symmetric house color (house 0)
    
    # Find the minimum achievable cost with cost_suffix = [0, 0, 0]
    min_with_zero_suffix = float('inf')
    for (last_c0, last_c1), cost in dp.items():
        # The last house in cost_prefix is at position n-2
        # The symmetric house for position n-1 is house 0
        for c_last in range(3):
            if c_last == last_c0:  # Adjacent constraint
                continue
            if c_last == last_c1:  # Symmetric constraint with house 0
                continue
            
            total_cost = cost + 0  # cost_suffix = [0, 0, 0]
            min_with_zero_suffix = min(min_with_zero_suffix, total_cost)
    
    # If minimum cost with zero suffix is already the target, return zero
    if min_with_zero_suffix == minimum_beautiful_painting_cost:
        return [[0, 0, 0]]
    
    # Otherwise, we need to adjust cost_suffix to match the target
    # The difference between target and min_with_zero_suffix tells us how much to add
    diff = minimum_beautiful_painting_cost - min_with_zero_suffix
    
    if diff < 0:
        raise ValueError("Invalid input")
    
    # Find a valid color for the last house that satisfies constraints
    for (last_c0, last_c1), cost in dp.items():
        for c_last in range(3):
            if c_last == last_c0 or c_last == last_c1:
                continue
            
            # We can set cost_suffix such that cost + cost_suffix[c_last] = target
            cost_suffix_val = [0, 0, 0]
            cost_suffix_val[c_last] = diff
            
            # Verify the cost is within bounds
            if 0 <= cost_suffix_val[c_last] <= 10**5:
                return [cost_suffix_val]
    
    # If we couldn't find a valid solution
    raise ValueError("Invalid input")
