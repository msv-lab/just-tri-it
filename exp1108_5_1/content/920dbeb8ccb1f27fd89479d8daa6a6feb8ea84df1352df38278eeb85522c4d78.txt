# signature: def minCost(n: int, cost: List[List[int]]) -> int
# test name: test_basic_functionality_1
def test_basic_functionality_1():
    n = 4
    cost = [[3, 5, 7], [6, 2, 9], [4, 8, 1], [7, 3, 5]]
    result = minCost(n, cost)
    assert result == 9

def test_basic_functionality_2():
    n = 6
    cost = [[2, 4, 6], [5, 3, 8], [7, 1, 9], [4, 6, 2], [3, 5, 7], [8, 2, 4]]
    result = minCost(n, cost)
    assert result == 18

def test_minimum_possible_cost():
    n = 2
    cost = [[1, 2, 3], [4, 5, 6]]
    result = minCost(n, cost)
    assert result == 3  # Colors [1, 2] with costs 1 + 5 = 6 or [1, 3] with costs 1 + 6 = 7, etc. Minimum is 2 + 4 = 6 if colors are 2 and 1.

def test_multiple_valid_solutions():
    n = 2
    cost = [[1, 1, 1], [1, 1, 1]]
    result = minCost(n, cost)
    assert result == 2  # Any color combination where colors are different is valid, all have cost 2.

def test_all_houses_same_cost():
    n = 4
    cost = [[5, 5, 5], [5, 5, 5], [5, 5, 5], [5, 5, 5]]
    result = minCost(n, cost)
    assert result == 20  # Any valid color sequence will have cost 20.

def test_one_color_much_cheaper():
    n = 4
    cost = [[1, 100, 100], [100, 1, 100], [100, 100, 1], [1, 100, 100]]
    result = minCost(n, cost)
    assert result == 4  # Sequence [1, 2, 3, 1] or similar.

def test_large_n_with_alternating_costs():
    n = 100
    cost = [[i % 3, (i + 1) % 3, (i + 2) % 3] for i in range(n)]
    result = minCost(n, cost)
    # The exact expected value depends on the optimal sequence, but we can verify it's within bounds.
    assert 0 <= result <= sum(min(row) for row in cost)