# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    # Try all possible k values that satisfy constraints
    max_possible_k = n // x
    for k in range(1, max_possible_k + 1):
        if k * x > n:
            continue
            
        # Calculate minimum operations for this k
        # We need to select k disjoint subarrays of size x
        # The optimal strategy is to select consecutive subarrays and make all elements equal to the median
        
        # Precompute prefix sums for efficient range queries
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + nums[i]
        
        # DP approach: dp[i][j] = min operations for j subarrays using first i elements
        # Since k <= 15, we can use this approach
        
        INF = float('inf')
        dp = [[INF] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(n + 1):
            for j in range(k + 1):
                if dp[i][j] == INF:
                    continue
                
                # Try to add a new subarray starting at position i
                if j < k and i + x <= n:
                    # Calculate cost for subarray [i, i+x-1]
                    subarray = nums[i:i + x]
                    
                    # Sort to find median efficiently
                    sorted_sub = sorted(subarray)
                    median = sorted_sub[x // 2]
                    
                    # Calculate operations needed
                    operations = 0
                    for num in subarray:
                        operations += abs(num - median)
                    
                    dp[i + x][j + 1] = min(dp[i + x][j + 1], dp[i][j] + operations)
                
                # Skip current position
                if i + 1 <= n:
                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
        
        # Find minimum operations for exactly k subarrays
        min_ops = INF
        for i in range(n + 1):
            min_ops = min(min_ops, dp[i][k])
        
        # Check if this k matches our target
        if min_ops == min_operations_for_k_equal_subarrays:
            return k
    
    # If no k found, try a more efficient approach for larger constraints
    # Alternative approach: use sliding window to find k subarrays
    
    # Sort possible k values and use binary search-like approach
    for k in range(max_possible_k, 0, -1):
        if k * x > n:
            continue
            
        # Use greedy approach to estimate minimum operations
        # This is a heuristic since exact calculation is expensive
        
        # We'll try to find k subarrays with minimal cost
        # by considering all possible starting positions
        
        min_total_ops = float('inf')
        
        # Try different combinations of starting positions
        # Since exact solution is NP-hard for large n, we'll use a sampling approach
        
        import random
        random.seed(42)
        
        # Try multiple random starting configurations
        for _ in range(min(1000, n)):
            starts = sorted(random.sample(range(n - x + 1), k))
            
            # Check if subarrays are non-overlapping
            valid = True
            for i in range(1, k):
                if starts[i] < starts[i - 1] + x:
                    valid = False
                    break
            
            if not valid:
                continue
            
            # Calculate total operations
            total_ops = 0
            for start in starts:
                subarray = nums[start:start + x]
                sorted_sub = sorted(subarray)
                median = sorted_sub[x // 2]
                
                for num in subarray:
                    total_ops += abs(num - median)
            
            min_total_ops = min(min_total_ops, total_ops)
        
        if min_total_ops == min_operations_for_k_equal_subarrays:
            return k
    
    raise ValueError("No valid k found for given operations count")
