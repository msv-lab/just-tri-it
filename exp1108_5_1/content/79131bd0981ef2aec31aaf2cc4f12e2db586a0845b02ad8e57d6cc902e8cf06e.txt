# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute the cost for making each possible segment of length x equal to any target value
    # The optimal target for a segment is the median of the segment
    segments = []
    for i in range(n - x + 1):
        segment = nums[i:i+x]
        sorted_segment = sorted(segment)
        median = sorted_segment[x // 2] if x % 2 == 1 else sorted_segment[x // 2 - 1]
        
        # Calculate cost to make all elements equal to median
        cost = sum(abs(num - median) for num in segment)
        segments.append((cost, i))
    
    # We need to select k non-overlapping segments
    # Use dynamic programming: dp[i][j] = min cost to select j segments ending at or before position i
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    
    for i in range(1, n + 1):
        for j in range(k + 1):
            # Option 1: Don't take any segment ending at i-1
            dp[i][j] = min(dp[i][j], dp[i-1][j])
            
            # Option 2: Take a segment ending at i-1 if possible
            if j >= 1 and i >= x:
                # Find all segments that end at position i-1
                for seg_idx in range(max(0, i - x), i):
                    if seg_idx + x <= n:
                        seg_cost, start_idx = segments[seg_idx]
                        # Check if this segment doesn't overlap with previously selected segments
                        # We need to ensure the segment starts at or after the end of the last selected segment
                        # We'll track this by checking if we can add this segment to dp[start_idx][j-1]
                        if start_idx >= 0 and dp[start_idx][j-1] != float('inf'):
                            dp[i][j] = min(dp[i][j], dp[start_idx][j-1] + seg_cost)
    
    # Find the minimum cost to get exactly k segments
    result = float('inf')
    for i in range(x * k, n + 1):
        result = min(result, dp[i][k])
    
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    return result
