# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n < 2 or n != len(cost) or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    
    # Pair the houses that are equidistant from the ends
    pairs = []
    for i in range(n // 2):
        j = n - 1 - i
        pairs.append((i, j))
    
    # Precompute the minimum and second minimum costs for each pair, along with their colors
    pair_info = []
    for i, j in pairs:
        # For house i and j, we need to choose colors such that they are different
        # We'll store the best two options for each house in the pair
        # For each possible color combination where i and j have different colors
        min_cost = float('inf')
        best_colors = (-1, -1)
        
        for ci in range(3):
            for cj in range(3):
                if ci != cj:
                    current_cost = cost[i][ci] + cost[j][cj]
                    if current_cost < min_cost:
                        min_cost = current_cost
                        best_colors = (ci, cj)
        
        # Also store the second best option where colors are different
        second_min_cost = float('inf')
        second_colors = (-1, -1)
        
        for ci in range(3):
            for cj in range(3):
                if ci != cj and (ci, cj) != best_colors:
                    current_cost = cost[i][ci] + cost[j][cj]
                    if current_cost < second_min_cost:
                        second_min_cost = current_cost
                        second_colors = (ci, cj)
        
        pair_info.append({
            'min_cost': min_cost,
            'best_colors': best_colors,
            'second_min_cost': second_min_cost,
            'second_colors': second_colors
        })
    
    # Now, we need to ensure that adjacent pairs (i.e., consecutive pairs in the pairs list) have different colors
    # Initialize DP where dp[i][0] is the min cost up to pair i using the best colors,
    # and dp[i][1] is the min cost up to pair i using the second best colors
    if not pair_info:
        return 0
    
    dp = [[0] * 2 for _ in range(len(pair_info))]
    dp[0][0] = pair_info[0]['min_cost']
    dp[0][1] = pair_info[0]['second_min_cost']
    
    for i in range(1, len(pair_info)):
        prev_pair = pair_info[i-1]
        current_pair = pair_info[i]
        
        # If current pair uses best colors, check if colors conflict with previous pair's best or second best
        # Check if current_pair's best_colors for i and j conflict with previous_pair's best_colors or second_colors
        # Since the pairs are consecutive in the original house list, the last house of previous pair (i-1, j+1) is adjacent to first house of current pair (i, j)
        # Wait, the pairs are (0, n-1), (1, n-2), etc. So adjacent pairs in the pairs list are not adjacent in the original house list.
        # Actually, the adjacency is between the second house of previous pair and first house of current pair.
        # For example, pair 0 is (0, n-1), pair 1 is (1, n-2). Then house 1 is adjacent to house 0 and house n-2 is adjacent to house n-1.
        # So when choosing colors for pair i, the color of house i must not be the same as house i-1 (from pair i-1's first house)
        # and the color of house n-1-i must not be the same as house n-i (from pair i-1's second house)
        
        # So for current pair i (houses i and n-1-i), the constraints are:
        # house i's color != house i-1's color (from pair i-1's first house)
        # house n-1-i's color != house n-i's color (from pair i-1's second house)
        
        # So we need to track the colors used in the previous pair's first and second houses
        
        # Previous pair's first house is i-1, second house is n - (i-1) - 1 = n - i
        # Current pair's first house is i, second house is n - i - 1
        
        # So for current pair i:
        # color_i != color_{i-1} (from previous pair's first house)
        # color_{n-i-1} != color_{n-i} (from previous pair's second house)
        
        # So when choosing colors for current pair, we need to ensure:
        # current_pair's first color (ci) != previous_pair's first color
        # current_pair's second color (cj) != previous_pair's second color
        
        # Now, compute the transitions for dp[i][0] and dp[i][1]
        
        # Option 1: current pair uses best_colors
        ci, cj = current_pair['best_colors']
        cost_option1 = current_pair['min_cost']
        
        # Check previous pair's best_colors
        prev_ci, prev_cj = prev_pair['best_colors']
        if ci != prev_ci and cj != prev_cj:
            total_cost = dp[i-1][0] + cost_option1
        else:
            total_cost = float('inf')
        
        # Check previous pair's second_colors
        prev_ci_second, prev_cj_second = prev_pair['second_colors']
        if ci != prev_ci_second and cj != prev_cj_second:
            total_cost = min(total_cost, dp[i-1][1] + cost_option1)
        else:
            pass  # total_cost remains as is
        
        if total_cost == float('inf'):
            # Not possible to use best_colors for current pair
            dp[i][0] = float('inf')
        else:
            dp[i][0] = total_cost
        
        # Option 2: current pair uses second_colors
        ci, cj = current_pair['second_colors']
        cost_option2 = current_pair['second_min_cost']
        
        # Check previous pair's best_colors
        prev_ci, prev_cj = prev_pair['best_colors']
        if ci != prev_ci and cj != prev_cj:
            total_cost = dp[i-1][0] + cost_option2
        else:
            total_cost = float('inf')
        
        # Check previous pair's second_colors
        prev_ci_second, prev_cj_second = prev_pair['second_colors']
        if ci != prev_ci_second and cj != prev_cj_second:
            total_cost = min(total_cost, dp[i-1][1] + cost_option2)
        else:
            pass  # total_cost remains as is
        
        if total_cost == float('inf'):
            # Not possible to use second_colors for current pair
            dp[i][1] = float('inf')
        else:
            dp[i][1] = total_cost
        
        if dp[i][0] == float('inf') and dp[i][1] == float('inf'):
            # No valid coloring possible
            raise ValueError("No valid coloring possible")
    
    return min(dp[-1][0], dp[-1][1])
