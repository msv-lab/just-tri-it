# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n < 2:
        raise ValueError("Invalid input")
    
    if len(cost) != n or any(len(row) != 3 for row in cost):
        raise ValueError("Invalid input")
    
    if any(any(c < 0 for c in row) for row in cost):
        raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to consider all color combinations
    # where the two houses have different colors
    
    # dp[i][c1][c2] would be too expensive, so we'll use a different approach
    # We'll process pairs and track the minimum costs for different color combinations
    
    # Initialize: for the first pair (0, n-1)
    pair_count = n // 2
    prev_dp = [[float('inf')] * 3 for _ in range(3)]
    
    # For the first pair, initialize all valid color combinations
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric houses must have different colors
                prev_dp[c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, pair_count):
        curr_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if prev_dp[prev_c1][prev_c2] == float('inf'):
                    continue
                
                # Current pair: houses at positions i and n-1-i
                for curr_c1 in range(3):
                    # Adjacent constraint: current house i cannot have same color as previous house i-1
                    if curr_c1 == prev_c1:
                        continue
                    
                    for curr_c2 in range(3):
                        # Adjacent constraint: current house n-1-i cannot have same color as previous house n-i
                        if curr_c2 == prev_c2:
                            continue
                        
                        # Symmetric constraint: current pair must have different colors
                        if curr_c1 == curr_c2:
                            continue
                        
                        total_cost = prev_dp[prev_c1][prev_c2] + cost[i][curr_c1] + cost[n-1-i][curr_c2]
                        if total_cost < curr_dp[curr_c1][curr_c2]:
                            curr_dp[curr_c1][curr_c2] = total_cost
        
        prev_dp = curr_dp
    
    # Find the minimum cost from the last pair
    min_total = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            if prev_dp[c1][c2] < min_total:
                min_total = prev_dp[c1][c2]
    
    return min_total
