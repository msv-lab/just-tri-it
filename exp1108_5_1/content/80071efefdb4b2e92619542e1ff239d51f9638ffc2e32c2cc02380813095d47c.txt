# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also, adjacent houses cannot have the same color
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs where the i-th pair has colors c1 and c2
    # But this would be O(n * 3^4) which is too slow for n=10^5
    
    # Instead, we can process pairs independently and combine results
    # For each symmetric pair (i, n-1-i), we need to assign different colors to both houses
    # and the colors must be different from adjacent pairs
    
    # Let's precompute for each pair the valid color combinations and their costs
    pair_costs = []
    for i in range(n // 2):
        j = n - 1 - i
        costs_for_pair = []
        
        # For houses i and j, try all valid color combinations
        for c1 in range(3):  # color for house i
            for c2 in range(3):  # color for house j
                if c1 != c2:  # Houses equidistant from ends must have different colors
                    # Also check adjacent constraints if applicable
                    valid = True
                    
                    # Check if this color combination is valid with previous pair
                    # We'll handle this in DP
                    costs_for_pair.append((c1, c2, cost[i][c1] + cost[j][c2]))
        
        pair_costs.append(costs_for_pair)
    
    # Now use DP where dp[i][c] = min cost for first i pairs where the i-th pair's first house has color c
    # But we need to track both colors of the pair
    
    # Since we have 3 colors and pairs, we can use a simpler approach
    # For each pair, we'll track the minimum costs for each possible color of the first house
    
    # Initialize DP for the first pair
    dp = {}
    for c1, c2, total_cost in pair_costs[0]:
        dp[(c1, c2)] = total_cost
    
    # Process remaining pairs
    for i in range(1, len(pair_costs)):
        new_dp = {}
        
        for prev_c1, prev_c2 in dp:
            for curr_c1, curr_c2, curr_cost in pair_costs[i]:
                # Check constraints:
                # 1. Adjacent houses cannot have same color
                #    The second house of previous pair (at position i-1) is adjacent to first house of current pair (at position i)
                #    But wait, the houses are arranged as: ... house[i-1], house[i], house[n-i], house[n-i-1] ...
                #    Actually, for symmetric pairs, the adjacency is:
                #    - Within a pair: no constraint between the two houses (they're not adjacent)
                #    - Between pairs: house[i] is adjacent to house[i+1], and house[n-i-1] is adjacent to house[n-i-2]
                
                # The important adjacency constraints are:
                # 1. house[i] != house[i+1] (normal adjacent constraint)
                # 2. house[n-i-1] != house[n-i-2] (normal adjacent constraint)  
                # 3. house[i] != house[n-i-1] (symmetric constraint - already handled in pair creation)
                
                # So for transition from pair i-1 to pair i:
                # - house[i-1] (second element of previous pair's first house color) should not equal house[i] (current pair's first house color)
                if prev_c1 == curr_c1:
                    continue
                
                # Also, the second house of current pair should not equal the first house of next pair
                # But we handle this when processing the next pair
                
                key = (curr_c1, curr_c2)
                new_cost = dp[(prev_c1, prev_c2)] + curr_cost
                if key not in new_dp or new_cost < new_dp[key]:
                    new_dp[key] = new_cost
        
        dp = new_dp
    
    # Find minimum cost
    if not dp:
        raise ValueError("Invalid input")
    
    min_cost = min(dp.values())
    
    # Add 1 to the final answer as requested
    return min_cost + 1
