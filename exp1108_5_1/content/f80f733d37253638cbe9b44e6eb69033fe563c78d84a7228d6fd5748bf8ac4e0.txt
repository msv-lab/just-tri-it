# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    if not cost_prefix:
        if minimum_beautiful_painting_cost == 0:
            return [[0, 0, 0]]
        else:
            raise ValueError("Invalid input")
    
    n = len(cost_prefix) + 1
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if any(len(row) != 3 for row in cost_prefix):
        raise ValueError("Invalid input")
    
    if any(not (0 <= cost <= 10**5) for row in cost_prefix for cost in row):
        raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    # Precompute the minimum cost for the first n-1 houses
    # We need to consider the constraints:
    # 1. No two adjacent houses same color
    # 2. Houses at symmetric positions (i, n-1-i) cannot have same color
    
    # For the first n-1 houses, we need to find the minimum cost considering:
    # - Adjacency constraint between consecutive houses
    # - Symmetry constraint between pairs (i, n-1-i) for i < n-1
    
    # Since we're only given cost_prefix (first n-1 houses), and we need to find
    # cost_suffix for the last house, the last house forms symmetric pairs with house 0
    
    # Let's compute the minimum cost for painting first n-1 houses with all constraints
    # except the constraint involving the last house
    
    # We'll use dynamic programming where dp[i][c] = min cost for first i+1 houses
    # ending with color c, considering all constraints up to i
    
    # But we need to handle the symmetry constraints carefully
    # For symmetric pairs (i, n-1-i):
    # - If i < n-1-i: both houses exist in cost_prefix
    # - If i = n-1-i: this is the middle pair, only for odd n (but n is even)
    # - The pair (0, n-1) involves the last house (not in cost_prefix)
    
    # Since n is even, the symmetric pairs are:
    # (0, n-1), (1, n-2), ..., (n/2-1, n/2)
    
    # The pair (0, n-1) involves house 0 (in cost_prefix) and house n-1 (last house, not in cost_prefix)
    # All other pairs involve two houses from cost_prefix
    
    # Let's first compute the minimum cost for painting houses 1 to n-2 with all symmetry constraints
    # except the pair (0, n-1)
    
    # We'll process pairs: (1, n-2), (2, n-3), ..., (n/2-1, n/2)
    
    # Initialize with the first pair (0, n-1) - but house n-1 is not available yet
    # So we'll compute for houses 1 to n-2 first
    
    if n == 2:
        # Special case: only 2 houses
        # House 0 is in cost_prefix, house 1 is the last house (cost_suffix)
        # Constraint: they can't have same color (adjacent) and also symmetric pair (0,1)
        # So they just can't have same color
        
        # For the given minimum_beautiful_painting_cost, we need:
        # min_{c0, c1, c0 != c1} [cost_prefix[0][c0] + cost_suffix[0][c1]] = minimum_beautiful_painting_cost
        
        # Let's find cost_suffix that satisfies this
        house0_costs = cost_prefix[0]
        
        for c1 in range(3):
            cost_suffix_val = [0, 0, 0]
            # Try each color for the last house
            for try_c1 in range(3):
                if try_c1 == c1:
                    cost_suffix_val[try_c1] = 0
                else:
                    cost_suffix_val[try_c1] = 10**5 + 1
            
            # Now check if with this cost_suffix, the minimum cost equals the target
            min_cost = float('inf')
            for c0 in range(3):
                if c0 != c1:
                    total_cost = house0_costs[c0] + cost_suffix_val[c1]
                    min_cost = min(min_cost, total_cost)
            
            if min_cost == minimum_beautiful_painting_cost:
                return [cost_suffix_val]
        
        # If no solution found with one color fixed, try a different approach
        # We need min_{c0 != c1} [house0_costs[c0] + cost_suffix_val[c1]] = target
        
        # Let cost_suffix_val = [x, y, z]
        # Then min_cost = min(house0_costs[0] + min(y, z), 
        #                    house0_costs[1] + min(x, z),
        #                    house0_costs[2] + min(x, y))
        
        # We need to find x, y, z in [0, 10^5] such that this equals target
        
        for x in range(0, min(10**5 + 1, minimum_beautiful_painting_cost + 1)):
            for y in range(0, min(10**5 + 1, minimum_beautiful_painting_cost + 1)):
                for z in range(0, min(10**5 + 1, minimum_beautiful_painting_cost + 1)):
                    cost_suffix_val = [x, y, z]
                    min_cost = min(
                        house0_costs[0] + min(y, z),
                        house0_costs[1] + min(x, z), 
                        house0_costs[2] + min(x, y)
                    )
                    if min_cost == minimum_beautiful_painting_cost:
                        return [cost_suffix_val]
        
        raise ValueError("Invalid input")
    
    # For n > 2, we need a more sophisticated approach
    # Let's compute the minimum cost for the first n-1 houses with all symmetry constraints
    # except the pair involving the last house
    
    # We'll process symmetric pairs from the innermost to outermost
    # The pairs are: (n/2-1, n/2), (n/2-2, n/2+1), ..., (1, n-2)
    
    # Initialize with the innermost pair
    mid = n // 2
    pair_costs = []
    
    for i in range(1, mid):
        j = n - 1 - i
        # Houses i and j are both in cost_prefix
        costs_i = cost_prefix[i]
        costs_j = cost_prefix[j]
        
        # For this pair, they can't have the same color
        pair_cost = []
        for c1 in range(3):
            min_cost_for_c1 = float('inf')
            for c2 in range(3):
                if c1 != c2:
                    min_cost_for_c1 = min(min_cost_for_c1, costs_i[c1] + costs_j[c2])
            pair_cost.append(min_cost_for_c1)
        pair_costs.append(pair_cost)
    
    # Now we have the costs for all symmetric pairs except (0, n-1)
    # We need to combine these with house 0 and the last house
    
    # Let's compute the total cost for all pairs except (0, n-1)
    total_inner_cost = 0
    for pair_cost in pair_costs:
        total_inner_cost += min(pair_cost)
    
    # Now we need to handle house 0 and the last house
    # They form a symmetric pair and are also adjacent
    
    house0_costs = cost_prefix[0]
    
    # We need: min_{c0 != c_last} [house0_costs[c0] + cost_suffix_val[c_last]] + total_inner_cost = minimum_beautiful_painting_cost
    
    # So: min_{c0 != c_last} [house0_costs[c0] + cost_suffix_val[c_last]] = minimum_beautiful_painting_cost - total_inner_cost
    target = minimum_beautiful_painting_cost - total_inner_cost
    
    if target < 0:
        raise ValueError("Invalid input")
    
    # Find cost_suffix_val that satisfies this
    for c_last in range(3):
        cost_suffix_val = [0, 0, 0]
        # Set the cost for color c_last to make the equation work
        for try_c in range(3):
            if try_c == c_last:
                # We want: min_{c0 != c_last} [house0_costs[c0] + cost_suffix_val[c_last]] = target
                # So cost_suffix_val[c_last] should be set such that:
                # min_{c0 != c_last} [house0_costs[c0]] + cost_suffix_val[c_last] = target
                # But wait, this is not exactly correct because we're taking min over c0
                
                # Let's think differently: for fixed c_last, we have:
                # min_cost = min_{c0 != c_last} [house0_costs[c0] + cost_suffix_val[c_last]]
                # = cost_suffix_val[c_last] + min_{c0 != c_last} house0_costs[c0]
                
                min_other = min(house0_costs[(c_last + 1) % 3], house0_costs[(c_last + 2) % 3])
                required = target - min_other
                
                if 0 <= required <= 10**5:
                    cost_suffix_val[c_last] = required
                    # Set other colors to high values so they're not chosen
                    for other_c in range(3):
                        if other_c != c_last:
                            cost_suffix_val[other_c] = 10**5 + 1
                    
                    # Verify the solution
                    actual_min = float('inf')
                    for c0 in range(3):
                        if c0 != c_last:
                            actual_min = min(actual_min, house0_costs[c0] + cost_suffix_val[c_last])
                    
                    if actual_min + total_inner_cost == minimum_beautiful_painting_cost:
                        return [cost_suffix_val]
    
    # If the above approach didn't work, try a brute force for small ranges
    for x in range(0, min(10**5 + 1, target + 1)):
        for y in range(0, min(10**5 + 1, target + 1)):
            for z in range(0, min(10**5 + 1, target + 1)):
                cost_suffix_val = [x, y, z]
                
                # Calculate the minimum cost for painting all houses
                min_cost_all = float('inf')
                
                # Try all valid colorings for house 0 and last house
                for c0 in range(3):
                    for c_last in range(3):
                        if c0 != c_last:  # Adjacent and symmetric constraint
                            cost = house0_costs[c0] + cost_suffix_val[c_last] + total_inner_cost
                            min_cost_all = min(min_cost_all, cost)
                
                if min_cost_all == minimum_beautiful_painting_cost:
                    return [cost_suffix_val]
    
    raise ValueError("Invalid input")
