# signature: def minCost(n: int, cost: List[List[int]]) -> int
# test name: test_symmetric_cost_structure
def test_symmetric_cost_structure():
    """Test case where costs are symmetric, forcing balanced color distribution"""
    n = 4
    cost = [
        [1, 10, 100],  # House 0
        [10, 100, 1],  # House 1  
        [100, 1, 10],  # House 2
        [1, 10, 100]   # House 3
    ]
    result = minCost(n, cost)
    # Optimal: [1, 3, 2, 1] = 1 + 1 + 1 + 1 = 4
    # Or [2, 1, 3, 2] = 10 + 10 + 10 + 10 = 40
    # Or [3, 2, 1, 3] = 100 + 100 + 100 + 100 = 400
    # Minimum should be 4
    assert result == 4

def test_extreme_cost_differences():
    """Test with very large cost differences to ensure optimal path selection"""
    n = 4
    cost = [
        [1, 1000, 1000],    # House 0
        [1000, 1, 1000],    # House 1
        [1000, 1000, 1],    # House 2  
        [1, 1000, 1000]     # House 3
    ]
    result = minCost(n, cost)
    # Must use color 1 for houses 0 and 3, but they can't be the same
    # So optimal: [1, 2, 3, 2] = 1 + 1 + 1 + 1000 = 1003
    # Or [2, 1, 2, 3] = 1000 + 1000 + 1000 + 1000 = 4000
    # Or [1, 3, 2, 3] = 1 + 1000 + 1000 + 1000 = 3001
    # Minimum should be 1003
    assert result == 1003

def test_minimal_n_with_constraints():
    """Test the smallest possible n=2 with specific constraints"""
    n = 2
    cost = [
        [1, 2, 3],  # House 0
        [3, 2, 1]   # House 1
    ]
    result = minCost(n, cost)
    # Houses 0 and 1 are equidistant and must have different colors
    # Valid combinations: [1,2]=1+2=3, [1,3]=1+1=2, [2,1]=2+3=5, [2,3]=2+1=3, [3,1]=3+3=6, [3,2]=3+2=5
    # Minimum is 2 with colors [1,3] or [3,1]
    assert result == 2

def test_forced_color_choices():
    """Test where symmetry constraints force specific color choices"""
    n = 4
    cost = [
        [1, 100, 100],  # House 0
        [100, 1, 100],  # House 1
        [100, 100, 1],  # House 2
        [100, 1, 100]   # House 3
    ]
    result = minCost(n, cost)
    # Houses 0 and 3 must be different colors
    # Houses 1 and 2 must be different colors  
    # Optimal: [1, 2, 3, 2] = 1 + 1 + 1 + 1 = 4
    assert result == 4

def test_alternating_cheap_options():
    """Test where cheap options alternate between colors"""
    n = 4
    cost = [
        [1, 10, 100],   # House 0: color 1 is cheapest
        [10, 1, 100],   # House 1: color 2 is cheapest  
        [100, 10, 1],   # House 2: color 3 is cheapest
        [10, 100, 1]    # House 3: color 3 is cheapest
    ]
    result = minCost(n, cost)
    # Cannot use all cheapest due to constraints
    # Houses 0 and 3 must be different, houses 1 and 2 must be different
    # Optimal: [1, 2, 3, 3] = 1 + 1 + 1 + 1 = 4
    assert result == 4

def test_zero_costs():
    """Test with zero costs to ensure handling of minimum values"""
    n = 4
    cost = [
        [0, 5, 10],
        [5, 0, 10], 
        [10, 5, 0],
        [0, 10, 5]
    ]
    result = minCost(n, cost)
    # Can achieve cost 0 for some houses, but constrained by symmetry
    # Houses 0 and 3 both want color 1 (cost 0), but must be different
    assert result >= 0
    assert result <= sum(min(row) for row in cost) + 5  # Some small overhead

def test_large_n_with_random_pattern():
    """Test with larger n to ensure scalability"""
    n = 8
    cost = [
        [1, 2, 3], [3, 1, 2], [2, 3, 1],
        [1, 2, 3], [3, 1, 2], [2, 3, 1],
        [1, 2, 3], [3, 1, 2]
    ]
    result = minCost(n, cost)
    # Pattern repeats every 3 houses, but symmetry constraints apply
    # Should find optimal sequence that satisfies all constraints
    assert result >= 8  # Minimum possible if all costs were 1
    assert result <= 16  # Maximum reasonable given constraints