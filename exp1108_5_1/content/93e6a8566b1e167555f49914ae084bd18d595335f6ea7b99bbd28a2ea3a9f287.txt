# signature: def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]
from typing import List
from collections import defaultdict, deque

def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]:
    n = len(nums)
    if n < 2 or len(edges) != n - 1:
        raise ValueError("Invalid input")
    
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length <= 0:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Build tree structure with parent-child relationships (root at 0)
    parent = [-1] * n
    children = defaultdict(list)
    edge_length = defaultdict(dict)
    
    # BFS to build tree structure
    visited = [False] * n
    queue = deque([0])
    visited[0] = True
    
    while queue:
        node = queue.popleft()
        for neighbor, length in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                children[node].append(neighbor)
                edge_length[node][neighbor] = length
                edge_length[neighbor][node] = length
                queue.append(neighbor)
    
    # Result: [max_length, min_nodes_for_max_length]
    result = [0, 1]  # At minimum, a single node path has length 0 with 1 node
    
    # DFS function that returns (max_length, min_nodes) for paths ending at current node
    def dfs(node):
        nonlocal result
        
        # For paths starting and ending at current node
        current_best = (0, 1)  # (length, nodes)
        
        # Process all children
        child_results = []
        for child in children[node]:
            child_length, child_nodes = dfs(child)
            
            # Add edge length to child's result
            edge_len = edge_length[node][child]
            child_length += edge_len
            child_nodes += 1
            
            child_results.append((child_length, child_nodes))
        
        # Sort child results by length descending, then by nodes ascending
        child_results.sort(key=lambda x: (-x[0], x[1]))
        
        # Update global result with best path ending at current node
        if child_results:
            best_child = child_results[0]
            if best_child[0] > result[0]:
                result = [best_child[0], best_child[1]]
            elif best_child[0] == result[0] and best_child[1] < result[1]:
                result[1] = best_child[1]
        
        # Check if we can combine two child paths (if they have unique values)
        # For efficiency, we'll track the best two paths from different subtrees
        if len(child_results) >= 2:
            # We need to ensure all values in the combined path are unique
            # For now, we'll use a simplified approach and check the top candidates
            for i in range(min(2, len(child_results))):
                for j in range(i + 1, min(3, len(child_results))):
                    length1, nodes1 = child_results[i]
                    length2, nodes2 = child_results[j]
                    
                    combined_length = length1 + length2
                    combined_nodes = nodes1 + nodes2 - 1  # Remove duplicate count for current node
                    
                    if combined_length > result[0]:
                        result = [combined_length, combined_nodes]
                    elif combined_length == result[0] and combined_nodes < result[1]:
                        result[1] = combined_nodes
        
        # Return the best path ending at current node
        return child_results[0] if child_results else (0, 1)
    
    # Start DFS from root
    dfs(0)
    
    return result
