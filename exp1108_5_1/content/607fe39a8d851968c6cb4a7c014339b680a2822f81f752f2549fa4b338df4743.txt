# signature: def minOperations(nums: List[int], x: int, k: int) -> int
# test name: test_multiple_valid_solutions_same_cost
def test_multiple_valid_solutions_same_cost():
    nums = [1, 2, 3, 1, 2, 3, 1, 2, 3]
    x = 3
    k = 2
    result = minOperations(nums, x, k)
    # Multiple ways to get cost 2: make [1,2,3] all 2, or [2,3,1] all 2, etc.
    assert result == 2

def test_non_adjacent_optimal_subarrays():
    nums = [10, 1, 10, 2, 10, 3, 10, 4, 10]
    x = 2
    k = 3
    result = minOperations(nums, x, k)
    # Best strategy: use subarrays at indices (0,2), (2,4), (4,6) 
    # and make all 10s (already correct) - cost 0
    assert result == 0

def test_k_equals_maximum_for_array():
    nums = list(range(20))  # 20 elements
    x = 2
    k = 10  # Maximum possible: 20/2 = 10
    result = minOperations(nums, x, k)
    # Must find 10 non-overlapping pairs and make each pair equal
    assert result >= 0

def test_floating_point_median_case():
    nums = [1, 3, 5, 7, 9, 11]
    x = 2
    k = 2
    result = minOperations(nums, x, k)
    # For pairs: best to use (1,3)->both 2 (cost=1+1=2), (5,7)->both 6 (cost=1+1=2)
    # Total cost = 4
    assert result == 4

def test_overlapping_constraints_optimal_selection():
    nums = [1, 100, 1, 100, 1, 100, 1, 100]
    x = 3
    k = 2
    result = minOperations(nums, x, k)
    # Best strategy: use subarrays [1,100,1] and [1,100,1] 
    # Make all elements in each subarray equal to 1
    # Cost: |100-1| + |1-1| + |100-1| + |1-1| = 99 + 0 + 99 + 0 = 198
    assert result == 198

def test_negative_target_values():
    nums = [5, 3, 1, -1, -3, -5]
    x = 3
    k = 1
    result = minOperations(nums, x, k)
    # Best subarray might be [1,-1,-3] - make all -1 (cost: |1-(-1)| + |-1-(-1)| + |-3-(-1)| = 2+0+2=4)
    assert result == 4

def test_large_k_small_x():
    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    x = 2
    k = 4
    result = minOperations(nums, x, k)
    # Need 4 pairs: best to use (1,2), (3,4), (5,6), (7,8)
    # Make each pair equal to their average: cost = 0.5+0.5 + 0.5+0.5 + 0.5+0.5 + 0.5+0.5 = 4
    # Since we need integer operations, cost = 4
    assert result == 4

def test_small_k_large_x():
    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    x = 5
    k = 1
    result = minOperations(nums, x, k)
    # Find best subarray of size 5 and make all elements equal
    # Best might be [3,4,5,6,7] -> make all 5 (cost: 2+1+0+1+2=6)
    assert result == 6

def test_all_negative_numbers_large_k():
    nums = [-10, -8, -6, -4, -2, -1, -3, -5, -7, -9]
    x = 2
    k = 4
    result = minOperations(nums, x, k)
    # Should find 4 pairs and minimize operations
    assert result >= 0

def test_mixed_positive_negative_extremes():
    nums = [-1000000, 0, 1000000, -1000000, 0, 1000000, -1000000, 0, 1000000]
    x = 3
    k = 2
    result = minOperations(nums, x, k)
    # High cost expected due to extreme value differences
    assert result >= 0