# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if not (2 <= n <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= n):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= n):
        raise ValueError("Invalid input")
    
    # Precompute cost arrays for each possible starting position
    costs = []
    for i in range(n - x + 1):
        # For subarray starting at i, length x
        subarray = nums[i:i+x]
        # Sort to find median (optimal target value)
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]
        
        # Calculate cost to make all elements equal to median
        cost = sum(abs(num - median) for num in subarray)
        costs.append((cost, i))
    
    # Sort by cost
    costs.sort()
    
    # Greedy selection of k non-overlapping subarrays
    selected = []
    total_cost = 0
    
    for cost, start in costs:
        # Check if this subarray overlaps with any already selected
        overlap = False
        for sel_start in selected:
            if not (start + x <= sel_start or sel_start + x <= start):
                overlap = True
                break
        
        if not overlap:
            selected.append(start)
            total_cost += cost
            
            if len(selected) == k:
                break
    
    return total_cost
