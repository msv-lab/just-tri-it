# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n <= 0 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    if len(cost) != n or any(len(row) != 3 for row in cost):
        raise ValueError("Invalid input")
    
    if any(any(c < 0 for c in row) for row in cost):
        raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses must have different colors
    
    # dp[i][c1][c2] would be too expensive, so we'll use a different approach
    # We'll process pairs of symmetric houses together
    
    # For each symmetric pair (i, n-1-i), we need to consider all color combinations
    # where c1 != c2 (for the symmetric constraint) and also ensure adjacent constraints
    
    # Let's define a DP that processes pairs and tracks the minimum cost for the last color chosen
    # Since we have 3 colors, we can track the best costs for ending with each color
    
    # Initialize DP for the first pair
    # The first pair consists of house 0 and house n-1
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # For the first pair, try all color combinations where colors are different
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                dp[c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process the remaining pairs
    for i in range(1, n // 2):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        # Current pair: houses i and n-1-i
        # Previous pair: houses i-1 and n-i
        
        # For each possible color combination in previous pair (prev_c1, prev_c2)
        # where prev_c1 is color of house i-1, prev_c2 is color of house n-i
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[prev_c1][prev_c2] == float('inf'):
                    continue
                
                # For current pair, try all valid color combinations
                for curr_c1 in range(3):  # color for house i
                    for curr_c2 in range(3):  # color for house n-1-i
                        # Check constraints:
                        # 1. curr_c1 != prev_c1 (adjacent constraint between i-1 and i)
                        # 2. curr_c2 != prev_c2 (adjacent constraint between n-i and n-1-i)  
                        # 3. curr_c1 != curr_c2 (symmetric constraint for current pair)
                        if curr_c1 != prev_c1 and curr_c2 != prev_c2 and curr_c1 != curr_c2:
                            total_cost = dp[prev_c1][prev_c2] + cost[i][curr_c1] + cost[n-1-i][curr_c2]
                            if total_cost < new_dp[curr_c1][curr_c2]:
                                new_dp[curr_c1][curr_c2] = total_cost
        
        dp = new_dp
    
    # Find the minimum cost in the final DP state
    min_total = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            if dp[c1][c2] < min_total:
                min_total = dp[c1][c2]
    
    return min_total if min_total != float('inf') else 0
