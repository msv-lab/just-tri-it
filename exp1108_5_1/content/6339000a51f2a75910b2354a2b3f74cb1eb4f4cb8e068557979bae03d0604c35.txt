# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if not (0 <= cost[i][j] <= 10**5):
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Try to find a valid coloring with cost <= minimum_cost_symmetric_painting
    # and verify that no coloring exists with lower cost
    
    # For each pair of symmetric houses (i, n-1-i), they must have different colors
    # Also, adjacent houses must have different colors
    
    # We'll use dynamic programming to find the minimum valid cost
    # dp[i][c1][c2] = min cost for first i+1 pairs where pair i has colors c1 and c2
    
    # Initialize DP table
    INF = float('inf')
    dp = [[[INF for _ in range(3)] for _ in range(3)] for _ in range(n//2)]
    
    # Initialize first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric houses must have different colors
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Fill DP table
    for i in range(1, n//2):
        for c1 in range(3):  # Color for house i
            for c2 in range(3):  # Color for house n-1-i
                if c1 != c2:  # Symmetric houses must have different colors
                    for prev_c1 in range(3):  # Color for house i-1
                        for prev_c2 in range(3):  # Color for house n-i
                            if prev_c1 != c1 and prev_c2 != c2:  # Adjacent houses must have different colors
                                if dp[i-1][prev_c1][prev_c2] != INF:
                                    current_cost = dp[i-1][prev_c1][prev_c2] + cost[i][c1] + cost[n-1-i][c2]
                                    dp[i][c1][c2] = min(dp[i][c1][c2], current_cost)
    
    # Find minimum cost in the last pair
    min_found = INF
    for c1 in range(3):
        for c2 in range(3):
            min_found = min(min_found, dp[n//2 - 1][c1][c2])
    
    # Check if the given value matches the computed minimum
    if min_found == INF:
        # No valid coloring exists, but the problem guarantees at least one exists
        return False
    
    return min_found == minimum_cost_symmetric_painting
