# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Check for invalid inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # The starting indices of possible subarrays of size x
    # The subarrays are non-overlapping, so we need to select k of them with at least x distance apart
    # We need to find k subarrays where the cost to make all elements in each subarray equal is minimized
    
    # Precompute the cost for each possible subarray of size x
    # For each subarray starting at i, the optimal target is the median of the subarray
    # The cost is the sum of absolute differences between each element and the median
    
    # We'll first compute for each possible starting index i (0 <= i <= n - x)
    # the cost to make all elements in nums[i..i+x-1] equal to the median
    
    costs = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        # To find the median, we can use a min heap and a max heap (but for simplicity, we'll sort)
        subarray_sorted = sorted(subarray)
        median = subarray_sorted[x // 2] if x % 2 == 1 else subarray_sorted[x // 2]  # for even x, either median is fine
        cost = sum(abs(num - median) for num in subarray)
        costs.append((cost, i))
    
    # Now, we need to select k non-overlapping subarrays with minimal total cost
    # The subarrays cannot overlap, meaning the selected subarrays must be at least x apart in starting indices
    
    # We can use dynamic programming to solve this:
    # dp[i][j] = minimal cost to select j subarrays from the first i available subarrays
    # But with n up to 1e5 and k up to 15, this might be too slow
    
    # Alternative approach: use a priority queue to greedily select the smallest cost subarrays,
    # ensuring they don't overlap with previously selected ones
    
    # We'll sort the subarrays by cost, and then select them in order, marking their ranges as used
    
    # Sort the subarrays by cost
    sorted_costs = sorted(costs, key=lambda item: item[0])
    selected = []
    total_operations = 0
    used_indices = set()
    
    for cost, i in sorted_costs:
        # Check if this subarray overlaps with any previously selected subarrays
        # The subarray occupies indices i to i+x-1
        overlap = False
        for (start, end) in selected:
            if not (i + x - 1 < start or i > end):
                overlap = True
                break
        if not overlap:
            selected.append((i, i + x - 1))
            total_operations += cost
            if len(selected) == k:
                break
    
    return total_operations
