# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    if not nums or x <= 0 or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute prefix sums for efficient median calculation
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
    
    # Function to calculate cost for a segment [l, r]
    def segment_cost(l, r):
        length = r - l + 1
        if length != x:
            return float('inf')
        
        # Find median index
        mid = l + (x - 1) // 2
        
        # Calculate cost: sum(|nums[i] - nums[mid]| for i in [l, r])
        # This can be computed using prefix sums
        left_count = mid - l
        right_count = r - mid
        
        left_sum = prefix_sum[mid] - prefix_sum[l]
        right_sum = prefix_sum[r + 1] - prefix_sum[mid + 1]
        
        cost = (nums[mid] * left_count - left_sum) + (right_sum - nums[mid] * right_count)
        return cost
    
    # Try all possible k values in the valid range
    max_possible_k = n // x
    
    for k in range(1, max_possible_k + 1):
        # Use dynamic programming to find minimum operations for exactly k subarrays
        # dp[i][j] = min operations to get j subarrays using first i elements
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(n + 1):
            for j in range(k + 1):
                if dp[i][j] == float('inf'):
                    continue
                
                # Skip current element
                if i + 1 <= n:
                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
                
                # Try to form a subarray starting at i
                if j < k and i + x <= n:
                    cost = segment_cost(i, i + x - 1)
                    if cost != float('inf'):
                        dp[i + x][j + 1] = min(dp[i + x][j + 1], dp[i][j] + cost)
        
        # Check if we found our target
        min_ops = min(dp[i][k] for i in range(n + 1))
        if min_ops == min_operations_for_k_equal_subarrays:
            return k
    
    # If no k found, try the reverse approach with binary search
    # Since multiple k could work, we can also check nearby values
    for delta in range(-2, 3):
        test_k = max(1, min(max_possible_k, min_operations_for_k_equal_subarrays + delta))
        if 2 <= test_k * x <= n:
            # Quick validation
            dp = [[float('inf')] * (test_k + 1) for _ in range(n + 1)]
            dp[0][0] = 0
            
            for i in range(n + 1):
                for j in range(test_k + 1):
                    if dp[i][j] == float('inf'):
                        continue
                    
                    if i + 1 <= n:
                        dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
                    
                    if j < test_k and i + x <= n:
                        cost = segment_cost(i, i + x - 1)
                        if cost != float('inf'):
                            dp[i + x][j + 1] = min(dp[i + x][j + 1], dp[i][j] + cost)
            
            min_ops = min(dp[i][test_k] for i in range(n + 1))
            if min_ops == min_operations_for_k_equal_subarrays:
                return test_k
    
    raise ValueError("Invalid input")
