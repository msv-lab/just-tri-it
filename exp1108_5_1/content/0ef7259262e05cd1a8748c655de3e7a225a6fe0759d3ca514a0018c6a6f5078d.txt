# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 10**5:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Check if the cost is achievable by trying all possible color combinations
    # for symmetric pairs and ensuring adjacent houses have different colors
    
    # For each symmetric pair (i, n-1-i), we need to assign colors such that:
    # 1. color[i] != color[i+1] for i from 0 to n-2
    # 2. color[i] != color[n-1-i] for i from 0 to n/2-1
    
    # We'll use dynamic programming to find the actual minimum cost
    # and compare with the given value
    
    # DP[i][c1][c2] = minimum cost for first i+1 pairs where:
    # - house i has color c1
    # - house n-1-i has color c2
    # But this would be O(n * 9) which is acceptable for n <= 10^5
    
    # Initialize DP for the first pair
    dp_prev = [[float('inf')] * 3 for _ in range(3)]
    
    # For the first pair (0, n-1)
    for c0 in range(3):
        for cn1 in range(3):
            if c0 != cn1:  # Symmetric constraint
                dp_prev[c0][cn1] = cost[0][c0] + cost[n-1][cn1]
    
    # Process remaining pairs
    for i in range(1, n // 2):
        dp_curr = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c0 in range(3):  # Color of house i-1
            for prev_cn1 in range(3):  # Color of house n-i
                if dp_prev[prev_c0][prev_cn1] == float('inf'):
                    continue
                
                for curr_c0 in range(3):  # Color of house i
                    for curr_cn1 in range(3):  # Color of house n-1-i
                        # Check constraints:
                        # 1. Adjacent houses in first half: prev_c0 != curr_c0
                        # 2. Adjacent houses in second half: curr_cn1 != prev_cn1  
                        # 3. Symmetric constraint: curr_c0 != curr_cn1
                        if (prev_c0 != curr_c0 and 
                            curr_cn1 != prev_cn1 and 
                            curr_c0 != curr_cn1):
                            
                            total_cost = (dp_prev[prev_c0][prev_cn1] + 
                                         cost[i][curr_c0] + 
                                         cost[n-1-i][curr_cn1])
                            
                            if total_cost < dp_curr[curr_c0][curr_cn1]:
                                dp_curr[curr_c0][curr_cn1] = total_cost
        
        dp_prev = dp_curr
    
    # Find the minimum cost from the last DP state
    actual_min_cost = float('inf')
    for c0 in range(3):
        for cn1 in range(3):
            if dp_prev[c0][cn1] < actual_min_cost:
                actual_min_cost = dp_prev[c0][cn1]
    
    # The given value should be equal to the actual minimum cost
    return minimum_cost_symmetric_painting == actual_min_cost
