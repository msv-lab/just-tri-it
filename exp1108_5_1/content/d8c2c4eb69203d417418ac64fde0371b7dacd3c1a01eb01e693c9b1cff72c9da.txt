# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Find the actual minimum cost by checking all valid colorings
    # Since n can be up to 10^5, we need an efficient approach
    
    # For each pair of symmetric houses (i, n-1-i), they must have different colors
    # Also, adjacent houses must have different colors
    
    # We'll use dynamic programming to find the minimum cost
    # dp[i][c1][c2] = min cost for first i pairs where the i-th pair has colors c1 and c2
    # But this would be O(n * 3^4) which is too slow for n=10^5
    
    # Instead, let's find a lower bound and check if the given value is achievable
    
    # Calculate the minimum possible cost for each symmetric pair
    min_pair_costs = []
    for i in range(n // 2):
        j = n - 1 - i
        
        # For houses i and j, they must have different colors
        # Also, house i must have different color from i-1 (if i > 0)
        # and house j must have different color from j+1 (if j < n-1)
        
        # But without knowing the full coloring, we can only calculate a lower bound
        min_cost_for_pair = float('inf')
        
        # Try all color combinations for the pair (i, j)
        for color_i in range(3):
            for color_j in range(3):
                if color_i == color_j:  # Symmetric houses can't have same color
                    continue
                
                # Check adjacent constraints for house i
                valid_i = True
                if i > 0:
                    # We don't know the color of i-1, so we can't fully validate
                    # This is a limitation of the verification approach
                    pass
                
                # Check adjacent constraints for house j  
                valid_j = True
                if j < n - 1:
                    # We don't know the color of j+1, so we can't fully validate
                    pass
                
                if valid_i and valid_j:
                    pair_cost = cost[i][color_i] + cost[j][color_j]
                    min_cost_for_pair = min(min_cost_for_pair, pair_cost)
        
        min_pair_costs.append(min_cost_for_pair)
    
    # Calculate absolute lower bound (may not be achievable due to adjacent constraints)
    lower_bound = sum(min_pair_costs)
    
    # If the given value is less than the lower bound, it's invalid
    if minimum_cost_symmetric_painting < lower_bound:
        return False
    
    # For small n, we can try to find the actual minimum cost
    if n <= 10:
        from itertools import product
        
        min_actual_cost = float('inf')
        
        # Generate all possible colorings
        for coloring in product(range(3), repeat=n):
            valid = True
            
            # Check adjacent houses constraint
            for k in range(n - 1):
                if coloring[k] == coloring[k + 1]:
                    valid = False
                    break
            
            # Check symmetric houses constraint
            if valid:
                for k in range(n // 2):
                    if coloring[k] == coloring[n - 1 - k]:
                        valid = False
                        break
            
            if valid:
                total_cost = sum(cost[i][coloring[i]] for i in range(n))
                min_actual_cost = min(min_actual_cost, total_cost)
        
        return minimum_cost_symmetric_painting == min_actual_cost
    
    # For larger n, we can't exhaustively check, so we'll use a more efficient DP
    # and verify if the given cost is achievable
    
    # Dynamic programming approach
    # dp[i][c1][c2] = min cost for first i+1 pairs where:
    # - house i has color c1
    # - house n-1-i has color c2
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n // 2)]
    
    # Initialize first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Fill DP table
    for i in range(1, n // 2):
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[i-1][prev_c1][prev_c2] == float('inf'):
                    continue
                
                for curr_c1 in range(3):
                    for curr_c2 in range(3):
                        if curr_c1 == curr_c2:  # Symmetric constraint
                            continue
                        if curr_c1 == prev_c1:  # Adjacent constraint for left side
                            continue
                        if curr_c2 == prev_c2:  # Adjacent constraint for right side
                            continue
                        
                        new_cost = dp[i-1][prev_c1][prev_c2] + cost[i][curr_c1] + cost[n-1-i][curr_c2]
                        dp[i][curr_c1][curr_c2] = min(dp[i][curr_c1][curr_c2], new_cost)
    
    # Find the minimum cost from the last pair
    actual_min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            actual_min_cost = min(actual_min_cost, dp[n//2 - 1][c1][c2])
    
    return minimum_cost_symmetric_painting == actual_min_cost
