# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    n = len(nums)
    
    # Validate inputs
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    for num in nums:
        if num < -10**6 or num > 10**6:
            raise ValueError("Invalid input")
    
    # Maximum possible k (k * x <= n)
    max_k = n // x
    
    # Binary search for k
    left, right = 1, max_k
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Calculate minimum operations for k=mid
        # We need to select mid disjoint subarrays of length x
        # The cost for making a subarray [i, i+x-1] equal is:
        # min(sum(|nums[j] - target| for j in range(i, i+x)) over all possible target values
        # The optimal target is the median of the subarray
        
        # Calculate prefix sums for efficient median calculation
        sorted_nums = sorted(nums)
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + sorted_nums[i]
        
        # Calculate minimum operations for each possible subarray
        # and select the k best ones
        
        # Calculate cost for each possible subarray
        subarray_costs = []
        for i in range(n - x + 1):
            # Get the median element
            median_idx = i + x // 2
            median = sorted_nums[median_idx]
            
            # Calculate cost: sum(|nums[j] - median|) for j in range(i, i+x)
            # Using prefix sums
            left_sum = median * (median_idx - i) - (prefix_sum[median_idx] - prefix_sum[i])
            right_sum = (prefix_sum[i + x] - prefix_sum[median_idx + 1]) - median * (i + x - median_idx - 1)
            cost = left_sum + right_sum
            
            subarray_costs.append(cost)
        
        # Sort subarray costs and take the k smallest ones
        subarray_costs.sort()
        total_operations = sum(subarray_costs[:mid])
        
        if total_operations <= min_operations_for_k_equal_subarrays:
            # We can achieve at least k subarrays with the given operations
            result = mid
            left = mid + 1
        else:
            right = mid - 1
    
    if result == -1 or result < 1 or result * x > n:
        raise ValueError("Invalid input")
    
    return result
