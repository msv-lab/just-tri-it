# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Try to find a valid coloring with cost <= minimum_cost_symmetric_painting
    # and verify that no valid coloring has lower cost
    
    # We'll use dynamic programming to find the minimum cost
    # The state is (position, color1, color2) where color1 is for current symmetric pair
    # and color2 is for the other house in the pair
    
    # For symmetric pairs (i, n-1-i), we need to assign different colors to both houses
    # and also ensure adjacent constraints
    
    # Precompute symmetric pairs
    pairs = []
    for i in range(n // 2):
        pairs.append((i, n - 1 - i))
    
    # DP approach: for each pair, track minimum costs for color combinations
    # that satisfy all constraints
    
    # Initialize DP for first pair
    dp = {}
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric houses must have different colors
                total_cost = cost[pairs[0][0]][c1] + cost[pairs[0][1]][c2]
                dp[(c1, c2)] = total_cost
    
    # Process remaining pairs
    for k in range(1, len(pairs)):
        new_dp = {}
        i, j = pairs[k]
        
        for prev_c1, prev_c2 in dp:
            for curr_c1 in range(3):
                for curr_c2 in range(3):
                    if curr_c1 != curr_c2:  # Symmetric constraint
                        # Check adjacent constraint with previous pair
                        if k > 0 and curr_c1 == prev_c1:
                            continue
                        total_cost = dp[(prev_c1, prev_c2)] + cost[i][curr_c1] + cost[j][curr_c2]
                        
                        if (curr_c1, curr_c2) not in new_dp or total_cost < new_dp[(curr_c1, curr_c2)]:
                            new_dp[(curr_c1, curr_c2)] = total_cost
        
        dp = new_dp
    
    # Find minimum cost from valid final states
    actual_min_cost = float('inf')
    for c1, c2 in dp:
        actual_min_cost = min(actual_min_cost, dp[(c1, c2)])
    
    # Check if the given value matches the actual minimum
    if actual_min_cost == float('inf'):
        return False
    
    return minimum_cost_symmetric_painting == actual_min_cost
