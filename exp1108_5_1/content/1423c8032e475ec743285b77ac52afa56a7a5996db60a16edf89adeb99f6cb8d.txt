# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    n = len(nums)
    
    # Validate constraints
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if k < 1 or k > 15:
        raise ValueError("Invalid input")
    if k * x > n:
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    
    # Precompute the cost for making each possible subarray of length x have all equal values
    # For a subarray starting at index i, the optimal target value is the median of nums[i:i+x]
    # This minimizes the sum of absolute deviations
    
    # Calculate cost for each possible subarray
    costs = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        # Find median efficiently using heap
        left_heap = []  # max heap (store negative values)
        right_heap = []  # min heap
        
        for num in subarray:
            if not left_heap or num <= -left_heap[0]:
                heapq.heappush(left_heap, -num)
            else:
                heapq.heappush(right_heap, num)
            
            # Balance heaps
            if len(left_heap) > len(right_heap) + 1:
                heapq.heappush(right_heap, -heapq.heappop(left_heap))
            elif len(right_heap) > len(left_heap):
                heapq.heappush(left_heap, -heapq.heappop(right_heap))
        
        # Median is at the top of left_heap
        median = -left_heap[0]
        
        # Calculate total operations needed
        total_ops = 0
        for num in subarray:
            total_ops += abs(num - median)
        
        costs.append((total_ops, i))
    
    # We need to select k non-overlapping subarrays
    # This is a dynamic programming problem where dp[i][j] = min operations using first i positions to get j subarrays
    
    # Sort costs by starting index for easier DP
    costs.sort(key=lambda x: x[1])
    
    # DP table: dp[i][j] = min operations using subarrays up to index i to get j subarrays
    # Initialize with infinity
    INF = float('inf')
    dp = [[INF] * (k + 1) for _ in range(len(costs) + 1)]
    dp[0][0] = 0
    
    for i in range(1, len(costs) + 1):
        cost_val, start_idx = costs[i-1]
        
        # Copy previous state (not taking current subarray)
        for j in range(k + 1):
            dp[i][j] = min(dp[i][j], dp[i-1][j])
        
        # Try to take current subarray
        for j in range(1, k + 1):
            # Find the last subarray we can take that doesn't overlap with current one
            last_valid = -1
            for prev in range(i-1, -1, -1):
                if prev == 0:
                    last_valid = 0
                    break
                _, prev_start = costs[prev-1]
                if prev_start + x <= start_idx:
                    last_valid = prev
                    break
            
            if last_valid != -1:
                dp[i][j] = min(dp[i][j], dp[last_valid][j-1] + cost_val)
    
    # Find the minimum operations for exactly k subarrays
    result = INF
    for i in range(len(costs) + 1):
        if dp[i][k] < result:
            result = dp[i][k]
    
    if result == INF:
        raise ValueError("Invalid input")
    
    # Add 1 to the result as specified
    return result + 1
