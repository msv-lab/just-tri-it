# signature: def postcondition(edges: List[List[int]], nums: List[int], longest_special_path_info: List[int]) -> bool
from typing import List
from collections import defaultdict, deque

def postcondition(edges: List[List[int]], nums: List[int], longest_special_path_info: List[int]) -> bool:
    n = len(nums)
    
    # Validate input constraints
    if n < 2 or n > 50000:
        raise ValueError("Invalid input")
    if len(edges) != n - 1:
        raise ValueError("Invalid input")
    for edge in edges:
        if len(edge) != 3:
            raise ValueError("Invalid input")
        if edge[0] < 0 or edge[0] >= n or edge[1] < 0 or edge[1] >= n:
            raise ValueError("Invalid input")
        if edge[2] < 1 or edge[2] > 1000:
            raise ValueError("Invalid input")
    if len(nums) != n:
        raise ValueError("Invalid input")
    for num in nums:
        if num < 0 or num > 50000:
            raise ValueError("Invalid input")
    if len(longest_special_path_info) != 2:
        raise ValueError("Invalid input")
    
    # Build adjacency list for the tree
    graph = defaultdict(list)
    for u, v, length in edges:
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Build the tree structure (parent-child relationships) with BFS from root 0
    parent = [-1] * n
    children = defaultdict(list)
    edge_lengths = {}  # Store edge lengths for quick lookup
    
    for u, v, length in edges:
        edge_lengths[(u, v)] = length
        edge_lengths[(v, u)] = length
    
    # BFS to establish parent-child relationships
    visited = [False] * n
    queue = deque([0])
    visited[0] = True
    
    while queue:
        node = queue.popleft()
        for neighbor, _ in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                children[node].append(neighbor)
                queue.append(neighbor)
    
    # Function to find all special paths using DFS
    def dfs(node, current_path_values, current_path_length, current_path_nodes):
        nonlocal max_length, min_nodes_count
        
        # Add current node to path
        current_path_values.add(nums[node])
        current_path_nodes += 1
        
        # Update global maximum if needed
        if current_path_length > max_length:
            max_length = current_path_length
            min_nodes_count = current_path_nodes
        elif current_path_length == max_length:
            if current_path_nodes < min_nodes_count:
                min_nodes_count = current_path_nodes
        
        # Explore children
        for child in children[node]:
            # Check if child's value is unique in current path
            if nums[child] not in current_path_values:
                edge_len = edge_lengths[(node, child)]
                dfs(child, current_path_values.copy(), current_path_length + edge_len, current_path_nodes + 1)
            else:
                # Even if value repeats, we can still start a new path from this child
                edge_len = edge_lengths[(node, child)]
                dfs(child, {nums[child]}, edge_len, 1)
    
    # Find actual longest special path info
    max_length = 0
    min_nodes_count = float('inf')
    
    # We need to consider paths starting from every node
    # Since paths can start at any node and go downward
    for start_node in range(n):
        # Start a new path from each node
        dfs(start_node, {nums[start_node]}, 0, 1)
    
    # Check if the provided info matches our calculation
    provided_length = longest_special_path_info[0]
    provided_min_nodes = longest_special_path_info[1]
    
    return provided_length == max_length and provided_min_nodes == min_nodes_count
