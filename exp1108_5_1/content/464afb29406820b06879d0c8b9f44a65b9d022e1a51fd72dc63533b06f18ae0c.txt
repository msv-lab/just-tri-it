# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Try to find if there exists a valid coloring with the given cost
    # We'll use dynamic programming to find the minimum cost and compare
    
    # For symmetric painting, we need to consider pairs of symmetric houses
    # Let's define DP for the first half of houses
    
    half = n // 2
    
    # Precompute all possible color combinations for symmetric pairs
    # For pair (i, n-1-i), we need colors (c1, c2) such that:
    # 1. c1 != c2 (symmetric constraint)
    # 2. For adjacent houses in first half: color[i] != color[i+1]
    # 3. For adjacent houses in second half: color[n-1-i] != color[n-2-i]
    
    # Let's find the actual minimum cost using DP
    INF = float('inf')
    
    # DP[i][c1][c2]: minimum cost for first i pairs where:
    # - last house in first half has color c1
    # - last house in second half has color c2
    dp_prev = [[INF for _ in range(3)] for _ in range(3)]
    
    # Initialize for first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp_prev[c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, half):
        dp_curr = [[INF for _ in range(3)] for _ in range(3)]
        
        for prev_c1 in range(3):  # Color of house i-1 in first half
            for prev_c2 in range(3):  # Color of house n-i in second half
                if dp_prev[prev_c1][prev_c2] == INF:
                    continue
                
                for curr_c1 in range(3):  # Color of house i in first half
                    for curr_c2 in range(3):  # Color of house n-1-i in second half
                        # Check constraints:
                        # 1. Adjacent in first half: prev_c1 != curr_c1
                        # 2. Adjacent in second half: prev_c2 != curr_c2  
                        # 3. Symmetric: curr_c1 != curr_c2
                        if (prev_c1 != curr_c1 and prev_c2 != curr_c2 and 
                            curr_c1 != curr_c2):
                            total_cost = (dp_prev[prev_c1][prev_c2] + 
                                         cost[i][curr_c1] + 
                                         cost[n-1-i][curr_c2])
                            if total_cost < dp_curr[curr_c1][curr_c2]:
                                dp_curr[curr_c1][curr_c2] = total_cost
        
        dp_prev = dp_curr
    
    # Find the minimum cost from all valid final states
    actual_min_cost = INF
    for c1 in range(3):
        for c2 in range(3):
            if dp_prev[c1][c2] < actual_min_cost:
                actual_min_cost = dp_prev[c1][c2]
    
    # Check if the given value matches the actual minimum cost
    return actual_min_cost == minimum_cost_symmetric_painting
