# signature: def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]
from typing import List
from collections import defaultdict

def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]:
    if not edges or len(nums) != len(edges) + 1:
        raise ValueError("Invalid input")
    
    n = len(nums)
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length <= 0:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Build tree structure with parent pointers
    parent = [-1] * n
    depth = [0] * n
    dist_from_root = [0] * n
    
    stack = [(0, -1, 0, 0)]  # node, parent, depth, distance
    while stack:
        node, par, d, dist = stack.pop()
        parent[node] = par
        depth[node] = d
        dist_from_root[node] = dist
        
        for neighbor, length in graph[node]:
            if neighbor != par:
                stack.append((neighbor, node, d + 1, dist + length))
    
    # Preprocess for LCA (binary lifting)
    LOG = (n).bit_length()
    up = [[-1] * n for _ in range(LOG)]
    
    for i in range(n):
        up[0][i] = parent[i]
    
    for i in range(1, LOG):
        for j in range(n):
            if up[i-1][j] != -1:
                up[i][j] = up[i-1][up[i-1][j]]
    
    def get_lca(a, b):
        if depth[a] < depth[b]:
            a, b = b, a
        
        # Lift a to same depth as b
        diff = depth[a] - depth[b]
        for i in range(LOG):
            if diff & (1 << i):
                a = up[i][a]
        
        if a == b:
            return a
        
        for i in range(LOG-1, -1, -1):
            if up[i][a] != up[i][b]:
                a = up[i][a]
                b = up[i][b]
        
        return up[0][a]
    
    def get_distance(u, v):
        lca = get_lca(u, v)
        return dist_from_root[u] + dist_from_root[v] - 2 * dist_from_root[lca]
    
    # Find all pairs of nodes with unique values in path
    value_to_nodes = defaultdict(list)
    for i, val in enumerate(nums):
        value_to_nodes[val].append(i)
    
    max_length = 0
    min_nodes = float('inf')
    
    # Check all pairs where path has unique values
    for val, nodes in value_to_nodes.items():
        # For same value, only individual nodes are valid (path of length 0)
        if len(nodes) == 1:
            node = nodes[0]
            path_length = 0
            num_nodes = 1
            
            if path_length > max_length:
                max_length = path_length
                min_nodes = num_nodes
            elif path_length == max_length:
                min_nodes = min(min_nodes, num_nodes)
        
        # For different values, we need to find paths with all unique values
        # This is complex, so we'll use a different approach
    
    # Alternative approach: DFS with path tracking
    visited = [False] * n
    best_length = 0
    best_nodes = float('inf')
    
    def dfs(node, par, current_path_values, current_path_nodes, current_length):
        nonlocal best_length, best_nodes
        
        # Check if current path has unique values
        if len(current_path_values) == len(current_path_nodes):
            # Valid special path
            if current_length > best_length:
                best_length = current_length
                best_nodes = len(current_path_nodes)
            elif current_length == best_length:
                best_nodes = min(best_nodes, len(current_path_nodes))
        
        for neighbor, length in graph[node]:
            if neighbor == par:
                continue
            
            new_values = current_path_values.copy()
            new_values.add(nums[neighbor])
            new_nodes = current_path_nodes + [neighbor]
            
            # Check if we can add this neighbor while maintaining uniqueness
            if nums[neighbor] not in current_path_values:
                dfs(neighbor, node, new_values, new_nodes, current_length + length)
            else:
                # Can't extend path, but the current path ending at neighbor is valid
                if len(current_path_values) == len(current_path_nodes):
                    if current_length > best_length:
                        best_length = current_length
                        best_nodes = len(current_path_nodes)
                    elif current_length == best_length:
                        best_nodes = min(best_nodes, len(current_path_nodes))
    
    # Start DFS from each node
    for i in range(n):
        visited = [False] * n
        dfs(i, -1, {nums[i]}, [i], 0)
    
    # Handle case where no path found (shouldn't happen per problem)
    if best_nodes == float('inf'):
        best_length = 0
        best_nodes = 1
    
    result = [best_length, best_nodes]
    result[0] += 1
    result[1] += 1
    return result
