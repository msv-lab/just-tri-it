# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List
import heapq

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    # Input validation
    if not nums or x < 2 or x > len(nums) or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # We need to find k such that 2 <= k * x <= n
    max_possible_k = n // x
    
    # Binary search to find the k that gives exactly min_operations_for_k_equal_subarrays operations
    left, right = 1, max_possible_k
    result_k = -1
    
    while left <= right:
        mid_k = (left + right) // 2
        
        # Calculate minimum operations needed for k subarrays
        current_operations = calculate_min_operations(nums, x, mid_k)
        
        if current_operations == min_operations_for_k_equal_subarrays:
            result_k = mid_k
            break
        elif current_operations < min_operations_for_k_equal_subarrays:
            # Need more operations, so try larger k
            left = mid_k + 1
        else:
            # Too many operations, try smaller k
            right = mid_k - 1
    
    # If exact match not found, return the closest valid k
    if result_k == -1:
        # Check if any k in the valid range satisfies the condition
        for k in range(1, max_possible_k + 1):
            if calculate_min_operations(nums, x, k) == min_operations_for_k_equal_subarrays:
                result_k = k
                break
    
    if result_k == -1:
        raise ValueError("Invalid input")
    
    # Verify constraints
    if not (2 <= result_k * x <= n):
        raise ValueError("Invalid input")
    
    return result_k

def calculate_min_operations(nums: List[int], x: int, k: int) -> int:
    """Calculate minimum operations needed to get k subarrays of length x with equal elements."""
    n = len(nums)
    
    # For each possible starting position of a subarray of length x,
    # calculate the cost to make all elements equal to the median
    subarray_costs = []
    
    for start in range(n - x + 1):
        subarray = nums[start:start + x]
        # Sort to find median
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]
        
        # Calculate cost to make all elements equal to median
        cost = sum(abs(num - median) for num in subarray)
        subarray_costs.append((cost, start, start + x - 1))
    
    # Sort subarrays by cost
    subarray_costs.sort()
    
    # We need to select k non-overlapping subarrays with minimum total cost
    # This is a greedy selection problem
    
    selected = []
    total_cost = 0
    
    for cost, start, end in subarray_costs:
        # Check if this subarray overlaps with any already selected
        overlap = False
        for sel_start, sel_end in selected:
            if not (end < sel_start or start > sel_end):
                overlap = True
                break
        
        if not overlap:
            selected.append((start, end))
            total_cost += cost
            
            if len(selected) == k:
                break
    
    # If we couldn't find k non-overlapping subarrays, return a large number
    if len(selected) < k:
        return float('inf')
    
    return total_cost
