# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    if not cost_prefix:
        n = 1
    else:
        n = len(cost_prefix) + 1
    
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(len(cost_prefix)):
        if len(cost_prefix[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost_prefix[i][j] < 0 or cost_prefix[i][j] > 100000:
                raise ValueError("Invalid input")
    
    INF = 10**18
    dp = [[[INF, INF, INF] for _ in range(3)] for _ in range(2)]
    
    if n == 2:
        for c0 in range(3):
            for c1 in range(3):
                if c0 != c1:
                    cost = cost_prefix[0][c0] + 0
                    dp[1][c0][c1] = cost
    else:
        for c0 in range(3):
            for c1 in range(3):
                if c0 != c1:
                    dp[1][c0][c1] = cost_prefix[0][c0] + cost_prefix[1][c1]
        
        for i in range(2, n-1):
            new_dp = [[INF, INF, INF] for _ in range(3)]
            for prev_prev in range(3):
                for prev in range(3):
                    if dp[i%2][prev_prev][prev] == INF:
                        continue
                    for curr in range(3):
                        if curr == prev:
                            continue
                        if i < n//2 and curr == prev_prev:
                            continue
                        if i >= n//2:
                            mirror_idx = n - 1 - i
                            if mirror_idx < i:
                                mirror_color = dp[mirror_idx%2][?][?]
                                if curr == mirror_color:
                                    continue
                        cost = dp[i%2][prev_prev][prev] + cost_prefix[i][curr]
                        if cost < new_dp[prev][curr]:
                            new_dp[prev][curr] = cost
            for prev in range(3):
                for curr in range(3):
                    dp[(i+1)%2][prev][curr] = new_dp[prev][curr]
    
    result = []
    for c_last in range(3):
        min_cost = INF
        for prev_prev in range(3):
            for prev in range(3):
                if dp[(n-1)%2][prev_prev][prev] == INF:
                    continue
                if c_last == prev:
                    continue
                if n-1 >= n//2:
                    mirror_idx = 0
                    if c_last == prev_prev:
                        continue
                cost = dp[(n-1)%2][prev_prev][prev] + 0
                if cost < min_cost:
                    min_cost = cost
        
        if min_cost + cost_suffix_val == minimum_beautiful_painting_cost:
            result.append([[cost_suffix_val]])
    
    return result
