# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is achievable
    # We need to verify that there exists a coloring that satisfies:
    # 1. No two adjacent houses have same color
    # 2. Houses at symmetric positions (i, n-1-i) have different colors
    # 3. Total cost equals minimum_cost_symmetric_painting
    
    # Since finding the actual minimum is complex, we'll check if the given value
    # corresponds to a valid coloring that satisfies all constraints
    
    # We'll use dynamic programming to find the minimum cost and compare
    # But for efficiency with large n, we'll use a simplified approach
    
    # For each symmetric pair (i, n-1-i), they must have different colors
    # And adjacent houses must have different colors
    
    # Let's find the minimum possible cost by considering all valid colorings
    # for symmetric pairs while respecting adjacent constraints
    
    # We can process the array in pairs: (0, n-1), (1, n-2), ..., (n/2-1, n/2)
    # Each pair must have different colors, and consecutive pairs must respect
    # adjacent constraints
    
    # Since n can be up to 10^5, we need an efficient approach
    
    # Let's implement a DP that goes through symmetric pairs
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # Initialize for first symmetric pair (0, n-1)
    for c0 in range(3):
        for c1 in range(3):
            if c0 != c1:  # Symmetric houses must have different colors
                dp[c0][c1] = cost[0][c0] + cost[n-1][c1]
    
    # Process remaining symmetric pairs
    for i in range(1, n//2):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c0 in range(3):
            for prev_c1 in range(3):
                if dp[prev_c0][prev_c1] == float('inf'):
                    continue
                
                # Current symmetric pair: (i, n-1-i)
                for curr_c0 in range(3):
                    for curr_c1 in range(3):
                        # Check constraints:
                        # 1. Symmetric houses must have different colors
                        if curr_c0 == curr_c1:
                            continue
                        # 2. Adjacent to previous house i-1
                        if curr_c0 == prev_c0:
                            continue
                        # 3. Adjacent to previous house n-i (which is n-1-(i-1))
                        if curr_c1 == prev_c1:
                            continue
                        
                        total_cost = dp[prev_c0][prev_c1] + cost[i][curr_c0] + cost[n-1-i][curr_c1]
                        if total_cost < new_dp[curr_c0][curr_c1]:
                            new_dp[curr_c0][curr_c1] = total_cost
        
        dp = new_dp
    
    # Find minimum cost from all valid final states
    min_possible_cost = float('inf')
    for c0 in range(3):
        for c1 in range(3):
            min_possible_cost = min(min_possible_cost, dp[c0][c1])
    
    # Check if the given value matches the minimum possible cost
    return min_possible_cost == minimum_cost_symmetric_painting
