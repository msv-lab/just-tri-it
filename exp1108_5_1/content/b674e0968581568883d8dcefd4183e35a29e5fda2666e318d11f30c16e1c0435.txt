# signature: def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool
from typing import List
import heapq

def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool:
    # Validate inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute prefix sums for efficient range sum calculation
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Precompute squared prefix sums for variance calculation
    prefix_sq = [0] * (n + 1)
    for i in range(n):
        prefix_sq[i + 1] = prefix_sq[i] + nums[i] * nums[i]
    
    def get_range_sum(l, r):
        """Get sum of elements from index l to r-1"""
        return prefix[r] - prefix[l]
    
    def get_range_sq_sum(l, r):
        """Get sum of squares of elements from index l to r-1"""
        return prefix_sq[r] - prefix_sq[l]
    
    def cost_for_subarray(start, target):
        """Calculate cost to make subarray [start, start+x) equal to target"""
        current_sum = get_range_sum(start, start + x)
        current_sq_sum = get_range_sq_sum(start, start + x)
        
        # Cost = sum((nums[i] - target)^2) but we need absolute differences
        # We can use: sum(|nums[i] - target|) = sum(|nums[i] - mean|) when target = mean
        # But for arbitrary target, we can compute directly
        # cost = sum(|nums[i] - target|) for i in [start, start+x)
        
        # More efficient calculation using mathematical identity:
        # sum(|a_i - m|) is minimized when m is median, but we need exact calculation
        # We'll compute directly
        total_cost = 0
        for i in range(start, start + x):
            total_cost += abs(nums[i] - target)
        return total_cost
    
    def min_cost_for_subarray(start):
        """Find minimum cost and optimal target for subarray starting at start"""
        # The optimal target is the median for absolute differences
        sub = nums[start:start + x]
        sub_sorted = sorted(sub)
        
        # For odd length, median is middle element
        # For even length, median can be either of the two middle elements
        median = sub_sorted[x // 2]
        
        # Calculate cost for median
        cost_median = 0
        for num in sub:
            cost_median += abs(num - median)
        
        # Also check nearby values in case of ties or better solutions
        candidates = [median]
        if x % 2 == 0:
            candidates.append(sub_sorted[x // 2 - 1])
        
        # Check a small range around median to be safe
        for offset in [-1, 1]:
            candidate = median + offset
            cost_candidate = 0
            for num in sub:
                cost_candidate += abs(num - candidate)
            if cost_candidate < cost_median:
                cost_median = cost_candidate
        
        return cost_median
    
    # Precompute costs for all possible subarrays
    subarray_costs = []
    for i in range(n - x + 1):
        cost = min_cost_for_subarray(i)
        subarray_costs.append((cost, i))
    
    # We need to select k non-overlapping subarrays with minimum total cost
    # This is a classic dynamic programming problem
    
    # Sort subarrays by cost
    subarray_costs.sort()
    
    # Use DP with state: dp[i][mask] = minimum cost using subarrays ending at or before position i
    # But with constraints, we can use a greedy approach with priority queue
    
    # Alternative approach: try the k best non-overlapping subarrays
    best_subarrays = []
    
    # We'll use a greedy selection with backtracking for k <= 15
    selected = []
    
    def backtrack(idx, count, current_cost, last_end):
        if count == k:
            return current_cost
        if idx >= len(subarray_costs):
            return float('inf')
        
        cost, start = subarray_costs[idx]
        end = start + x
        
        # Skip if overlaps with previously selected
        if start < last_end:
            return backtrack(idx + 1, count, current_cost, last_end)
        
        # Option 1: take current subarray
        take = backtrack(idx + 1, count + 1, current_cost + cost, end)
        
        # Option 2: skip current subarray
        skip = backtrack(idx + 1, count, current_cost, last_end)
        
        return min(take, skip)
    
    # For efficiency with larger inputs, we'll use a different approach
    # Sort subarrays by start position and use DP
    subarrays_by_start = [(i, min_cost_for_subarray(i)) for i in range(n - x + 1)]
    subarrays_by_start.sort()
    
    # DP[i][j] = min cost to select j subarrays from first i subarrays
    # But this would be O(n^2) which is too slow for n=10^5
    
    # Instead, use a greedy approach with priority queue for k small
    # We'll find the k best non-overlapping subarrays
    
    # Create a graph where nodes are subarrays and edges connect non-overlapping subarrays
    # Then find the shortest path of length k
    
    # For the scope of this problem, we'll use a simplified approach:
    # Try to find k non-overlapping subarrays with minimum total cost
    
    # Use a priority queue approach
    heap = []
    for i in range(n - x + 1):
        heapq.heappush(heap, (subarray_costs[i][0], i, subarray_costs[i][1]))
    
    selected_subarrays = []
    total_min_cost = 0
    
    while len(selected_subarrays) < k and heap:
        cost, idx, start = heapq.heappop(heap)
        end = start + x
        
        # Check if this subarray overlaps with any selected subarray
        valid = True
        for sel_start, sel_end in selected_subarrays:
            if not (end <= sel_start or start >= sel_end):
                valid = False
                break
        
        if valid:
            selected_subarrays.append((start, end))
            total_min_cost += cost
    
    # If we couldn't find k non-overlapping subarrays, try a more exhaustive search
    if len(selected_subarrays) < k:
        # Use the backtracking approach for smaller k
        subarray_costs_sorted = sorted(subarray_costs, key=lambda x: x[0])
        min_required = backtrack(0, 0, 0, -1)
    else:
        min_required = total_min_cost
    
    # The given value is valid if it's >= the minimum required cost
    return min_operations_for_k_equal_subarrays >= min_required
