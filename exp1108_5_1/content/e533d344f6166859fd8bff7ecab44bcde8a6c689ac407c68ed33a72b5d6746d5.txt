# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Validate input constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if not (0 <= cost[i][j] <= 100000):
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Function to check if a coloring is valid
    def is_valid_coloring(coloring):
        # Check adjacent houses don't have same color
        for i in range(n - 1):
            if coloring[i] == coloring[i + 1]:
                return False
        
        # Check symmetric houses don't have same color
        for i in range(n // 2):
            if coloring[i] == coloring[n - 1 - i]:
                return False
        
        return True
    
    # Function to calculate cost of a coloring
    def calculate_cost(coloring):
        total = 0
        for i in range(n):
            total += cost[i][coloring[i]]
        return total
    
    # Try all possible color combinations for symmetric pairs
    # Since n is even, we only need to check n/2 pairs
    # Each pair (i, n-1-i) must have different colors from each other
    # and from their adjacent houses
    
    # We'll use dynamic programming to find the actual minimum cost
    # and compare it with the given value
    
    # DP approach: process symmetric pairs
    # dp[i][c1][c2] = minimum cost for first i pairs where
    # the i-th house from left has color c1 and i-th house from right has color c2
    
    # Initialize DP table
    INF = float('inf')
    dp = [[[INF for _ in range(3)] for _ in range(3)] for _ in range(n // 2 + 1)]
    
    # Base case: 0 pairs processed
    dp[0][0][0] = dp[0][0][1] = dp[0][0][2] = 0
    dp[0][1][0] = dp[0][1][1] = dp[0][1][2] = 0
    dp[0][2][0] = dp[0][2][1] = dp[0][2][2] = 0
    
    # Process each symmetric pair
    for i in range(1, n // 2 + 1):
        left_idx = i - 1
        right_idx = n - i
        
        for left_color in range(3):
            for right_color in range(3):
                # Colors must be different for symmetric houses
                if left_color == right_color:
                    continue
                
                # Try all possible previous colors
                for prev_left_color in range(3):
                    for prev_right_color in range(3):
                        # Check constraints for previous pair
                        if i > 1:
                            # Left house shouldn't match its left neighbor
                            if left_color == prev_left_color:
                                continue
                            # Right house shouldn't match its right neighbor  
                            if right_color == prev_right_color:
                                continue
                        
                        current_cost = cost[left_idx][left_color] + cost[right_idx][right_color]
                        
                        if i == n // 2:
                            # Last pair - also check they're not adjacent to each other
                            if left_idx + 1 == right_idx and left_color == right_color:
                                continue
                        
                        dp[i][left_color][right_color] = min(
                            dp[i][left_color][right_color],
                            dp[i-1][prev_left_color][prev_right_color] + current_cost
                        )
    
    # Find the minimum cost from all valid final states
    actual_min_cost = INF
    for left_color in range(3):
        for right_color in range(3):
            actual_min_cost = min(actual_min_cost, dp[n // 2][left_color][right_color])
    
    # Check if the given value matches the actual minimum cost
    return abs(actual_min_cost - minimum_cost_symmetric_painting) < 1e-9
