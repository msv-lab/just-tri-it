# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also, adjacent houses cannot have the same color
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs where the i-th pair has colors c1 and c2
    # But with n up to 10^5, we need a more efficient approach
    
    # Instead, we can process pairs independently and combine results
    # For each symmetric pair (i, n-1-i), we need to assign different colors to both houses
    # and the colors must be different from adjacent pairs
    
    # Initialize DP for the first pair
    # For the first pair (0, n-1), we try all valid color combinations
    min_cost = 0
    
    # We'll process each symmetric pair and maintain the best two color combinations
    # for the current pair that can be extended to the next pair
    
    # For each pair, we need to consider that:
    # 1. The two houses in the pair must have different colors
    # 2. The current pair's colors must be different from the previous pair's colors
    
    # Initialize with the first pair
    pair_count = n // 2
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # Initialize first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Two houses in the same pair must have different colors
                dp[c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, pair_count):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[prev_c1][prev_c2] == float('inf'):
                    continue
                
                # Try all color combinations for current pair
                for curr_c1 in range(3):
                    for curr_c2 in range(3):
                        # Check constraints:
                        # 1. Current pair houses must have different colors
                        # 2. Current left house color != previous left house color (adjacent constraint)
                        # 3. Current right house color != previous right house color (adjacent constraint)
                        if (curr_c1 != curr_c2 and 
                            curr_c1 != prev_c1 and 
                            curr_c2 != prev_c2):
                            
                            current_cost = cost[i][curr_c1] + cost[n-1-i][curr_c2]
                            new_dp[curr_c1][curr_c2] = min(new_dp[curr_c1][curr_c2], 
                                                          dp[prev_c1][prev_c2] + current_cost)
        
        dp = new_dp
    
    # Find minimum cost from all valid color combinations for the last pair
    result = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            result = min(result, dp[c1][c2])
    
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    # Add 1 to the final answer as requested
    return result + 1
