# signature: def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]
from typing import List
from collections import defaultdict, deque

def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]:
    n = len(nums)
    if n < 2:
        raise ValueError("Invalid input")
    
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length <= 0:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Build tree structure with parent-child relationships (root at 0)
    parent = [-1] * n
    children = defaultdict(list)
    edge_length = defaultdict(dict)
    
    # Store edge lengths
    for u, v, length in edges:
        edge_length[u][v] = length
        edge_length[v][u] = length
    
    # BFS to build tree structure
    visited = [False] * n
    queue = deque([0])
    visited[0] = True
    
    while queue:
        node = queue.popleft()
        for neighbor, length in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                children[node].append((neighbor, length))
                queue.append(neighbor)
    
    # Result: [max_length, min_nodes_for_max_length]
    result = [0, 1]  # At least the node itself has length 0 with 1 node
    
    def dfs(node):
        nonlocal result
        
        # For each child, we'll maintain paths ending at that child
        # We need to track: (path_length, node_count, value_set)
        
        # Base case: single node path
        single_paths = [(0, 1, {nums[node]})]  # (length, node_count, values)
        
        for child, length in children[node]:
            child_paths = dfs(child)
            
            # Try to extend paths from child to current node
            for path_len, node_cnt, values in child_paths:
                if nums[node] not in values:
                    new_len = path_len + length
                    new_node_cnt = node_cnt + 1
                    new_values = values | {nums[node]}
                    
                    # Update global result
                    if new_len > result[0]:
                        result[0] = new_len
                        result[1] = new_node_cnt
                    elif new_len == result[0] and new_node_cnt < result[1]:
                        result[1] = new_node_cnt
                    
                    # Add to current node's paths
                    single_paths.append((new_len, new_node_cnt, new_values))
        
        # Also consider paths that start and end at current node
        if 0 > result[0]:
            result[0] = 0
            result[1] = 1
        elif 0 == result[0] and 1 < result[1]:
            result[1] = 1
        
        # Merge paths from different children
        all_paths = single_paths.copy()
        
        # Try to combine paths from different children
        child_results = []
        for child, _ in children[node]:
            child_results.append(dfs(child))
        
        # For each pair of children, try to combine their paths through current node
        for i in range(len(child_results)):
            for path_len1, node_cnt1, values1 in child_results[i]:
                # Add current node to path1
                if nums[node] not in values1:
                    extended_len1 = path_len1
                    extended_cnt1 = node_cnt1 + 1
                    extended_vals1 = values1 | {nums[node]}
                    
                    # Try to combine with paths from other children
                    for j in range(i + 1, len(child_results)):
                        for path_len2, node_cnt2, values2 in child_results[j]:
                            if nums[node] not in values2:
                                # Check if all values are unique when combined
                                if not (extended_vals1 & values2):
                                    total_len = extended_len1 + path_len2
                                    total_nodes = extended_cnt1 + node_cnt2
                                    
                                    if total_len > result[0]:
                                        result[0] = total_len
                                        result[1] = total_nodes
                                    elif total_len == result[0] and total_nodes < result[1]:
                                        result[1] = total_nodes
        
        return single_paths
    
    dfs(0)
    return result
