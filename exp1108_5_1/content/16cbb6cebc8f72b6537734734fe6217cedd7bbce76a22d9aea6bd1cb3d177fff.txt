# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not nums or x <= 0 or k <= 0 or k * x > len(nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute the cost for making each possible subarray of length x have all elements equal
    # The optimal target value for a subarray is the median of its elements
    costs = []
    
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        sorted_sub = sorted(subarray)
        
        # Median for odd length, any of the two middle values for even length
        median = sorted_sub[x // 2]
        
        # Calculate cost to make all elements equal to median
        cost = 0
        for num in subarray:
            cost += abs(num - median)
        
        costs.append((cost, i))  # Store cost and starting index
    
    # We need to select k non-overlapping subarrays with minimum total cost
    # Subarrays are non-overlapping if their indices don't overlap: |i - j| >= x
    
    # Dynamic programming approach
    # dp[i][j] = minimum cost to select j subarrays from first i available subarrays
    
    m = len(costs)  # Number of possible subarrays
    
    # Initialize DP table
    dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        cost_i, idx_i = costs[i-1]
        
        # Copy previous row (not selecting current subarray)
        for j in range(k + 1):
            dp[i][j] = min(dp[i][j], dp[i-1][j])
        
        # Try to select current subarray
        for j in range(1, k + 1):
            # Find the last subarray that doesn't overlap with current one
            prev_idx = i - 1
            while prev_idx > 0:
                _, idx_prev = costs[prev_idx-1]
                if abs(idx_i - idx_prev) >= x:
                    dp[i][j] = min(dp[i][j], dp[prev_idx][j-1] + cost_i)
                    break
                prev_idx -= 1
            else:
                # If no previous non-overlapping subarray found, we can start a new sequence
                if j == 1:
                    dp[i][j] = min(dp[i][j], cost_i)
    
    # Find the minimum cost across all possibilities
    result = min(dp[i][k] for i in range(m + 1))
    
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    return int(result)
