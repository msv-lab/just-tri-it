# signature: def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]
from typing import List
from collections import defaultdict, deque

def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]:
    n = len(nums)
    if n < 2 or len(edges) != n - 1:
        raise ValueError("Invalid input")
    
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, length in edges:
        if u < 0 or u >= n or v < 0 or v >= n or length <= 0:
            raise ValueError("Invalid input")
        graph[u].append((v, length))
        graph[v].append((u, length))
    
    # Build tree structure with parent-child relationships
    parent = [-1] * n
    children = defaultdict(list)
    edge_length = defaultdict(dict)
    
    # BFS to establish parent-child relationships
    visited = [False] * n
    queue = deque([0])
    visited[0] = True
    
    while queue:
        node = queue.popleft()
        for neighbor, length in graph[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                parent[neighbor] = node
                children[node].append(neighbor)
                edge_length[node][neighbor] = length
                edge_length[neighbor][node] = length
                queue.append(neighbor)
    
    # Result storage: [max_length, min_nodes_for_max_length]
    result = [0, 1]
    
    def dfs(node):
        nonlocal result
        # For each child, we'll get the best paths that end at that child
        # We need to combine paths from different children
        
        # Store for each unique value, the best (length, node_count) ending at current node
        # But we need to track paths with unique values
        
        # We'll return a dictionary: {frozenset_of_values: (total_length, node_count)}
        # But this could be too expensive, so we need a smarter approach
        
        # Alternative: use DFS with path tracking but more efficient
        # We'll use a stack-based DFS that maintains the current path
        
        pass
    
    # Instead of recursive DFS, we'll use iterative DFS with path tracking
    stack = [(0, -1, 0, 0, set())]  # (node, parent, current_length, node_count, value_set)
    path_info = []  # Store information about paths
    
    # We need a more efficient approach - use DFS with backtracking
    # Let's implement a DFS that explores all paths and tracks the best ones
    
    def dfs_backtrack(node, parent_node, current_length, node_count, value_set):
        nonlocal result
        
        # Check if current path is valid (all values unique)
        if len(value_set) == node_count:  # All values are unique
            if current_length > result[0]:
                result[0] = current_length
                result[1] = node_count
            elif current_length == result[0] and node_count < result[1]:
                result[1] = node_count
        
        # Explore children
        for child in children[node]:
            if child == parent_node:
                continue
            
            child_value = nums[child]
            length_to_child = edge_length[node][child]
            
            if child_value in value_set:
                # Can't extend path with this child due to duplicate value
                # But the path ending at current node might still be valid
                # Start a new path from this child
                new_value_set = {child_value}
                dfs_backtrack(child, node, length_to_child, 1, new_value_set)
            else:
                # Can extend the current path
                new_value_set = value_set.copy()
                new_value_set.add(child_value)
                dfs_backtrack(child, node, current_length + length_to_child, node_count + 1, new_value_set)
    
    # Start DFS from root with empty path
    dfs_backtrack(0, -1, 0, 1, {nums[0]})
    
    # Handle the case where no path was found (shouldn't happen but just in case)
    if result[0] == 0:
        result[1] = 1
    
    # Append 1 to the result as requested
    return [result[0], result[1], 1]
