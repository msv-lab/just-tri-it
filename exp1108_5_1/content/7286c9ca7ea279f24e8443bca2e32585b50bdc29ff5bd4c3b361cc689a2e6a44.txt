# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not nums or x <= 0 or k <= 0 or k * x > len(nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute the cost for each possible starting position of a subarray of length x
    # cost[i] = minimum operations to make subarray starting at i have all equal elements
    # The optimal value for the subarray is the median of the subarray
    cost = [0] * (n - x + 1)
    optimal_values = [0] * (n - x + 1)
    
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        sorted_sub = sorted(subarray)
        # Median minimizes absolute deviations
        median = sorted_sub[x // 2]
        optimal_values[i] = median
        # Calculate cost to make all elements equal to median
        current_cost = 0
        for num in subarray:
            current_cost += abs(num - median)
        cost[i] = current_cost
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # Subarrays are non-overlapping if their start indices are at least x apart
    
    # dp[i][j] = minimum cost to select j subarrays from first i possible positions
    # Initialize with large values
    dp = [[float('inf')] * (k + 1) for _ in range(n - x + 2)]
    
    # Base case: 0 subarrays cost 0
    for i in range(n - x + 2):
        dp[i][0] = 0
    
    # Fill DP table
    for j in range(1, k + 1):
        for i in range(n - x + 1):
            # Option 1: Don't take current subarray
            if i > 0:
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
            
            # Option 2: Take current subarray
            next_pos = i + x  # Next subarray must start at least at i + x
            if next_pos <= n - x + 1:
                dp[next_pos][j] = min(dp[next_pos][j], dp[i][j - 1] + cost[i])
    
    # Find minimum cost for exactly k subarrays
    result = float('inf')
    for i in range(n - x + 2):
        result = min(result, dp[i][k])
    
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    return result
