# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Validate input constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is achievable
    # We'll use dynamic programming to find the actual minimum cost
    
    # For symmetric constraint: houses at positions i and n-1-i cannot have same color
    # For adjacent constraint: adjacent houses cannot have same color
    
    # DP state: dp[i][c1][c2] = min cost for first i pairs where:
    # - house i has color c1
    # - house n-1-i has color c2
    # But this would be O(n * 9) which is too slow for n up to 10^5
    
    # Alternative approach: check if there exists a valid coloring with cost <= given value
    # But since we need to verify minimum, we need to find the actual minimum
    
    # Let's implement a more efficient DP that considers pairs of symmetric houses
    # dp[i][c1][c2] = min cost for first i symmetric pairs where:
    # - left house of pair i has color c1  
    # - right house of pair i has color c2
    
    # Initialize DP
    INF = float('inf')
    dp = [[[INF for _ in range(3)] for _ in range(3)] for _ in range(n//2 + 1)]
    
    # Base case: 0 pairs processed
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = 0
    
    # Process each symmetric pair
    for i in range(1, n//2 + 1):
        left_idx = i - 1
        right_idx = n - i
        
        for left_color in range(3):
            for right_color in range(3):
                if left_color == right_color:  # Symmetric constraint
                    continue
                
                # Try all possible colors for previous pair
                for prev_left in range(3):
                    for prev_right in range(3):
                        if prev_left == prev_right:  # Symmetric constraint for previous
                            continue
                        if prev_left == left_color:  # Adjacent constraint for left side
                            continue
                        if prev_right == right_color:  # Adjacent constraint for right side
                            continue
                        
                        current_cost = cost[left_idx][left_color] + cost[right_idx][right_color]
                        dp[i][left_color][right_color] = min(
                            dp[i][left_color][right_color],
                            dp[i-1][prev_left][prev_right] + current_cost
                        )
    
    # Find minimum cost among all valid final states
    actual_min_cost = INF
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                actual_min_cost = min(actual_min_cost, dp[n//2][c1][c2])
    
    # Special case for middle pair when n is even (already handled above)
    
    # Check if the given value matches the actual minimum cost
    return actual_min_cost == minimum_cost_symmetric_painting
