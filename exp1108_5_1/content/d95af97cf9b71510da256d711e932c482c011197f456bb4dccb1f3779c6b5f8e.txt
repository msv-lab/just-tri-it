# signature: def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]
from typing import List

def minCost_simp_split_0_inv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[int]]:
    if not cost_prefix:
        if minimum_beautiful_painting_cost != 0:
            raise ValueError("Invalid input")
        return [[]]
    
    n = len(cost_prefix) + 1
    if n % 2 != 0:
        raise ValueError("Invalid input")
    
    if len(cost_prefix) != n - 1:
        raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    # Precompute the minimum cost for the first n-1 houses
    # We need to track the minimum costs for different ending colors
    # considering both adjacency and symmetry constraints
    
    # For symmetric positions (i, n-2-i) in the prefix
    # We'll compute the minimum cost for assigning colors to these pairs
    
    # Initialize DP for the first half of houses
    half = n // 2
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # Initialize for the first symmetric pair (0, n-2)
    for c0 in range(3):
        for c1 in range(3):
            if c0 != c1:  # Adjacent constraint for positions 0 and 1
                cost = cost_prefix[0][c0] + cost_prefix[n-2][c1]
                dp[c0][c1] = cost
    
    # Process remaining symmetric pairs
    for i in range(1, half):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c0 in range(3):
            for prev_c1 in range(3):
                if dp[prev_c0][prev_c1] == float('inf'):
                    continue
                
                for curr_c0 in range(3):
                    for curr_c1 in range(3):
                        # Check constraints:
                        # 1. Adjacent houses can't have same color
                        if curr_c0 == prev_c0:  # Between i-1 and i
                            continue
                        if curr_c1 == prev_c1:  # Between n-2-i and n-1-i
                            continue
                        # 2. Symmetric houses can't have same color
                        if curr_c0 == curr_c1:  # Between i and n-1-i
                            continue
                        
                        cost = dp[prev_c0][prev_c1] + cost_prefix[i][curr_c0] + cost_prefix[n-2-i][curr_c1]
                        new_dp[curr_c0][curr_c1] = min(new_dp[curr_c0][curr_c1], cost)
        
        dp = new_dp
    
    # Now we need to add the last house (cost_suffix)
    # The last house has constraints with its adjacent house (n-2) and its symmetric house (0)
    min_cost_without_last = float('inf')
    for c0 in range(3):
        for c1 in range(3):
            min_cost_without_last = min(min_cost_without_last, dp[c0][c1])
    
    # Calculate required cost_suffix value
    required_suffix_cost = minimum_beautiful_painting_cost - min_cost_without_last
    
    # Find valid color for last house that satisfies constraints
    for last_color in range(3):
        valid = True
        # Check constraint with adjacent house (n-2)
        for c0 in range(3):
            for c1 in range(3):
                if dp[c0][c1] != float('inf'):
                    # Last house (n-1) is adjacent to house n-2 (color c1)
                    if last_color == c1:
                        valid = False
                        break
                    # Last house (n-1) is symmetric to house 0 (color c0)
                    if last_color == c0:
                        valid = False
                        break
            if not valid:
                break
        
        if valid:
            # Return cost_suffix that makes total cost equal to minimum_beautiful_painting_cost
            cost_suffix = [0, 0, 0]
            cost_suffix[last_color] = max(0, required_suffix_cost)
            return [cost_suffix]
    
    # If no valid color found, try to adjust the cost
    for last_color in range(3):
        cost_suffix = [0, 0, 0]
        cost_suffix[last_color] = max(0, required_suffix_cost)
        return [cost_suffix]
    
    # Fallback
    return [[0, 0, 0]]
