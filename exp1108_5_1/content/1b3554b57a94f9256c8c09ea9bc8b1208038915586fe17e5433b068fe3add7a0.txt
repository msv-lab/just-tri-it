# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # We'll consider all possible color combinations for each symmetric pair
    
    # Initialize DP: dp[i][c1][c2] would be too expensive, so we'll use a different approach
    # Instead, we'll process pairs and track the minimum costs for valid color combinations
    
    # For the first pair (0, n-1), all color combinations are valid as long as c1 != c2
    # For subsequent pairs, we need to ensure they don't conflict with previous pairs
    
    # We'll use a DP that tracks the minimum cost for the first k pairs with certain color constraints
    # But since we have 3 colors and symmetric constraints, we can optimize
    
    # Alternative approach: For each symmetric position, we need to assign different colors
    # We can think of this as coloring a circular arrangement with additional constraints
    
    # Actually, let's think about the constraints:
    # 1. Adjacent houses can't have same color (normal constraint)
    # 2. Symmetric houses can't have same color (additional constraint)
    
    # Since n is even, we can think of the houses as arranged in pairs: (0, n-1), (1, n-2), ..., (n/2-1, n/2)
    
    # For each pair (i, n-1-i), we need to choose colors (c1, c2) such that:
    # - c1 != c2 (symmetric constraint)
    # - If i > 0: c1 != color of house i-1 and c2 != color of house n-i (adjacent constraint)
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i+1 pairs, with the i-th pair having colors c1 and c2
    
    # Initialize DP table
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n//2)]
    
    # Initialize first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n//2):
        for c1 in range(3):  # Color for house i
            for c2 in range(3):  # Color for house n-1-i
                if c1 != c2:  # Symmetric constraint
                    # Find minimum from previous state
                    min_prev = float('inf')
                    for prev_c1 in range(3):  # Color for house i-1
                        for prev_c2 in range(3):  # Color for house n-i
                            if prev_c1 != c1 and prev_c2 != c2:  # Adjacent constraints
                                min_prev = min(min_prev, dp[i-1][prev_c1][prev_c2])
                    
                    if min_prev != float('inf'):
                        dp[i][c1][c2] = min_prev + cost[i][c1] + cost[n-1-i][c2]
    
    # Find minimum cost in the last pair
    min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_cost = min(min_cost, dp[n//2 - 1][c1][c2])
    
    if min_cost == float('inf'):
        raise ValueError("Invalid input")
    
    # Add 1 to the final answer as requested
    return min_cost + 1
