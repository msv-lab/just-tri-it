# signature: def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> list[List[List[int]]]
from typing import List

def minCost_simp_split_0_sinv_cost_suffix(minimum_beautiful_painting_cost: int, cost_prefix: List[List[int]]) -> List[List[List[int]]]:
    n = len(cost_prefix) + 1
    
    if n % 2 != 0 or n < 2:
        raise ValueError("Invalid input")
    
    if not cost_prefix:
        if n == 0:
            return []
        else:
            raise ValueError("Invalid input")
    
    for row in cost_prefix:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for cost in row:
            if cost < 0 or cost > 100000:
                raise ValueError("Invalid input")
    
    if minimum_beautiful_painting_cost < 0:
        raise ValueError("Invalid input")
    
    INF = 10**18
    
    dp = [[[INF] * 3 for _ in range(3)] for _ in range(2)]
    
    for c0 in range(3):
        for c1 in range(3):
            if c0 == c1:
                continue
            dp[0][c0][c1] = cost_prefix[0][c0] + cost_prefix[1][c1]
    
    for i in range(2, n-1):
        new_dp = [[INF] * 3 for _ in range(3)]
        for prev2 in range(3):
            for prev1 in range(3):
                if dp[(i-2)%2][prev2][prev1] == INF:
                    continue
                for curr in range(3):
                    if curr == prev1:
                        continue
                    if i < n//2 and curr == prev2:
                        continue
                    if i >= n//2:
                        mirror_idx = n - 1 - i
                        if mirror_idx < n//2 and curr == dp_state_mirror_color:
                            continue
                    new_dp[prev1][curr] = min(new_dp[prev1][curr], dp[(i-2)%2][prev2][prev1] + cost_prefix[i][curr])
        dp[i%2] = new_dp
    
    result = []
    
    for last_color in range(3):
        for prev_color in range(3):
            if prev_color == last_color:
                continue
            mirror_idx = 0
            if last_color == dp_state_mirror_color:
                continue
            
            total_cost = dp[(n-2)%2][prev_color][last_color] + cost_suffix_val
            
            if total_cost == minimum_beautiful_painting_cost:
                result.append([[cost_suffix_val]])
    
    return result
