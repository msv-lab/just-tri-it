# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Check if minimum_cost_symmetric_painting is non-negative
    if minimum_cost_symmetric_painting < 0:
        return False
    
    # Dynamic programming approach to find actual minimum cost
    # We need to consider symmetry constraints
    
    # For symmetric pairs (i, n-1-i), they cannot have the same color
    # Also adjacent houses cannot have the same color
    
    # Precompute symmetric pairs
    symmetric_pairs = [(i, n-1-i) for i in range(n//2)]
    
    # Try all possible color combinations for the first symmetric pair
    # and propagate constraints
    
    # Initialize DP table for symmetric pairs
    # dp[i][c1][c2] = minimum cost for first i symmetric pairs where
    # the left house of pair i has color c1 and right house has color c2
    
    # Since we have 3 colors and n can be large, we need a more efficient approach
    # Let's use a state machine approach
    
    # For each symmetric pair (i, j), we need to choose colors such that:
    # 1. color_i != color_j (symmetric constraint)
    # 2. color_i != color_{i-1} (adjacent constraint for left side)
    # 3. color_j != color_{j+1} (adjacent constraint for right side)
    
    # We can process houses from left to right, keeping track of the last two colors
    # on both sides
    
    # Alternative approach: use DP with state tracking last two colors on each side
    INF = float('inf')
    
    # Try all possible starting colors for first and last house
    min_actual_cost = INF
    
    # For small n, we can try all possibilities, but for large n we need a smarter approach
    # Since n can be up to 10^5, we need an efficient DP
    
    # Let's implement a proper DP that respects all constraints
    dp = [[[INF for _ in range(3)] for _ in range(3)] for _ in range(n//2 + 1)]
    
    # Initialize for the first symmetric pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[1][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Fill DP table for remaining symmetric pairs
    for k in range(2, n//2 + 1):
        i = k - 1  # left index
        j = n - k  # right index
        
        for prev_c1 in range(3):  # previous left color
            for prev_c2 in range(3):  # previous right color
                if dp[k-1][prev_c1][prev_c2] == INF:
                    continue
                
                for curr_c1 in range(3):  # current left color
                    for curr_c2 in range(3):  # current right color
                        # Check constraints:
                        # 1. Adjacent constraint for left: curr_c1 != prev_c1
                        # 2. Adjacent constraint for right: curr_c2 != prev_c2  
                        # 3. Symmetric constraint: curr_c1 != curr_c2
                        if (curr_c1 != prev_c1 and curr_c2 != prev_c2 and 
                            curr_c1 != curr_c2):
                            new_cost = dp[k-1][prev_c1][prev_c2] + cost[i][curr_c1] + cost[j][curr_c2]
                            if new_cost < dp[k][curr_c1][curr_c2]:
                                dp[k][curr_c1][curr_c2] = new_cost
    
    # Find minimum cost from all valid final states
    for c1 in range(3):
        for c2 in range(3):
            if dp[n//2][c1][c2] < min_actual_cost:
                min_actual_cost = dp[n//2][c1][c2]
    
    # Check if the given value matches the computed minimum
    return abs(min_actual_cost - minimum_cost_symmetric_painting) < 1e-9
