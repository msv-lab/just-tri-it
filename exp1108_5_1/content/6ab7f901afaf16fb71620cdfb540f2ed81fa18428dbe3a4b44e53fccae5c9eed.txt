# signature: def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool
from typing import List

def postcondition(cost: List[List[int]], minimum_cost_symmetric_painting: int) -> bool:
    n = len(cost)
    
    # Check constraints
    if n < 2 or n > 100000 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # Generate all possible valid color assignments for symmetric pairs
    def get_valid_color_pairs(color1, color2):
        valid_pairs = []
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:  # Adjacent constraint for symmetric pairs
                    valid_pairs.append((c1, c2))
        return valid_pairs
    
    # Dynamic programming to find actual minimum cost
    dp = [[float('inf')] * 3 for _ in range(n)]
    
    # Initialize first half
    for color in range(3):
        dp[0][color] = cost[0][color]
    
    # Fill DP table for first half
    for i in range(1, n // 2):
        for color in range(3):
            for prev_color in range(3):
                if prev_color != color:
                    dp[i][color] = min(dp[i][color], dp[i-1][prev_color] + cost[i][color])
    
    # Now consider symmetric constraints for the second half
    dp2 = [[float('inf')] * 3 for _ in range(n // 2)]
    
    # For each symmetric pair (i, n-1-i), find valid color combinations
    actual_min_cost = float('inf')
    
    for left_color in range(3):
        for right_color in range(3):
            if left_color != right_color:  # Symmetric constraint
                # Calculate cost for this symmetric pair configuration
                pair_cost = dp[n//2 - 1][left_color] + cost[n-1][right_color]
                
                # Add costs for remaining symmetric pairs
                for pair_idx in range(1, n // 2):
                    left_idx = pair_idx
                    right_idx = n - 1 - pair_idx
                    
                    min_pair_cost = float('inf')
                    for left_c in range(3):
                        for right_c in range(3):
                            if left_c != right_c:  # Symmetric constraint
                                # Check adjacent constraint with previous houses
                                if left_c != left_color and right_c != right_color:
                                    pair_cost_candidate = cost[left_idx][left_c] + cost[right_idx][right_c]
                                    min_pair_cost = min(min_pair_cost, pair_cost_candidate)
                    
                    pair_cost += min_pair_cost
                
                actual_min_cost = min(actual_min_cost, pair_cost)
    
    # Check if the given value matches the actual minimum cost
    return minimum_cost_symmetric_painting == actual_min_cost
