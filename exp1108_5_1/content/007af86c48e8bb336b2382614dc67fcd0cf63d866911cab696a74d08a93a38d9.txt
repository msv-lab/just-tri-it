# signature: def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int
MOD = 998244353

def count_distinct_in_degree_sequences(modulus: int, num_vertices: int, binary_string: str) -> int:
    MOD = modulus
    N = num_vertices
    
    # Validate inputs
    if N < 3:
        raise ValueError("Invalid input")
    if len(binary_string) != N:
        raise ValueError("Invalid input")
    if not all(c in '01' for c in binary_string):
        raise ValueError("Invalid input")
    
    # Count number of '1's in the string
    k = binary_string.count('1')
    
    # Precompute factorials and inverse factorials
    fact = [1] * (N + 5)
    inv_fact = [1] * (N + 5)
    
    for i in range(1, len(fact)):
        fact[i] = fact[i-1] * i % MOD
    
    # Fermat's little theorem for inverse factorial
    inv_fact[len(fact)-1] = pow(fact[len(fact)-1], MOD-2, MOD)
    for i in range(len(fact)-2, -1, -1):
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD
    
    def comb(n, r):
        if r < 0 or r > n:
            return 0
        return fact[n] * inv_fact[r] % MOD * inv_fact[n-r] % MOD
    
    # The main combinatorial formula
    # For the cycle part: we need to count the number of ways to assign directions to cycle edges
    # such that the in-degree differences between consecutive vertices are constrained
    # For the star edges: each edge can independently contribute to either endpoint's in-degree
    
    result = 0
    
    # Iterate over possible total in-degree from cycle edges for vertex N
    for x in range(k + 1):
        # The number of ways to choose which star edges contribute to vertex N's in-degree
        ways_star = comb(k, x)
        
        # For the cycle, we need to count the number of valid in-degree sequences
        # This is equivalent to counting the number of ways to assign directions to cycle edges
        # such that the differences between consecutive vertices' in-degrees are constrained
        
        # Using generating functions and inclusion-exclusion
        cycle_ways = 0
        for t in range(N + 1):
            sign = 1 if t % 2 == 0 else -1
            term = comb(N, t) * comb(N + (N - k - x) - t * 2 - 1, N - 1) % MOD
            cycle_ways = (cycle_ways + sign * term) % MOD
        
        result = (result + ways_star * cycle_ways) % MOD
    
    return result
