# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not all(-10**6 <= num <= 10**6 for num in nums):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # Collect all possible x-length subarrays' indices and their median
    subarrays = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        subarrays.append((i, i+x-1, subarray))
    
    # For each subarray, compute the cost to make all elements equal to the median (or optimal value)
    # The optimal target is the median to minimize the operations
    costs = []
    for start, end, sub in subarrays:
        sorted_sub = sorted(sub)
        median = sorted_sub[x // 2]
        cost = sum(abs(num - median) for num in sub)
        costs.append((cost, start, end, median))
    
    # We need to select k non-overlapping subarrays with minimal total cost
    # This is a classic interval scheduling problem with the goal of minimal total cost
    # We can use dynamic programming or greedy approach, but given k is small (<=15), we can use a priority queue approach
    
    # Sort the subarrays by their end index
    costs.sort(key=lambda item: item[2])
    
    # Initialize DP: dp[i][j] represents the minimal cost to select j non-overlapping subarrays up to i-th subarray
    m = len(costs)
    # We'll use a list of dictionaries to keep track of minimal costs for each count of subarrays
    dp = [{} for _ in range(m)]
    
    for i in range(m):
        cost_i, start_i, end_i, median_i = costs[i]
        # For selecting 1 subarray, it's just the current cost
        dp[i][1] = cost_i
        # Check previous subarrays that don't overlap with the current one
        for j in range(i):
            cost_j, start_j, end_j, median_j = costs[j]
            if end_j < start_i:
                for count in dp[j]:
                    new_count = count + 1
                    new_cost = dp[j][count] + cost_i
                    if new_count in dp[i]:
                        if new_cost < dp[i][new_count]:
                            dp[i][new_count] = new_cost
                    else:
                        dp[i][new_count] = new_cost
    
    # Now, find the minimal cost across all subarrays that have at least k counts
    min_total = float('inf')
    for i in range(m):
        if k in dp[i]:
            if dp[i][k] < min_total:
                min_total = dp[i][k]
    
    if min_total == float('inf'):
        raise ValueError("Invalid input")
    
    return min_total
