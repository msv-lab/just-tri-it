# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if c < 0 or c > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses cannot have same color
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i symmetric pairs, with the first house of the pair having color c1
    # and the symmetric house having color c2
    
    # Since n can be up to 10^5, we need an efficient approach
    # We'll process pairs and track the best costs for different color combinations
    
    # Initialize DP for the first pair
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(n//2)]
    
    # Fill first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric houses must have different colors
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n//2):
        for c1 in range(3):  # Color for house i
            for c2 in range(3):  # Color for symmetric house n-1-i
                if c1 == c2:  # Symmetric houses cannot have same color
                    continue
                    
                # Find minimum from previous pair considering adjacent constraints
                min_prev = float('inf')
                for prev_c1 in range(3):  # Color for house i-1
                    for prev_c2 in range(3):  # Color for symmetric house n-i
                        if prev_c1 == c1:  # Adjacent houses cannot have same color
                            continue
                        if prev_c2 == c2:  # Adjacent symmetric houses cannot have same color
                            continue
                        min_prev = min(min_prev, dp[i-1][prev_c1][prev_c2])
                
                if min_prev != float('inf'):
                    dp[i][c1][c2] = min_prev + cost[i][c1] + cost[n-1-i][c2]
    
    # Find minimum cost for the last pair
    result = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            result = min(result, dp[n//2 - 1][c1][c2])
    
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    return result + 1
