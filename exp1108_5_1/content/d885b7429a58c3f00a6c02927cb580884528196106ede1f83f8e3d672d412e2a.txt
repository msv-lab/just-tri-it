# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n <= 0:
        raise ValueError("Invalid input")
    if len(cost) != n or any(len(c) != 3 for c in cost):
        raise ValueError("Invalid input")
    
    # Pair the houses that are equidistant from the ends
    pairs = [(i, n - 1 - i) for i in range(n // 2)]
    
    # Precompute the minimum and second minimum costs for each pair
    pair_info = []
    for a, b in pairs:
        # For each possible color combination (a_color, b_color) where a_color != b_color
        # Compute the total cost for the pair (a, b)
        min_cost = float('inf')
        for a_color in range(3):
            for b_color in range(3):
                if a_color != b_color:
                    total = cost[a][a_color] + cost[b][b_color]
                    if total < min_cost:
                        min_cost = total
        pair_info.append(min_cost)
    
    # Now, we need to ensure that adjacent pairs (i.e., consecutive pairs in the list) have different colors
    # But since the pairs are independent in terms of adjacency (except within the pair), we can sum all the minimal pair costs
    # However, adjacent pairs in the original list might share a house, but in the pairing approach, adjacent pairs are non-overlapping
    # So, the minimal total cost is the sum of the minimal costs for each pair
    
    return sum(pair_info)
