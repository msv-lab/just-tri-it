# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n <= 0 or n % 2 != 0:
        raise ValueError("Invalid input")
    
    if len(cost) != n or any(len(row) != 3 for row in cost):
        raise ValueError("Invalid input")
    
    if any(any(c < 0 for c in row) for row in cost):
        raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses must have different colors
    
    # dp[i][c1][c2] = min cost for first i pairs where the i-th pair has colors c1 and c2
    # But this would be O(n * 9) which is too slow for n up to 10^5
    
    # Let's use a more efficient approach:
    # For each symmetric pair (i, n-1-i), we need to choose two different colors
    # And consecutive pairs must satisfy that the right color of previous pair != left color of current pair
    
    # We can use dynamic programming where dp[i][c] = min cost for first i pairs where
    # the right house of i-th pair has color c
    
    # But wait, we need to track both colors for each pair
    
    # Alternative approach: treat it as coloring a circular arrangement with constraints
    # Since n is even, we have n/2 pairs of symmetric houses
    
    pairs = n // 2
    
    # For each pair, precompute the cost for all valid color combinations
    pair_costs = []
    for i in range(pairs):
        j = n - 1 - i
        
        # For this pair, we need two different colors
        costs_for_pair = []
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:  # Houses in symmetric positions must have different colors
                    total_cost = cost[i][c1] + cost[j][c2]
                    costs_for_pair.append((c1, c2, total_cost))
        pair_costs.append(costs_for_pair)
    
    # Dynamic programming: dp[i][c] = min cost for first i pairs where the right color of i-th pair is c
    # But we need to track both colors to ensure adjacent constraint
    
    # Let's track the minimum cost for each possible color configuration of the current pair
    # Initialize for the first pair
    dp = {}
    for c1, c2, total in pair_costs[0]:
        dp[(c1, c2)] = total
    
    # Process remaining pairs
    for idx in range(1, pairs):
        new_dp = {}
        current_costs = pair_costs[idx]
        
        for prev_c1, prev_c2 in dp:
            for curr_c1, curr_c2, curr_cost in current_costs:
                # Check constraints:
                # 1. The right color of previous pair (prev_c2) must be different from left color of current pair (curr_c1)
                #    because these houses are adjacent
                if prev_c2 == curr_c1:
                    continue
                
                # 2. If this is the middle pair (when n is even), no additional constraint needed
                
                new_cost = dp[(prev_c1, prev_c2)] + curr_cost
                new_key = (curr_c1, curr_c2)
                
                if new_key not in new_dp or new_cost < new_dp[new_key]:
                    new_dp[new_key] = new_cost
        
        dp = new_dp
    
    # Find the minimum cost among all valid configurations
    if not dp:
        raise ValueError("No valid coloring found")
    
    return min(dp.values())
