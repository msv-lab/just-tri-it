# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Validate inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    if any(not (-10**6 <= num <= 10**6) for num in nums):
        raise ValueError("Invalid input")

    n = len(nums)
    # Collect all possible subarrays of size x
    subarrays = []
    for i in range(n - x + 1):
        subarray = nums[i:i+x]
        subarrays.append((i, subarray))

    # For each subarray, compute the cost to make all elements equal to the median (min cost)
    # and store the cost and the target value (median)
    sub_costs = []
    for i, sub in subarrays:
        sorted_sub = sorted(sub)
        median = sorted_sub[x // 2]
        cost = sum(abs(num - median) for num in sub)
        sub_costs.append((cost, median, i))

    # We need to select k non-overlapping subarrays with minimal total cost
    # This is a classic interval scheduling problem with weights, which can be solved with dynamic programming
    # However, given k is small (<=15), we can use a greedy approach with priority queues

    # Sort the subarrays by their starting index
    sub_costs.sort(key=lambda sc: sc[2])

    # We'll use a priority queue to keep track of the best k non-overlapping subarrays
    # Initialize a list to keep track of the best costs for up to k subarrays
    # This is a dynamic programming approach where dp[i] represents the minimal cost to select i non-overlapping subarrays
    dp = [float('inf')] * (k + 1)
    dp[0] = 0

    # We'll process the subarrays in order and update the dp array
    # We need to keep track of the last end index for each possible count of subarrays
    # To optimize, we can keep a list of (last_end, cost) pairs for each possible count
    # Since k is small, this is feasible

    # Initialize a list to keep track of possible (last_end, cost) for each count
    # We start with count 0, last_end -infinity, cost 0
    candidates = [ [ (-float('inf'), 0) ] for _ in range(k + 1) ]

    for cost, median, start in sub_costs:
        end = start + x - 1
        # For each possible count from k down to 1
        for count in range(k, 0, -1):
            # Find the largest last_end in candidates[count-1] that is < start
            left = 0
            right = len(candidates[count - 1]) - 1
            best_index = -1
            while left <= right:
                mid = (left + right) // 2
                if candidates[count - 1][mid][0] < start:
                    best_index = mid
                    left = mid + 1
                else:
                    right = mid - 1
            if best_index != -1:
                new_cost = candidates[count - 1][best_index][1] + cost
                # Check if this new_cost is better than the current dp[count]
                if new_cost < dp[count]:
                    dp[count] = new_cost
                    # Add to candidates[count]
                    # But first, check if the new last_end is larger than the last one in candidates[count]
                    if candidates[count] and candidates[count][-1][0] == end:
                        if new_cost < candidates[count][-1][1]:
                            candidates[count].pop()
                            candidates[count].append( (end, new_cost) )
                    else:
                        candidates[count].append( (end, new_cost) )
    
    if dp[k] == float('inf'):
        raise ValueError("Invalid input")
    return dp[k]
