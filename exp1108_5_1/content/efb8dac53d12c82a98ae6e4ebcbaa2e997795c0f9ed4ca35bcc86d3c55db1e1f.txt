# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Check for invalid inputs
    if not (2 <= len(nums) <= 10**5):
        raise ValueError("Invalid input")
    if not (2 <= x <= len(nums)):
        raise ValueError("Invalid input")
    if not (1 <= k <= 15):
        raise ValueError("Invalid input")
    if not (2 <= k * x <= len(nums)):
        raise ValueError("Invalid input")
    if any(not (-10**6 <= num <= 10**6) for num in nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    # The possible starting indices for subarrays of size x are 0 to n - x
    # For each possible subarray, calculate the cost to make all elements equal to the median
    # The median minimizes the absolute deviations
    
    # Precompute the cost for each possible subarray
    subarray_costs = []
    # We'll use a sliding window approach with a max-heap and min-heap to compute the median
    # But for large x, a more efficient method is needed
    
    # Since x can be large, we need an efficient way to compute the median and the sum of absolute differences
    # Using two heaps (max-heap for lower half, min-heap for upper half) and maintaining the sum
    
    # For each possible subarray starting at i (0 <= i <= n - x)
    for i in range(n - x + 1):
        sub = nums[i:i+x]
        sub_sorted = sorted(sub)
        median = sub_sorted[x // 2] if x % 2 == 1 else sub_sorted[x // 2 - 1]
        # The optimal target is the median to minimize the sum of absolute differences
        cost = sum(abs(num - median) for num in sub)
        subarray_costs.append((cost, i))
    
    # Now, we need to select k non-overlapping subarrays with minimal total cost
    # The subarrays cannot overlap, i.e., for two subarrays starting at i and j with size x,
    # the intervals [i, i+x-1] and [j, j+x-1] must not overlap
    
    # This is a classic interval selection problem with the goal of minimizing total cost
    # We can use dynamic programming to solve it
    
    # dp[i][j] represents the minimal cost to select j non-overlapping subarrays from the first i subarrays
    # Initialize dp with infinity
    m = len(subarray_costs)
    dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        current_cost, current_start = subarray_costs[i-1]
        current_end = current_start + x - 1
        # Option 1: do not take the i-th subarray
        for j in range(k + 1):
            dp[i][j] = dp[i-1][j]
        # Option 2: take the i-th subarray, then we cannot take any subarray that overlaps with it
        # Find the largest p < i such that the p-th subarray does not overlap with the i-th subarray
        left = 0
        right = i - 1
        best_p = -1
        # Binary search to find the rightmost subarray before i that doesn't overlap
        # The subarrays are in order of their starting indices
        # So we can binary search based on their starting indices
        low = 0
        high = i - 2
        best_p = 0
        while low <= high:
            mid = (low + high) // 2
            p_start = subarray_costs[mid][1]
            p_end = p_start + x - 1
            if p_end < current_start:
                best_p = mid + 1
                low = mid + 1
            else:
                high = mid - 1
        best_p = high
        # Now, for all j >= 1, dp[i][j] = min(dp[i][j], dp[best_p + 1][j - 1] + current_cost)
        for j in range(1, k + 1):
            if best_p >= 0:
                prev_p = best_p
                candidate = dp[prev_p + 1][j - 1] + current_cost
            else:
                if j == 1:
                    candidate = current_cost
                else:
                    candidate = float('inf')
            if candidate < dp[i][j]:
                dp[i][j] = candidate
    
    result = dp[m][k]
    if result == float('inf'):
        raise ValueError("Invalid input")
    return result
