# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric constraint: houses at distance i and n-1-i must have different colors
    # We need to assign colors to all houses such that:
    # 1. Adjacent houses have different colors
    # 2. Houses at symmetric positions (i and n-1-i) have different colors
    
    # Since n is even, we can think of the houses as forming pairs (i, n-1-i)
    # and also satisfying adjacent constraints
    
    # Dynamic programming approach considering the constraints
    # We'll process pairs of symmetric houses
    
    # Initialize DP: dp[i][c1][c2] = min cost for first i symmetric pairs where
    # the left house has color c1 and right house has color c2
    
    # But this would be O(n * 3^4) which is too slow for n=10^5
    
    # Alternative approach: Since we have only 3 colors and symmetric constraints,
    # we can use a more efficient DP that tracks states for pairs
    
    # Let's define dp[i][a][b] where:
    # - i is the pair index (0 <= i < n//2)
    # - a is color of left house in pair i
    # - b is color of right house in pair i
    
    # But we also need to ensure adjacent pairs have different colors
    
    # Actually, let's think differently: we have two independent chains
    # Chain 1: houses 0, 1, 2, ..., n-1 (adjacent constraint)
    # Chain 2: symmetric pairs (0, n-1), (1, n-2), ... must have different colors
    
    # This is equivalent to coloring a circular graph with additional constraints
    
    # Since the problem is complex, let's implement a working solution
    # that handles the constraints correctly
    
    # We'll use DP that considers the entire sequence
    # dp[i][c] = min cost for first i+1 houses ending with color c
    
    # But we need to handle symmetric constraints
    
    # Let's process the houses in pairs (i, n-1-i)
    half = n // 2
    
    # For the first half of houses, we need to track both the color of current house
    # and the color of its symmetric counterpart
    
    # Initialize DP for the first pair
    dp = [[[float('inf')] * 3 for _ in range(3)] for _ in range(half)]
    
    # First pair: houses 0 and n-1
    for c0 in range(3):
        for c_last in range(3):
            if c0 != c_last:  # Symmetric constraint
                dp[0][c0][c_last] = cost[0][c0] + cost[n-1][c_last]
    
    # Process remaining pairs
    for i in range(1, half):
        for c_prev in range(3):  # Color of house i-1
            for c_sym_prev in range(3):  # Color of symmetric house of i-1 (n-i)
                if dp[i-1][c_prev][c_sym_prev] == float('inf'):
                    continue
                
                # Current left house i, right house n-1-i
                for c_curr in range(3):  # Color of house i
                    if c_curr == c_prev:  # Adjacent constraint
                        continue
                    for c_sym_curr in range(3):  # Color of house n-1-i
                        if c_sym_curr == c_sym_prev:  # Adjacent constraint for symmetric side
                            continue
                        if c_curr == c_sym_curr and i == n-1-i:  # Same house case (shouldn't happen for even n)
                            continue
                        if c_curr != c_sym_curr:  # Symmetric constraint
                            new_cost = dp[i-1][c_prev][c_sym_prev] + cost[i][c_curr] + cost[n-1-i][c_sym_curr]
                            if new_cost < dp[i][c_curr][c_sym_curr]:
                                dp[i][c_curr][c_sym_curr] = new_cost
    
    # Find minimum cost in the last pair
    min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_cost = min(min_cost, dp[half-1][c1][c2])
    
    if min_cost == float('inf'):
        raise ValueError("Invalid input")
    
    return min_cost
