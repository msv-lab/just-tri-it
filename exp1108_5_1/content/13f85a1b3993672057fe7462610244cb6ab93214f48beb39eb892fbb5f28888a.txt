# signature: def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> list[int]
from typing import List
import math

def minOperations_sinv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> List[int]:
    # Input validation
    if not nums or len(nums) < 2:
        raise ValueError("Invalid input")
    if x < 2 or x > len(nums):
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    result = []
    
    # For each possible k (number of subarrays)
    for k in range(1, 16):  # k from 1 to 15
        # Check constraint: k * x <= n
        if k * x > n:
            continue
            
        # We need to find k non-overlapping subarrays of size x
        # The minimum operations = sum of operations to make each chosen subarray equal
        
        # Dynamic programming approach to find minimum operations
        # dp[i][j] = min operations to choose j subarrays from first i elements
        # But we need to optimize for large n (up to 10^5)
        
        # Precompute operations needed for each possible subarray
        # operations[i] = operations needed to make subarray starting at i of length x equal
        operations = []
        for i in range(n - x + 1):
            subarray = nums[i:i + x]
            # To make all elements equal with minimum operations, 
            # we should make them equal to the median
            sorted_sub = sorted(subarray)
            median = sorted_sub[x // 2]
            op_count = sum(abs(num - median) for num in subarray)
            operations.append(op_count)
        
        # Now we need to find k non-overlapping subarrays with minimum total operations
        # Subarrays are non-overlapping if their starting indices are at least x apart
        
        # Use dynamic programming: dp[i][j] = min operations using first i positions for j subarrays
        m = len(operations)
        INF = float('inf')
        
        # Initialize DP table
        dp = [[INF] * (k + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][0] = 0
        
        # Fill DP table
        for j in range(1, k + 1):
            for i in range(m):
                if dp[i][j - 1] != INF:
                    # Try starting a new subarray at position i
                    if i + x <= m:
                        dp[i + x][j] = min(dp[i + x][j], dp[i][j - 1] + operations[i])
                
                # Carry forward the minimum value
                if i > 0:
                    dp[i][j] = min(dp[i][j], dp[i - 1][j])
        
        # Find minimum operations for exactly k subarrays
        min_ops = INF
        for i in range(m + 1):
            min_ops = min(min_ops, dp[i][k])
        
        # Check if this k satisfies the condition
        if min_ops != INF and min_ops == min_operations_for_k_equal_subarrays:
            result.append(k)
    
    return result
