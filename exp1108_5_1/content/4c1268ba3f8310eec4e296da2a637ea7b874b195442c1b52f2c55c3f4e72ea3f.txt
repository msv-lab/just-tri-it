# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Input validation
    if not nums or x < 2 or k < 1 or k * x > len(nums) or x > len(nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute the cost for each possible starting position of a subarray
    # For a subarray starting at index i, we want to make all x elements equal
    # The optimal value to make them equal to is the median (for absolute differences)
    
    # We'll use sliding window to compute the cost for each possible subarray
    # Since we need k non-overlapping subarrays, this becomes a dynamic programming problem
    
    # Precompute cost for each possible subarray of length x
    costs = [0] * (n - x + 1)
    
    for i in range(n - x + 1):
        # Extract the subarray
        subarray = nums[i:i + x]
        # Sort to find median
        sorted_sub = sorted(subarray)
        median = sorted_sub[x // 2]
        # Calculate cost to make all elements equal to median
        cost = sum(abs(num - median) for num in subarray)
        costs[i] = cost
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # We can use dynamic programming: dp[i][j] = min cost using j subarrays ending at or before position i
    
    # Since k is small (<=15), we can use DP with state (position, count)
    # But we need to ensure subarrays don't overlap
    
    # Initialize DP table
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    
    for i in range(n + 1):
        for j in range(k + 1):
            if dp[i][j] == float('inf'):
                continue
                
            # Option 1: don't take any subarray starting at i
            if i < n:
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
            
            # Option 2: take a subarray starting at i (if possible)
            if j < k and i <= n - x:
                dp[i + x][j + 1] = min(dp[i + x][j + 1], dp[i][j] + costs[i])
    
    # Find the minimum cost for exactly k subarrays
    result = min(dp[i][k] for i in range(n + 1))
    
    if result == float('inf'):
        raise ValueError("Invalid input")
    
    return int(result)
