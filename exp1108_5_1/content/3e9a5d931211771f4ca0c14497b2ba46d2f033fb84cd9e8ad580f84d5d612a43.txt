# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if c < 0 or c > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses cannot have same color
    
    # Precompute the minimum cost for each symmetric pair considering constraints
    # There are 3 colors, so for each pair we have 3x3 possibilities where colors are different
    # and also different from adjacent pairs when applicable
    
    # We'll use dynamic programming where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs where the i-th pair has colors c1 and c2
    # But this would be O(n * 9) which is too slow for n=10^5
    
    # Alternative approach: Since we have only 3 colors, we can consider all valid colorings
    # for a pair of symmetric houses
    
    # Let's process pairs from left to right
    # For each pair (i, n-1-i), we need to choose colors (a, b) such that:
    # 1. a != b (for symmetric constraint)
    # 2. For adjacent pairs, the right color of current pair != left color of next pair
    
    # We can use DP where state is (color_left, color_right) for current pair
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # Initialize for first pair
    for a in range(3):
        for b in range(3):
            if a != b:  # Symmetric constraint
                dp[a][b] = cost[0][a] + cost[n-1][b]
    
    # Process remaining pairs
    for i in range(1, n//2):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_a in range(3):      # Left color of previous pair's left house
            for prev_b in range(3):  # Right color of previous pair's right house
                if dp[prev_a][prev_b] == float('inf'):
                    continue
                
                # For current pair (i, n-1-i)
                for curr_a in range(3):  # Color for house i
                    for curr_b in range(3):  # Color for house n-1-i
                        # Check constraints:
                        # 1. Symmetric constraint: curr_a != curr_b
                        # 2. Adjacent constraint: curr_a != prev_a (for left side)
                        # 3. Adjacent constraint: curr_b != prev_b (for right side)
                        if curr_a != curr_b and curr_a != prev_a and curr_b != prev_b:
                            new_cost = dp[prev_a][prev_b] + cost[i][curr_a] + cost[n-1-i][curr_b]
                            if new_cost < new_dp[curr_a][curr_b]:
                                new_dp[curr_a][curr_b] = new_cost
        
        dp = new_dp
    
    # Find minimum cost in final state
    min_cost = float('inf')
    for a in range(3):
        for b in range(3):
            min_cost = min(min_cost, dp[a][b])
    
    if min_cost == float('inf'):
        raise ValueError("Invalid input")
    
    return min_cost + 1
