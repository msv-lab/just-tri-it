# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    if not nums or x < 2 or x > len(nums):
        raise ValueError("Invalid input")
    
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute prefix sums for efficient range sum calculation
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Function to calculate operations needed for k subarrays
    def calculate_operations(k):
        if k * x > n:
            return float('inf')
        
        # We need to find k non-overlapping subarrays of length x
        # The cost for making a subarray [i, i+x-1] have all equal elements
        # is minimized when we make all elements equal to the median
        
        # DP approach: dp[i][j] = min operations for j subarrays using first i elements
        # But we need to optimize for large n
        
        # We'll use a greedy approach with sliding window
        # For each possible starting position of k subarrays, calculate total cost
        
        # Precompute cost for each possible subarray of length x
        subarray_costs = []
        for i in range(n - x + 1):
            # Extract the subarray
            sub = nums[i:i + x]
            # Sort to find median
            sorted_sub = sorted(sub)
            median = sorted_sub[x // 2]
            # Calculate operations needed
            cost = 0
            for val in sub:
                cost += abs(val - median)
            subarray_costs.append((i, cost))
        
        # Now we need to select k non-overlapping subarrays with minimum total cost
        # This is a classic interval scheduling problem with weights
        
        # Sort subarrays by end position
        subarray_costs.sort(key=lambda sc: sc[0] + x - 1)
        
        # Use DP to find minimum cost for selecting k non-overlapping subarrays
        m = len(subarray_costs)
        dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]
        dp[0][0] = 0
        
        for i in range(1, m + 1):
            idx, cost = subarray_costs[i - 1]
            end_pos = idx + x - 1
            
            # Option 1: Don't take current subarray
            for j in range(k + 1):
                dp[i][j] = min(dp[i][j], dp[i - 1][j])
            
            # Option 2: Take current subarray
            # Find the last subarray that ends before current starts
            prev_idx = -1
            for j in range(i - 1, 0, -1):
                prev_idx_j, _ = subarray_costs[j - 1]
                if prev_idx_j + x - 1 < idx:
                    prev_idx = j
                    break
            
            for j in range(1, k + 1):
                if prev_idx != -1:
                    dp[i][j] = min(dp[i][j], dp[prev_idx][j - 1] + cost)
                else:
                    if j == 1:
                        dp[i][j] = min(dp[i][j], cost)
        
        return dp[m][k] if dp[m][k] != float('inf') else float('inf')
    
    # Binary search for k that gives exactly min_operations_for_k_equal_subarrays
    left, right = 1, n // x
    
    # Check all possible k values
    for k in range(right, 0, -1):
        if k * x > n:
            continue
        operations = calculate_operations(k)
        if operations == min_operations_for_k_equal_subarrays:
            return k
    
    # If no exact match found, check if we can return any valid k
    # that satisfies the constraints
    for k in range(1, right + 1):
        if k * x <= n:
            operations = calculate_operations(k)
            if operations <= min_operations_for_k_equal_subarrays:
                # Find the maximum k that satisfies the condition
                candidate = k
                for k2 in range(k + 1, right + 1):
                    if k2 * x <= n:
                        operations2 = calculate_operations(k2)
                        if operations2 <= min_operations_for_k_equal_subarrays:
                            candidate = k2
                return candidate
    
    raise ValueError("Invalid input")
