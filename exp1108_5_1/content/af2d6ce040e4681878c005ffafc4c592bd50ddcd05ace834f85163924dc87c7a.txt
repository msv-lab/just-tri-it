# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to find the minimum cost
    # such that both houses have different colors and also different from their adjacent symmetric pairs
    
    # We'll process symmetric pairs and track the best costs for different color combinations
    
    # Initialize DP: for the first symmetric pair, all color combinations are valid except same colors
    # We'll track the minimum cost for the first k pairs
    
    # For each symmetric pair (i, j), we need to choose colors c1 for i and c2 for j such that:
    # 1. c1 != c2 (since they're symmetric)
    # 2. For adjacent symmetric pairs, the colors must be different
    
    # We can use DP where dp[k][c1][c2] = min cost for first k pairs with colors c1, c2
    # But this would be O(n * 3^4) which is too slow for n=10^5
    
    # Alternative approach: process pairs and track the best two color combinations
    
    # Initialize with first pair
    pair_costs = []
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                pair_costs.append((cost[0][c1] + cost[n-1][c2], c1, c2))
    
    pair_costs.sort()
    # Keep only the best few combinations to propagate
    
    # For subsequent pairs, we need to ensure colors are different from previous pair
    for i in range(1, n//2):
        new_costs = []
        for total_cost, prev_c1, prev_c2 in pair_costs[:6]:  # Keep top 6 to maintain diversity
            for c1 in range(3):
                for c2 in range(3):
                    if c1 != c2 and c1 != prev_c1 and c2 != prev_c2:
                        new_cost = total_cost + cost[i][c1] + cost[n-1-i][c2]
                        new_costs.append((new_cost, c1, c2))
        
        if not new_costs:
            raise ValueError("Invalid input")
        
        new_costs.sort()
        pair_costs = new_costs[:6]  # Keep top 6 combinations
    
    # Find the minimum total cost
    min_cost = min(pair_costs)[0] if pair_costs else 0
    
    # Add 1 to the final answer as requested
    return min_cost + 1
