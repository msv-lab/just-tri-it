# signature: def minOperations(nums: List[int], x: int, k: int) -> int
from typing import List
import heapq

def minOperations(nums: List[int], x: int, k: int) -> int:
    # Input validation
    if not nums or x < 2 or k < 1 or k * x > len(nums) or x > len(nums):
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Precompute prefix sums for efficient range sum calculation
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Precompute prefix sum of squares for variance calculation
    prefix_sq = [0] * (n + 1)
    for i in range(n):
        prefix_sq[i + 1] = prefix_sq[i] + nums[i] * nums[i]
    
    def get_range_sum(l, r):
        """Get sum of elements from index l to r-1"""
        return prefix[r] - prefix[l]
    
    def get_range_sum_sq(l, r):
        """Get sum of squares from index l to r-1"""
        return prefix_sq[r] - prefix_sq[l]
    
    def cost_for_subarray(start, target):
        """Calculate cost to make subarray starting at 'start' all equal to 'target'"""
        end = start + x
        current_sum = get_range_sum(start, end)
        current_sum_sq = get_range_sum_sq(start, end)
        
        # Cost = sum((nums[i] - target)^2) but we need absolute differences
        # For absolute differences, the optimal target is the median
        # But for squared differences, the optimal is the mean
        # We need to compute sum(|nums[i] - target|)
        
        # For efficiency, we'll use the mathematical identity:
        # sum(|a_i - m|) can be computed using prefix sums if we had sorted the subarray
        # Since we can't sort every subarray, we'll use a different approach
        
        # Alternative: use the fact that for a given target, cost = sum(|nums[i] - target|)
        # We can compute this using the prefix sum and the count of elements
        return sum(abs(nums[i] - target) for i in range(start, end))
    
    # Dynamic programming approach
    # dp[i][j] = minimum cost to have j valid subarrays considering first i*x positions
    # But k is small (<=15), so we can use state-space search
    
    # We need to find k non-overlapping subarrays of length x
    # Let's precompute the cost for making each possible subarray equal to any value
    
    # For each possible starting position of a subarray
    possible_starts = n - x + 1
    
    # Precompute for each subarray the optimal target and cost
    # The optimal target for minimizing sum(|a_i - t|) is the median
    subarray_costs = []
    
    for start in range(possible_starts):
        end = start + x
        subarr = nums[start:end]
        
        # Find median for minimum absolute deviations
        sorted_subarr = sorted(subarr)
        median = sorted_subarr[x // 2]
        
        # Calculate cost to make all elements equal to median
        cost = sum(abs(num - median) for num in subarr)
        subarray_costs.append((start, cost, median))
    
    # Now we need to select k non-overlapping subarrays with minimum total cost
    # Subarrays are non-overlapping if end_i <= start_j
    
    # Use dynamic programming: dp[i][j] = min cost using first i subarrays to get j valid ones
    # But we need to track the last used position
    
    # Alternative: use state DP where state is (mask, last_end)
    # Since k <= 15, we can use bitmask DP
    
    # Sort subarrays by start position
    subarray_costs.sort(key=lambda x: x[0])
    
    # For DP state: dp[mask][last_end] = min_cost
    # where mask is bitmask of used subarrays, last_end is the end position of last used subarray
    
    INF = float('inf')
    total_subarrays = len(subarray_costs)
    
    # Initialize DP table
    dp = [{} for _ in range(1 << k)]
    dp[0][0] = 0  # No subarrays used, last_end = 0
    
    for mask in range(1 << k):
        for last_end, current_cost in dp[mask].items():
            # Try to add a new subarray
            for idx in range(total_subarrays):
                if mask >> idx & 1:  # Already used
                    continue
                
                start, cost, _ = subarray_costs[idx]
                if start < last_end:  # Overlapping
                    continue
                
                new_mask = mask | (1 << idx)
                new_last_end = start + x
                new_cost = current_cost + cost
                
                if new_last_end not in dp[new_mask] or dp[new_mask][new_last_end] > new_cost:
                    dp[new_mask][new_last_end] = new_cost
    
    # Find minimum cost for mask with k bits set
    min_ops = INF
    for mask in range(1 << k):
        if bin(mask).count('1') == k:
            for cost in dp[mask].values():
                if cost < min_ops:
                    min_ops = cost
    
    if min_ops == INF:
        raise ValueError("Invalid input")
    
    return min_ops
