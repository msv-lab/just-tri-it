# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n != len(cost) or any(len(house) != 3 for house in cost):
        raise ValueError("Invalid input")
    
    if n == 2:
        min_cost = float('inf')
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:
                    total = cost[0][c1] + cost[1][c2]
                    if total < min_cost:
                        min_cost = total
        return min_cost
    
    # For each pair of symmetric houses, precompute the minimal costs for all valid color combinations
    total_pairs = n // 2
    dp = [[float('inf')] * 3 for _ in range(3)]  # dp[c1][c2] is the min cost for the first pair
    
    # Initialize the first pair (house 0 and house n-1)
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                dp[c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    for pair in range(1, total_pairs):
        i, j = pair, n - 1 - pair
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[prev_c1][prev_c2] == float('inf'):
                    continue
                for curr_c1 in range(3):
                    if curr_c1 == prev_c1:
                        continue
                    for curr_c2 in range(3):
                        if curr_c2 == prev_c2 or curr_c1 == curr_c2:
                            continue
                        new_cost = dp[prev_c1][prev_c2] + cost[i][curr_c1] + cost[j][curr_c2]
                        if new_cost < new_dp[curr_c1][curr_c2]:
                            new_dp[curr_c1][curr_c2] = new_cost
        dp = new_dp
    
    min_total = min(min(row) for row in dp)
    return min_total
