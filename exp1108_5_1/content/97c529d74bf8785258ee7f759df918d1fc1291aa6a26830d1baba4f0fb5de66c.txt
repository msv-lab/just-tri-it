# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 100000:
                raise ValueError("Invalid input")
    
    # For symmetric positions (i, n-1-i), we need to find the minimum cost
    # such that colors at these positions are different from each other
    # and also different from their adjacent symmetric pairs
    
    total_cost = 0
    for i in range(n // 2):
        j = n - 1 - i
        
        # Find the two minimum costs for position i
        min1_i, min2_i = float('inf'), float('inf')
        min1_color_i, min2_color_i = -1, -1
        
        for color in range(3):
            if cost[i][color] < min1_i:
                min2_i, min2_color_i = min1_i, min1_color_i
                min1_i, min1_color_i = cost[i][color], color
            elif cost[i][color] < min2_i:
                min2_i, min2_color_i = cost[i][color], color
        
        # Find the two minimum costs for position j
        min1_j, min2_j = float('inf'), float('inf')
        min1_color_j, min2_color_j = -1, -1
        
        for color in range(3):
            if cost[j][color] < min1_j:
                min2_j, min2_color_j = min1_j, min1_color_j
                min1_j, min1_color_j = cost[j][color], color
            elif cost[j][color] < min2_j:
                min2_j, min2_color_j = cost[j][color], color
        
        # Choose colors for positions i and j such that they are different
        # and minimize the total cost
        best_pair_cost = float('inf')
        
        for color_i in range(3):
            for color_j in range(3):
                if color_i != color_j:
                    current_cost = cost[i][color_i] + cost[j][color_j]
                    if current_cost < best_pair_cost:
                        best_pair_cost = current_cost
        
        total_cost += best_pair_cost
    
    return total_cost
