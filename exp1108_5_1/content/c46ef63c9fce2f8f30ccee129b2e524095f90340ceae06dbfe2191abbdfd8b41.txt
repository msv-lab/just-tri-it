# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    
    for row in cost:
        if len(row) != 3:
            raise ValueError("Invalid input")
        for val in row:
            if val < 0 or val > 10**5:
                raise ValueError("Invalid input")
    
    # For symmetric constraints, we need to consider that:
    # - Adjacent houses can't have same color
    # - Symmetric houses (i-th and (n-1-i)-th) can't have same color
    
    # Dynamic programming approach considering both constraints
    # dp[i][c] = min cost for first i+1 houses where house i has color c
    # But we need to track both ends simultaneously
    
    # Alternative approach: since constraints are symmetric, we can pair houses
    # For each pair (i, n-1-i), we need to assign different colors to both houses
    # and also ensure adjacent pairs have different colors
    
    # Initialize DP for the first pair
    # For first pair (house 0 and house n-1)
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    for c0 in range(3):
        for c_last in range(3):
            if c0 != c_last:  # Symmetric constraint
                dp[c0][c_last] = cost[0][c0] + cost[n-1][c_last]
    
    # Process remaining pairs
    for i in range(1, n // 2):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        for prev_c0 in range(3):  # Color of previous left house (i-1)
            for prev_c_last in range(3):  # Color of previous right house (n-i)
                for curr_c0 in range(3):  # Color of current left house (i)
                    for curr_c_last in range(3):  # Color of current right house (n-1-i)
                        # Adjacent constraint: current left != previous left
                        # Symmetric constraint: current left != current right
                        if curr_c0 != prev_c0 and curr_c0 != curr_c_last:
                            cost_val = cost[i][curr_c0] + cost[n-1-i][curr_c_last]
                            new_dp[curr_c0][curr_c_last] = min(
                                new_dp[curr_c0][curr_c_last], 
                                dp[prev_c0][prev_c_last] + cost_val
                            )
        
        dp = new_dp
    
    # Find minimum cost in the final DP state
    min_cost = float('inf')
    for c0 in range(3):
        for c_last in range(3):
            min_cost = min(min_cost, dp[c0][c_last])
    
    return min_cost
