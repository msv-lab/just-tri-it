# signature: def longestSpecialPath(edges: List[List[int]], nums: List[int]) -> List[int]
# test name: test_example_1
def test_example_1():
    """Test the provided example 1"""
    edges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]]
    nums = [2,1,2,1,3,1]
    result = longestSpecialPath(edges, nums)
    assert result == [6, 2]

def test_example_2():
    """Test the provided example 2"""
    edges = [[1,0,8]]
    nums = [2,2]
    result = longestSpecialPath(edges, nums)
    assert result == [0, 1]

def test_single_node_paths():
    """Test when all paths are single nodes (all duplicate values)"""
    edges = [[0,1,1],[0,2,2],[0,3,3]]
    nums = [5,5,5,5]
    result = longestSpecialPath(edges, nums)
    assert result == [0, 1]

def test_all_unique_values():
    """Test when all node values are unique - longest path should be the longest path in tree"""
    edges = [[0,1,2],[1,2,3],[1,3,4]]
    nums = [1,2,3,4]
    result = longestSpecialPath(edges, nums)
    # Path 0->1->2 has length 5, path 0->1->3 has length 6
    assert result == [6, 3]

def test_multiple_longest_paths_same_length():
    """Test when multiple paths have same length but different node counts"""
    edges = [[0,1,2],[0,2,2],[1,3,1],[2,4,1]]
    nums = [1,2,3,4,5]  # All unique values
    result = longestSpecialPath(edges, nums)
    # Paths 0->1->3 and 0->2->4 both have length 3, both have 3 nodes
    assert result == [3, 3]

def test_duplicate_breaks_long_path():
    """Test when a duplicate value breaks what would be the longest path"""
    edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,1]]
    nums = [1,2,3,2,4]  # Duplicate at nodes 1 and 3 breaks the long path
    result = longestSpecialPath(edges, nums)
    # Valid paths: 0->1->2 (length 2, 3 nodes), 2->3->4 (length 2, 3 nodes)
    assert result == [2, 3]

def test_star_tree_structure():
    """Test with star-shaped tree"""
    edges = [[0,1,1],[0,2,2],[0,3,3],[0,4,4]]
    nums = [1,2,3,4,5]  # All unique values
    result = longestSpecialPath(edges, nums)
    # All paths from root to leaves have same node count but different lengths
    # Longest is 0->4 with length 4
    assert result == [4, 2]

def test_chain_tree():
    """Test with linear chain tree"""
    edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,1]]
    nums = [1,2,3,4,5]  # All unique values
    result = longestSpecialPath(edges, nums)
    # Longest path is the entire chain: 0->1->2->3->4 with length 4
    assert result == [4, 5]

def test_duplicate_at_root():
    """Test when root value appears elsewhere, breaking paths"""
    edges = [[0,1,2],[1,2,3],[1,3,4]]
    nums = [5,1,5,2]  # Root value 5 appears at node 2
    result = longestSpecialPath(edges, nums)
    # Valid paths: 0->1 (length 2, 2 nodes), 1->3 (length 4, 2 nodes)
    assert result == [4, 2]

def test_minimum_nodes_selection():
    """Test selection of path with minimum nodes among longest paths"""
    edges = [[0,1,5],[0,2,5],[1,3,1],[2,4,1],[2,5,1]]
    nums = [1,2,3,4,5,6]  # All unique values
    result = longestSpecialPath(edges, nums)
    # Multiple paths with length 6: 0->1->3 (3 nodes), 0->2->4 (3 nodes), 0->2->5 (3 nodes)
    assert result == [6, 3]

def test_single_long_path_with_breaks():
    """Test a long path with multiple duplicate breaks"""
    edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[4,5,1]]
    nums = [1,2,1,3,4,5]  # Duplicate at nodes 0 and 2
    result = longestSpecialPath(edges, nums)
    # Valid paths: 2->3->4->5 (length 3, 4 nodes)
    assert result == [3, 4]

def test_only_root():
    """Test edge case with just root node (though constraints say n>=2)"""
    edges = []
    nums = [1]
    result = longestSpecialPath(edges, nums)
    assert result == [0, 1]

def test_two_nodes_unique():
    """Test simple two-node case with unique values"""
    edges = [[0,1,5]]
    nums = [1,2]
    result = longestSpecialPath(edges, nums)
    assert result == [5, 2]

def test_two_nodes_duplicate():
    """Test simple two-node case with duplicate values"""
    edges = [[0,1,5]]
    nums = [1,1]
    result = longestSpecialPath(edges, nums)
    assert result == [0, 1]

def test_complex_branching():
    """Test more complex branching structure"""
    edges = [[0,1,2],[0,2,3],[1,3,1],[1,4,2],[2,5,1],[2,6,2]]
    nums = [1,2,3,4,2,5,6]  # Duplicate at nodes 1 and 4
    result = longestSpecialPath(edges, nums)
    # Longest paths: 0->2->5 (length 4, 3 nodes), 0->2->6 (length 5, 3 nodes)
    assert result == [5, 3]

def test_all_same_values_except_one():
    """Test where all values are same except one leaf"""
    edges = [[0,1,1],[0,2,1],[0,3,2]]
    nums = [1,1,1,2]
    result = longestSpecialPath(edges, nums)
    # Only valid paths with length > 0: 0->3 (length 2, 2 nodes)
    assert result == [2, 2]