# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    
    # Check constraints
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for i in range(n):
        if len(cost[i]) != 3:
            raise ValueError("Invalid input")
        for j in range(3):
            if cost[i][j] < 0 or cost[i][j] > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses cannot have same color
    
    # Precompute the minimum cost for each symmetric pair
    # We'll create a DP table where dp[i][c1][c2] represents the minimum cost for the first i pairs
    # where the left house has color c1 and right house has color c2
    
    # Since we have 3 colors and n can be large, we need an efficient approach
    
    # For each symmetric pair (i, n-1-i), we need to choose colors such that:
    # 1. color_i != color_{i+1} (for adjacent houses, except for middle pairs)
    # 2. color_i != color_{n-1-i} (symmetric constraint)
    # 3. color_{n-1-i} != color_{n-2-i} (for adjacent houses, except for middle pairs)
    
    # We can use dynamic programming where we track the minimum cost for the first k pairs
    # with the colors chosen for the k-th pair
    
    # Initialize DP for the first pair
    dp = [[float('inf')] * 3 for _ in range(3)]
    
    # Try all color combinations for the first symmetric pair (0, n-1)
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Process remaining pairs
    for i in range(1, n//2):
        new_dp = [[float('inf')] * 3 for _ in range(3)]
        
        # Current pair is (i, n-1-i)
        for prev_c1 in range(3):  # Color of house i-1
            for prev_c2 in range(3):  # Color of house n-i
                if dp[prev_c1][prev_c2] == float('inf'):
                    continue
                
                # Try all colors for current pair
                for curr_c1 in range(3):  # Color of house i
                    for curr_c2 in range(3):  # Color of house n-1-i
                        # Check constraints:
                        # 1. Adjacent constraint: curr_c1 != prev_c1
                        # 2. Symmetric constraint: curr_c1 != curr_c2
                        # 3. Adjacent constraint for right side: curr_c2 != prev_c2
                        if curr_c1 != prev_c1 and curr_c1 != curr_c2 and curr_c2 != prev_c2:
                            total_cost = dp[prev_c1][prev_c2] + cost[i][curr_c1] + cost[n-1-i][curr_c2]
                            if total_cost < new_dp[curr_c1][curr_c2]:
                                new_dp[curr_c1][curr_c2] = total_cost
        
        dp = new_dp
    
    # Find the minimum cost in the final state
    min_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_cost = min(min_cost, dp[c1][c2])
    
    if min_cost == float('inf'):
        raise ValueError("Invalid input")
    
    return min_cost + 1
