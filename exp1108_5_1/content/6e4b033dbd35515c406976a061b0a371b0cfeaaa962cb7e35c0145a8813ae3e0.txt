# signature: def minCost_simp(cost: List[List[int]]) -> int
from typing import List

def minCost_simp(cost: List[List[int]]) -> int:
    n = len(cost)
    if n % 2 != 0 or n < 2 or n > 100000:
        raise ValueError("Invalid input")
    
    for house_cost in cost:
        if len(house_cost) != 3:
            raise ValueError("Invalid input")
        for c in house_cost:
            if c < 0 or c > 100000:
                raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to choose different colors
    # Also adjacent houses cannot have same color
    
    # Precompute the minimum cost for each symmetric pair
    # We'll consider all valid color combinations for each symmetric pair
    
    total_cost = 0
    
    for i in range(n // 2):
        j = n - 1 - i  # symmetric house
        
        # Find the minimum cost combination where:
        # 1. house i and house j have different colors
        # 2. If i > 0, house i has different color than house i-1
        # 3. If j < n-1, house j has different color than house j+1
        
        min_cost = float('inf')
        
        # Try all color combinations for the symmetric pair
        for color_i in range(3):
            for color_j in range(3):
                if color_i == color_j:
                    continue  # Symmetric houses cannot have same color
                
                # Check adjacent constraint for house i
                if i > 0:
                    # We don't know the actual color of i-1, so we'll handle this differently
                    # We need to consider the entire chain
                    continue
                
                # For the first iteration, we can compute directly
                current_cost = cost[i][color_i] + cost[j][color_j]
                
                # For subsequent pairs, we need to ensure they don't conflict with previous choices
                # This requires dynamic programming approach
                
                min_cost = min(min_cost, current_cost)
        
        # For simplicity in this implementation, we'll use a DP approach
        # that considers the entire row
        
        # Since this is complex, let's implement a proper DP solution
        break  # Break out of the loop to implement proper solution
    
    # Proper DP implementation
    # We need to track the minimum cost for each symmetric pair with different color combinations
    
    # For each symmetric pair (i, n-1-i), we have 3x3 = 9 possible color combinations
    # But we need to ensure adjacent constraints
    
    # Let's create a DP table where dp[i][c1][c2] represents the minimum cost
    # for the first i pairs, with the i-th pair having colors c1 and c2
    
    # Initialize DP for the first pair
    dp = [[[float('inf') for _ in range(3)] for _ in range(3)] for _ in range(n // 2)]
    
    # Initialize first pair
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:  # Symmetric constraint
                dp[0][c1][c2] = cost[0][c1] + cost[n-1][c2]
    
    # Fill DP table for remaining pairs
    for pair_idx in range(1, n // 2):
        i = pair_idx
        j = n - 1 - pair_idx
        
        for prev_c1 in range(3):
            for prev_c2 in range(3):
                if dp[pair_idx-1][prev_c1][prev_c2] == float('inf'):
                    continue
                
                for curr_c1 in range(3):
                    for curr_c2 in range(3):
                        if curr_c1 == curr_c2:  # Symmetric constraint
                            continue
                        if curr_c1 == prev_c1:  # Adjacent constraint for house i
                            continue
                        if curr_c2 == prev_c2:  # Adjacent constraint for house j
                            continue
                        
                        current_cost = dp[pair_idx-1][prev_c1][prev_c2] + cost[i][curr_c1] + cost[j][curr_c2]
                        dp[pair_idx][curr_c1][curr_c2] = min(dp[pair_idx][curr_c1][curr_c2], current_cost)
    
    # Find minimum cost in the last pair
    min_total_cost = float('inf')
    for c1 in range(3):
        for c2 in range(3):
            min_total_cost = min(min_total_cost, dp[n//2 - 1][c1][c2])
    
    if min_total_cost == float('inf'):
        raise ValueError("Invalid input")
    
    return min_total_cost + 1
