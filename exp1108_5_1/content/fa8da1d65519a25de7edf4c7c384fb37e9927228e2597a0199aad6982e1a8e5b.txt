# signature: def minCost(n: int, cost: List[List[int]]) -> int
from typing import List

def minCost(n: int, cost: List[List[int]]) -> int:
    if n % 2 != 0 or n < 2:
        raise ValueError("Invalid input")
    
    if len(cost) != n or any(len(row) != 3 for row in cost):
        raise ValueError("Invalid input")
    
    if any(any(c < 0 for c in row) for row in cost):
        raise ValueError("Invalid input")
    
    # For each pair of symmetric houses (i, n-1-i), we need to find the minimum cost
    # considering that they cannot have the same color and adjacent houses cannot have same color
    
    # dp[i][c1][c2] would be too expensive, so we'll use a different approach
    # We'll process pairs and maintain the best two options for each pair
    
    # Initialize DP for the first pair
    # For the first pair (0, n-1), we can choose any colors as long as they're different
    prev = []
    for c1 in range(3):
        for c2 in range(3):
            if c1 != c2:
                prev.append((c1, c2, cost[0][c1] + cost[n-1][c2]))
    
    # Sort by cost and keep only the best few options to avoid combinatorial explosion
    prev.sort(key=lambda x: x[2])
    prev = prev[:6]  # Keep top 6 options
    
    # Process remaining pairs
    for i in range(1, n//2):
        current = []
        left_idx, right_idx = i, n-1-i
        
        for prev_c1, prev_c2, prev_cost in prev:
            for c1 in range(3):
                for c2 in range(3):
                    # Check constraints:
                    # 1. Current left house color != previous left house color (adjacent)
                    # 2. Current right house color != previous right house color (adjacent)  
                    # 3. Current left and right houses cannot have same color (symmetric)
                    if c1 != prev_c1 and c2 != prev_c2 and c1 != c2:
                        current_cost = prev_cost + cost[left_idx][c1] + cost[right_idx][c2]
                        current.append((c1, c2, current_cost))
        
        # Sort by cost and keep only the best options
        current.sort(key=lambda x: x[2])
        prev = current[:6]
    
    return min(prev, key=lambda x: x[2])[2] if prev else 0
