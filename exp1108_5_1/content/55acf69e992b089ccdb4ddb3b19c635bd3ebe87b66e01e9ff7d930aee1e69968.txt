# signature: def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int
from typing import List
import heapq

def minOperations_inv_k(min_operations_for_k_equal_subarrays: int, nums: List[int], x: int) -> int:
    # Input validation
    if not nums or x < 2 or x > len(nums) or min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    n = len(nums)
    
    # Calculate cost for each possible subarray of length x
    costs = []
    
    # Use sliding window to calculate cost for each subarray
    # The cost for a subarray is the sum of absolute differences from median
    for i in range(n - x + 1):
        subarray = nums[i:i + x]
        
        # Find median using two heaps
        left = []  # max heap (store negative values)
        right = []  # min heap
        
        for j, val in enumerate(subarray):
            if not left or val <= -left[0]:
                heapq.heappush(left, -val)
            else:
                heapq.heappush(right, val)
            
            # Balance heaps
            if len(left) > len(right) + 1:
                heapq.heappush(right, -heapq.heappop(left))
            elif len(right) > len(left):
                heapq.heappush(left, -heapq.heappop(right))
        
        # Median is at left[0] (max of left heap)
        median = -left[0]
        
        # Calculate cost (sum of absolute differences from median)
        cost = sum(abs(num - median) for num in subarray)
        costs.append(cost)
    
    # Sort costs in ascending order
    costs.sort()
    
    # Find the maximum k such that sum of k smallest costs <= min_operations_for_k_equal_subarrays
    total_cost = 0
    k = 0
    
    for i in range(len(costs)):
        if total_cost + costs[i] <= min_operations_for_k_equal_subarrays:
            total_cost += costs[i]
            k += 1
        else:
            break
    
    # Validate constraints
    if k < 1 or k > 15 or k * x > n:
        # If k doesn't satisfy constraints, find the largest valid k
        k = min(15, n // x)
        while k > 0 and (k * x > n or sum(costs[:k]) > min_operations_for_k_equal_subarrays):
            k -= 1
    
    if k == 0:
        raise ValueError("Invalid input")
    
    return k
