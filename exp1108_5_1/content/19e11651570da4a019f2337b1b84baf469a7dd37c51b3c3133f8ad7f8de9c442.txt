# signature: def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool
from typing import List

def postcondition(nums: List[int], x: int, k: int, min_operations_for_k_equal_subarrays: int) -> bool:
    n = len(nums)
    
    # Validate constraints
    if n < 2 or n > 10**5:
        raise ValueError("Invalid input")
    if any(num < -10**6 or num > 10**6 for num in nums):
        raise ValueError("Invalid input")
    if x < 2 or x > n:
        raise ValueError("Invalid input")
    if k < 1 or k > 15:
        raise ValueError("Invalid input")
    if k * x < 2 or k * x > n:
        raise ValueError("Invalid input")
    if min_operations_for_k_equal_subarrays < 0:
        raise ValueError("Invalid input")
    
    # Precompute prefix sums for efficient range sum calculation
    prefix = [0] * (n + 1)
    for i in range(n):
        prefix[i + 1] = prefix[i] + nums[i]
    
    # Precompute prefix sums of squares for efficient range variance calculation
    prefix_sq = [0] * (n + 1)
    for i in range(n):
        prefix_sq[i + 1] = prefix_sq[i] + nums[i] * nums[i]
    
    def get_range_sum(l, r):
        """Get sum of elements from index l to r-1"""
        return prefix[r] - prefix[l]
    
    def get_range_sq_sum(l, r):
        """Get sum of squares of elements from index l to r-1"""
        return prefix_sq[r] - prefix_sq[l]
    
    def cost_for_target(l, r, target):
        """Calculate cost to make all elements in [l, r) equal to target"""
        length = r - l
        if length == 0:
            return 0
        
        current_sum = get_range_sum(l, r)
        current_sq_sum = get_range_sq_sum(l, r)
        
        # cost = sum((a_i - target)^2) but we need absolute differences
        # For absolute differences, the optimal target is the median
        # But we can compute for a given target:
        # cost = sum(|a_i - target|)
        # We can compute this efficiently by sorting, but for now we'll use direct calculation
        
        # For efficiency, we'll calculate directly
        total_cost = 0
        for i in range(l, r):
            total_cost += abs(nums[i] - target)
        
        return total_cost
    
    def find_min_cost_for_subarray(l, r):
        """Find minimum cost to make all elements in [l, r) equal"""
        # For absolute differences, the optimal target is the median
        subarray = nums[l:r]
        subarray_sorted = sorted(subarray)
        median = subarray_sorted[len(subarray_sorted) // 2]
        
        # Also check values around median to be sure
        candidates = [median]
        if median - 1 >= min(nums[l:r]):
            candidates.append(median - 1)
        if median + 1 <= max(nums[l:r]):
            candidates.append(median + 1)
        
        min_cost = float('inf')
        for candidate in candidates:
            cost = cost_for_target(l, r, candidate)
            if cost < min_cost:
                min_cost = cost
        
        return min_cost
    
    # Dynamic programming approach
    # dp[i][j] = minimum cost to form j subarrays using first i elements
    INF = float('inf')
    dp = [[INF] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    
    for i in range(n + 1):
        for j in range(k + 1):
            if dp[i][j] == INF:
                continue
            
            # Try to form the next subarray starting at position i
            if j < k and i + x <= n:
                cost = find_min_cost_for_subarray(i, i + x)
                if dp[i + x][j + 1] > dp[i][j] + cost:
                    dp[i + x][j + 1] = dp[i][j] + cost
    
    # Find the minimum cost to form at least k subarrays
    min_required = INF
    for i in range(n + 1):
        if dp[i][k] < min_required:
            min_required = dp[i][k]
    
    # Return True if the given value is at least the minimum required
    if min_required == INF:
        # It's impossible to form k subarrays
        return False
    
    return min_operations_for_k_equal_subarrays >= min_required
