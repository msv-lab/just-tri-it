[
  {
    "id": "absolute_zero",
    "requirements": {
      "signature": "def absolute_zero(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[Union[int, Tuple[int, list[int]]]]",
      "description": "You are given an array $a$ of $n$ integers.\n\nIn one operation, you will perform the following two-step move:\n\n  1. Choose an integer $x$ ($0 \\le x \\le 10^{9}$).    2. Replace each $a_i$ with $|a_i - x|$, where $|v|$ denotes the [absolute value](https://en.wikipedia.org/wiki/Absolute_value) of $v$. \n\nFor example, by choosing $x = 8$, the array $[5, 7, 10]$ will be changed into $[|5-8|, |7-8|, |10-8|] = [3,1,2]$.\n\nConstruct a sequence of operations to make all elements of $a$ equal to $0$ in at most $40$ operations or determine that it is impossible. You do not need to minimize the number of operations.\n\n# Input:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) — the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output a single integer $-1$ if it is impossible to make all array elements equal to $0$ in at most $40$ operations.\n\nOtherwise, output two lines. The first line of output should contain a single integer $k$ ($0 \\le k \\le 40$) — the number of operations. The second line of output should contain $k$ integers $x_1, x_2, \\ldots, x_k$ ($0 \\le x_i \\le 10^{9}$) — the sequence of operations, denoting that on the $i$-th operation, you chose $x=x_i$.\n\nIf there are multiple solutions, output any of them.\n\nYou do not need to minimize the number of operations.\n\n# Example input:\n5\n1\n5\n2\n0 0\n3\n4 6 8\n4\n80 40 20 10\n5\n1 2 3 4 5\n\n# Example output:\n1\n5\n0\n\n3\n6 1 1\n7\n60 40 20 10 30 25 5\n-1\n\n# Notes:\nIn the first test case, we can perform only one operation by choosing $x = 5$, changing the array from $[5]$ to $[0]$.\n\nIn the second test case, no operations are needed because all elements of the array are already $0$.\n\nIn the third test case, we can choose $x = 6$ to change the array from $[4, 6, 8]$ to $[2, 0, 2]$, then choose $x = 1$ to change it to $[1, 1, 1]$, and finally choose $x = 1$ again to change the array into $[0, 0, 0]$.\n\nIn the fourth test case, we can make all elements $0$ by following the operation sequence $(60, 40, 20, 10, 30, 25, 5)$.\n\nIn the fifth test case, it can be shown that it is impossible to make all elements $0$ in at most $40$ operations. Therefore, the output is $-1$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[Tuple[int, list[int]]], result: list[Union[int, Tuple[int, list[int]]]]) -> bool:\n    for (test, res) in zip(test_cases, result):\n        _, a = test\n        if res == -1:\n            has_even = any(num % 2 == 0 for num in a)\n            has_odd = any(num % 2 == 1 for num in a)\n            if not (has_even and has_odd):\n                return False\n            continue\n        k, ops = res\n        if k < 0 or k > 40 or len(ops) != k:\n            return False\n        if any(x < 0 or x > 10**9 for x in ops):\n            return False\n        arr = a[:]\n        for x in ops:\n            arr = [abs(ai - x) for ai in arr]\n        if not all(x == 0 for x in arr):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(1, [5])], absolute_zero(1, [(1, [5])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(2, [0, 0])], absolute_zero(1, [(2, [0, 0])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(3, [4, 6, 8])], absolute_zero(1, [(3, [4, 6, 8])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(4, [80, 40, 20, 10])], absolute_zero(1, [(4, [80, 40, 20, 10])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(5, [1, 2, 3, 4, 5])], absolute_zero(1, [(5, [1, 2, 3, 4, 5])]))"
      }
    ],
    "metadata": {
      "problem_id": "1991C",
      "url": "https://codeforces.com/problemset/problem/1991/C",
      "title": "Absolute Zero",
      "rating": 1300,
      "tags": [
        "constructive algorithms",
        "greedy",
        "math"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 341562269\n# status: accepted\n\ndef absolute_zero(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[Union[int, Tuple[int, list[int]]]]:\n    results = []\n    for test_id in range(t):\n        n, a = test_cases[test_id]\n        has_o = any(i % 2 for i in a)\n        has_e = any(i % 2 == 0 for i in a)\n        if has_o and has_e:\n            results.append(-1)\n            continue\n\n        if all(x == 0 for x in a):\n            results.append((0, []))\n            continue\n\n        xs = []\n        for _ in range(40):\n            if len(set(a)) == 1 and a[0] == 0:\n                break\n            mn, mx = min(a), max(a)\n            x = (mn + mx) // 2\n            xs.append(x)\n            a = [abs(v - x) for v in a]\n\n        if len(set(a)) == 1 and a[0] == 0:\n            results.append((len(xs), xs))\n        else:\n            results.append(-1)\n    return results\n",
      "incorrect_solution": "# submission:  337496545\n# Test: #2, time: 296 ms., memory: 360 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n#\n# Input\n# 10000\n# 31\n# 122534856 593338421 540955131 295232715 83411336 109748022 536634186 623506706 852252290 487528187 424941906 449273820 508402180 860009678 174523343 416980253 665739536 711698198 187959667 492038098 441938264 18547690 308727943 211151834 158361388 436432280 464300138 204815159 631842474 55436168 357371258\n# 10\n# 420424515 41942964 45287399 878574332 541226684 501543683 592682025 653094343 559196027 913029055\n# 76\n# 724972238 500692437 185543711 206758357 13673463 713434550 770430204 937642831 913064...\n#\n# Output\n# -1\n# -1\n# -1\n# -1\n# 31\n# 536870912 268435456 134217728 67108864 33554432 16777216 8388608 4194304 2097152 1048576 524288 262144 131072 65536 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1 1\n# -1\n# 31\n# 536870912 268435456 134217728 67108864 33554432 16777216 8388608 4194304 2097152 1048576 524288 262144 131072 65536 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1 1\n# 30\n# 536870912 268435456 134217728 67108864 33554432 16777216 8388608 4194304 2097152 1048576 524288 262144 131072 65536 327...\n#\n# Answer\n# -1\n# -1\n# -1\n# -1\n# 31\n# 536870912 268435456 134217728 67108864 33554432 16777216 8388608 4194304 2097152 1048576 524288 262144 131072 65536 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1 1 \n# -1\n# 31\n# 536870912 268435456 134217728 67108864 33554432 16777216 8388608 4194304 2097152 1048576 524288 262144 131072 65536 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1 1 \n# 30\n# 536870912 268435456 134217728 67108864 33554432 16777216 8388608 4194304 2097152 1048576 524288 262144 131072 65536 3...\n#\n# Checker Log\n# wrong answer you did not mark it impossible when it is impossible (test case 30)\n\ndef absolute_zero(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[Union[int, Tuple[int, list[int]]]]:\n    results = []\n\n    for i in range(t):\n        n, a = test_cases[i]\n        #check if any number are consecutive if consecutive this op is not possible\n        a.sort()\n        fc=0\n        count=0\n        l=[]\n        he=False\n        ho=False\n        for i in range(n-1):\n        #     if a[i+1]-a[i]==1:\n        #         fc=1\n        #         break\n        # if fc==1:\n        #     print(-1)\n        # else:\n        #     for i in range(40):\n        #         if max(a)==0:\n        #             fc=1\n        #             break\n        #         bar=(max(a)+min(a))//2\n        #         for i in range(n):\n        #             a[i]=abs(bar-a[i])\n        #         l.append(bar)\n        #         count+=1\n        #     if fc==1:\n        #         print(count)\n        #         print(*l)\n        #     else:\n        #         print(-1)\n            if (a[i] & 1)==1:\n                ho=True\n            else:\n                he=True\n        if he and ho:\n            results.append(-1)\n        else:\n            for i in range(29,-1,-1):\n                l.append(1<<i)\n            if he:\n                l.append(1)\n            results.append((len(l), l))\n    return results\n"
    }
  },
  {
    "id": "alices_adventures_in_cards",
    "requirements": {
      "signature": "def alices_adventures_in_cards(t: int, test_cases: list[Tuple[int, list[int], list[int], list[int]]]) -> list[Tuple[str, int, list[Tuple[str, int]]]]",
      "description": "Alice is playing cards with the Queen of Hearts, King of Hearts, and Jack of Hearts. There are $n$ different types of cards in their card game. Alice currently has a card of type $1$ and needs a card of type $n$ to escape Wonderland. The other players have one of each kind of card.\n\nIn this card game, Alice can trade cards with the three other players. Each player has different preferences for the $n$ types of cards, which can be described by permutations$^{\\text{∗}}$ $q$, $k$, and $j$ for the Queen, King, and Jack, respectively.\n\nA player values card $a$ more than card $b$ if for their permutation $p$, $p_a > p_b$. Then, this player is willing to trade card $b$ to Alice in exchange for card $a$. Alice's preferences are straightforward: she values card $a$ more than card $b$ if $a > b$, and she will also only trade according to these preferences.\n\nDetermine if Alice can trade up from card $1$ to card $n$ subject to these preferences, and if it is possible, give a possible set of trades to do it.\n\n$^{\\text{∗}}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n# Input:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($2\\le n\\le 2\\cdot 10^5$) — the number of card types.\n\nThe next three lines contain the preferences of the Queen, King, and Jack respectively. Each of these lines contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($1\\le p_i\\le n$) — a permutation corresponding to the player's preferences.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.\n\n# Output:\nFor each test case, on the first line output a single string \"YES\" or \"NO\" (without the quotes) denoting whether Alice can trade up to card $n$.\n\nIf the first line was \"YES\", then on the next line output $k$ — the number of trades Alice will make. On the next $k$ lines output space separated a character $c\\in \\\\{\\texttt{q}, \\texttt{k}, \\texttt{j}\\\\}$ and integer $x$, denoting that Alice trades with player $c$ to get card $x$. It must be the case that on the $k$'th line, $x = n$. If there are multiple solutions, print any of them.\n\nYou can output this answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses. The same goes for the character $c$ denoting the player in the trade ($\\texttt{Q}, \\texttt{K}, \\texttt{J}$ will all be accepted alongside their lowercase variants).\n\n# Example input:\n2\n3\n1 3 2\n2 1 3\n1 2 3\n4\n2 3 1 4\n1 2 3 4\n1 4 2 3\n\n# Example output:\nYES\n2\nk 2\nq 3\nNO\n\n# Notes:\nIn the first testcase, Alice can trade with the King to get card $2$. She can then trade with the Queen to get card $3$.\n\nIn the second testcase, even though Alice can trade with the Queen to get card $3$, with the King to get card $2$, and then with the Jack to get card $4$, this is not a valid solution since it doesn't respect Alice's preferences. We can show that there is no way for Alice to get to card $4$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[Tuple[int, list[int], list[int], list[int]]],\n            results: list[Tuple[str, int, list[Tuple[str, int]]]]) -> bool:\n\n    for test, result in zip(test_cases, results):\n\n        n, q, k, j = test\n        lines = result\n        first_line = lines[0].upper()\n        prefs = [q, k, j]\n\n        if first_line == 'NO':\n            if n == 1:\n                return False  # Alice starts at 1 and wants 1, so NO is invalid\n            # Compute if solution exists using AC logic\n            mins = [n] * 3\n            sol = [None] * (n + 2)\n            for i in range(n-1, 0, -1):\n                win = -1\n                for j_idx in range(3):\n                    pref_i = prefs[j_idx][i-1]\n                    pref_mins = prefs[j_idx][mins[j_idx]-1]\n                    if pref_i > pref_mins:\n                        win = j_idx\n                        break\n                if win != -1:\n                    sol[i] = win\n                    for j_idx in range(3):\n                        pref_i = prefs[j_idx][i-1]\n                        pref_mins = prefs[j_idx][mins[j_idx]-1]\n                        if pref_i < pref_mins:\n                            mins[j_idx] = i\n            if not(sol[1] is None):\n                return False\n\n        elif first_line != 'YES':\n            return False\n\n        current_card = 1\n        trades = lines[2]\n        for trade in trades:\n            player, x = trade\n            player = player.lower()\n            if player not in ['q', 'k', 'j']:\n                return False\n            if x < 1 or x > n or x <= current_card:\n                return False\n            j_idx = -1\n            if player == 'q':\n                j_idx = 0\n            elif player == 'k':\n                j_idx = 1\n            else:\n                j_idx = 2\n            a = current_card\n            b = x\n            if prefs[j_idx][a-1] <= prefs[j_idx][b-1]:\n                return False\n            current_card = x\n        if not(current_card == n):\n            return False\n\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, [1, 3, 2], [2, 1, 3], [1, 2, 3])], alices_adventures_in_cards(1, [(3, [1, 3, 2], [2, 1, 3], [1, 2, 3])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(4, [2, 3, 1, 4], [1, 2, 3, 4], [1, 4, 2, 3])], alices_adventures_in_cards(1, [(4, [2, 3, 1, 4], [1, 2, 3, 4], [1, 4, 2, 3])]))"
      }
    ],
    "metadata": {
      "problem_id": "2028D",
      "url": "https://codeforces.com/problemset/problem/2028/D",
      "title": "Alice's Adventures in Cards",
      "rating": 2000,
      "tags": [
        "constructive algorithms",
        "divide and conquer",
        "dp",
        "graphs",
        "greedy",
        "implementation",
        "sortings",
        "two pointers"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 343117001\n# status: accepted\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=max): # need to change default if func = min\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\ndef alices_adventures_in_cards(t: int, test_cases: list[Tuple[int, list[int], list[int], list[int]]]) -> list[Tuple[str, int, list[Tuple[str, int]]]]:\n\n    results = []\n\n    for test in test_cases:\n        n, p1, p2, p3 = test\n\n        t1 = [0]*n\n        t2 = [0]*n\n        t3 = [0]*n\n        t1[p1[n-1]-1] = n\n        t2[p2[n-1]-1] = n\n        t3[p3[n-1]-1] = n\n\n        t1 = SegmentTree(t1)\n        t2 = SegmentTree(t2)\n        t3 = SegmentTree(t3)\n\n        pointers = {}\n        for i in range(n-2,-1,-1):\n            v = t1.query(0,p1[i])\n            if v > 0:\n                pointers[i] = (v-1, 'q')\n                t1[p1[i]-1] = i+1\n                t2[p2[i]-1] = i+1\n                t3[p3[i]-1] = i+1\n            else:\n                v = t2.query(0,p2[i])\n                if v > 0:\n                    pointers[i] = (v-1, 'k')\n                    t1[p1[i]-1] = i+1\n                    t2[p2[i]-1] = i+1\n                    t3[p3[i]-1] = i+1\n                else:\n                    v = t3.query(0,p3[i])\n                    if v > 0:\n                        pointers[i] = (v-1, 'j')\n                        t1[p1[i]-1] = i+1\n                        t2[p2[i]-1] = i+1\n                        t3[p3[i]-1] = i+1\n\n        if 0 in pointers:\n            path = []\n            pointer = 0\n            while pointer != n-1:\n                v, type = pointers[pointer]\n                path.append((type, v+1))\n                pointer = v\n            results.append(('YES', len(path), path))\n\n        else:\n            results.append(('NO', 0, []))\n\n    return results\n",
      "incorrect_solution": "# submission: 335804802\n#  Test: #2, time: 93 ms., memory: 2716 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 216\n# 3\n# 1 2 3\n# 1 2 3\n# 1 2 3\n# 3\n# 1 2 3\n# 1 2 3\n# 1 3 2\n# 3\n# 1 2 3\n# 1 2 3\n# 2 1 3\n# 3\n# 1 2 3\n# 1 2 3\n# 2 3 1\n# 3\n# 1 2 3\n# 1 2 3\n# 3 1 2\n# 3\n# 1 2 3\n# 1 2 3\n# 3 2 1\n# 3\n# 1 2 3\n# 1 3 2\n# 1 2 3\n# 3\n# 1 2 3\n# 1 3 2\n# 1 3 2\n# 3\n# 1 2 3\n# 1 3 2\n# 2 1 3\n# 3\n# 1 2 3\n# 1 3 2\n# 2 3 1\n# 3\n# 1 2 3\n# 1 3 2\n# 3 1 2\n# 3\n# 1 2 3\n# 1 3 2\n# 3 2 1\n# 3\n# 1 2 3\n# 2 1 3\n# 1 2 3\n# 3\n# 1 2 3\n# 2 1 3\n# 1 3 2\n# 3\n# 1 2 3\n# 2 1 3\n# 2 1 3\n# 3\n# 1 2 3\n# 2 1 3\n# 2 3 1\n# 3\n# 1 2 3\n# 2 1 3\n# 3 1 2\n# 3\n# 1 2 3\n# 2 1 3\n# 3 2 1\n# 3\n# 1 2 3\n# 2 3 1\n# 1 2 3\n# 3\n# 1 2 3\n# 2 3 1\n# 1 3 2\n# 3\n# 1 2 3\n# 2 3 1\n# 2 1 3\n# 3\n# ...\n\n# Output\n# NO\n# NO\n# NO\n# NO\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# j 3\n# NO\n# NO\n# YES\n# 2\n# j 2\n# k 3\n# NO\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# k 3\n# NO\n# YES\n# 2\n# k 2\n# j 3\n# NO\n# YES\n# 2\n# k 2\n# j 3\n# YES\n# 1\n# j 3\n# YES\n# 2\n# k 2\n# j 3\n# NO\n# NO\n# YES\n# 2\n# j 2\n# k 3\n# NO\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 2\n# k 2\n# k 3\n# YES\n# 2\n# k 2\n# k 3\n# YES\n# 2\n# k 2\n# k 3\n# YES\n# 2\n# k 2\n# k 3\n# YES\n# 1\n# j 3\n# YES\n# 2\n# k 2\n# k 3\n# NO\n# NO\n# YES\n# 2\n# j 2\n# q 3\n# NO\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# q 3\n# NO\n# NO\n# YES\n# 2\n# j 2\n# q 3\n# ...\n# Answer\n# NO\n# NO\n# NO\n# YES\n# 1\n# j 3\n# YES\n# 1\n# j 3\n# YES\n# 1\n# j 3\n# NO\n# NO\n# YES\n# 2\n# j 2\n# k 3\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# k 3\n# YES\n# 1\n# j 3\n# NO\n# YES\n# 2\n# k 2\n# j 3\n# NO\n# YES\n# 1\n# j 3\n# YES\n# 1\n# j 3\n# YES\n# 1\n# j 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 2\n# j 2\n# k 3\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# k 3\n# YES\n# 1\n# j 3\n# YES\n# 1\n# k 3\n# YES\n# 2\n# k 2\n# j 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# j 3\n# YES\n# 1\n# j 3\n# YES\n# 1\n# j 3\n# YES\n# 1\n# k 3\n# YES\n# 1\n# k 3\n# YES\n# 2\n# j 2\n# k 3\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# k 3\n# YES\n# 1\n# j 3\n# NO\n# NO\n# YES\n# 2\n# j 2\n# q 3\n# YES\n# 1\n# j 3\n# YES\n# 2\n# j 2\n# q 3\n# YES\n# 1\n# j...\n\n# Checker Log\n# wrong answer expected \"YES\", found \"NO\" (test case 4)\n\nfrom collections import deque\n\n\ndef query(tree, l, r):\n    n = len(tree)//2\n    l, r = l+n, r+n\n    res = float('inf')\n    while l < r:\n        if l&1: res = min(res, tree[l]); l += 1\n        if r&1: res = min(res, tree[r-1]); r -= 1\n        l, r = l//2, r//2\n    return res\n\ndef update(tree, idx, value):\n    n = len(tree)//2\n    idx += n\n    tree[idx] = value\n    while idx:\n        tree[idx//2] = min(tree[idx], tree[idx^1])\n        idx //= 2\n\ndef alices_adventures_in_cards(t: int, test_cases: list[Tuple[int, list[int], list[int], list[int]]]) -> list[Tuple[str, int, list[Tuple[str, int]]]]:\n    results = []\n\n    for test in test_cases:\n        n, q, k, j = test\n        g = [[] for _ in range(n)]\n\n        qinv = [0] * n\n        kinv = [0] * n\n        jinv = [0] * n\n\n        for i in range(n):\n            qinv[q[i]-1] = i\n            kinv[k[i]-1] = i\n            jinv[j[i]-1] = i\n\n        inf = float('inf')\n\n        tree = [n] * (2*n)\n        for i in range(n - 1, -1, -1):\n            pref = q[i]\n            while True:\n                s = query(tree, 0, pref-1)\n                if s >= n: break\n                g[i].append((s, 'q'))\n                s_pref = q[s]\n                update(tree, s_pref-1, n)\n            update(tree, pref - 1, i)\n\n        tree = [n] * (2*n)\n        for i in range(n - 1, -1, -1):\n            pref = k[i]\n            while True:\n                s = query(tree, 0, pref-1)\n                if s >= n: break\n                g[i].append((s, 'k'))\n                s_pref = k[s]\n                update(tree, s_pref-1, n)\n            update(tree, pref - 1, i)\n\n        tree = [n] * (2*n)\n        for i in range(n - 1, -1, -1):\n            pref = j[i]\n            while True:\n                s = query(tree, 0, pref-1)\n                if s >= n: break\n                g[i].append((s, 'j'))\n                s_pref = j[s]\n                update(tree, s_pref-1, n)\n            update(tree, pref - 1, i)\n\n        q = deque()\n        vis = [0] * n\n        trace = [0] * n\n\n        q.append(0); vis[0] = 1\n        while q:\n            x = q.popleft()\n            for c,let in g[x]:\n                if vis[c]: continue\n                vis[c] = 1\n                trace[c] = (x, let)\n                q.append(c)\n\n        if vis[n-1]:\n            tr = []\n            x = n-1\n            while x:\n                tr.append(f'{trace[x][1]} {x+1}')\n                x = trace[x][0]\n            results.append(('YES', len(tr), tr[::-1]))\n        else:\n            results.append(('NO', 0, []))\n\n    return results\n"
    }
  },
  {
    "id": "alya_and_permutation",
    "requirements": {
      "signature": "def alya_and_permutation(t: int, n_list: list[int]) -> list[Tuple[int, list[int]]]",
      "description": "Alya has been given a hard problem. Unfortunately, she is too busy running for student council. Please solve this problem for her.\n\nGiven an integer $n$, construct a permutation $p$ of integers $1, 2, \\ldots, n$ that maximizes the value of $k$ (which is initially $0$) after the following process.\n\nPerform $n$ operations, on the $i$-th operation ($i=1, 2, \\dots, n$),\n\n  * If $i$ is odd, $k=k\\,\\&\\,p_i$, where $\\&$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND).    * If $i$ is even, $k=k\\,|\\,p_i$, where $|$ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\n# Input:\nThe first line contains a single integer $t$ ($1\\le t\\le 500$) — the number of test cases.\n\nThe only line of each test case contains a single integer $n$ ($5\\le n\\le 2 \\cdot 10^5$) — the length of the permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output the maximum value of $k$ in the first line and output the permutation $p_1, p_2,\\ldots, p_n$ in the second line.\n\nIf there are multiple such permutations, output any.\n\n# Example input:\n6\n5\n6\n7\n8\n9\n10\n\n# Example output:\n5\n2 1 3 4 5 \n7\n1 2 4 6 5 3 \n7\n2 4 5 1 3 6 7 \n15\n2 4 5 1 3 6 7 8 \n9\n2 4 5 6 7 1 3 8 9 \n15\n1 2 3 4 5 6 8 10 9 7\n\n# Notes:\nFor the first test case, the value of $k$ is determined as follows:\n\n$k = 0$ initially.\n\n  * On the $1$st operation, $1$ is odd, so Alya sets $k$ to be $k\\&p_1 = 0\\&2 = 0$.   * On the $2$nd operation, $2$ is even, so Alya sets $k$ to be $k|p_2 = 0|1 = 1$.   * On the $3$rd operation, $3$ is odd, so Alya sets $k$ to be $k\\&p_3 = 1\\&3 = 1$.   * On the $4$th operation, $4$ is even, so Alya sets $k$ to be $k|p_4 = 1|4 = 5$.   * On the $5$th operation, $5$ is odd, so Alya sets $k$ to be $k\\&p_5 = 5\\&5 = 5$.\n\nThe final value of $k$ is $5$. It can be shown that the final value of $k$ is at most $5$ for all permutations of length $5$. Another valid output is $[2, 3, 1, 4, 5]$.\n\nFor the second test case, the final value of $k$ is $7$. It can be shown that the final value of $k$ is at most $7$ for all permutations of length $6$. Other valid outputs include $[2, 4, 1, 6, 3, 5]$ and $[5, 2, 6, 1, 3, 4]$.\n"
    },
    "judge": "def __judge(t: int, n_list: list[int], results: list[Tuple[int, list[int]]]) -> bool:\n    for (n, result) in zip(n_list, results):\n        max_k, perm = result\n        if len(perm) != n:\n            return False\n        if sorted(perm) != list(range(1, n + 1)):\n            return False\n        k_calculated = 0\n        for i in range(n):\n            if i % 2 == 0: k_calculated &= perm[i]\n            else: k_calculated |= perm[i]\n        if k_calculated != max_k:\n            return False\n        if n % 2 == 1: theoretical = n\n        else:\n            po2 = 1\n            while po2 * 2 <= n: po2 *= 2\n            theoretical = 2 * po2 - 1\n        if not (max_k == theoretical):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [5], alya_and_permutation(1, [5]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [6], alya_and_permutation(1, [6]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [7], alya_and_permutation(1, [7]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [8], alya_and_permutation(1, [8]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [9], alya_and_permutation(1, [9]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [10], alya_and_permutation(1, [10]))"
      }
    ],
    "metadata": {
      "problem_id": "2035C",
      "url": "https://codeforces.com/problemset/problem/2035/C",
      "title": "Alya and Permutation",
      "rating": 1400,
      "tags": [
        "bitmasks",
        "constructive algorithms",
        "math"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 340029129\n# status: accepted\n\nif 1:\n    import sys  \n    #sys.stdout.flush()   #print('.....', flush = True)\n    import random #random.shuffle()\n    #from itertools import *\n    from heapq import *\n    from bisect import bisect_left, bisect_right\n    from collections import Counter, deque, defaultdict\n    input = lambda: sys.stdin.readline().strip()\n    import math\n    inf = math.inf\n    #rdm = random.getrandbits(30)\n    #sys.setrecursionlimit(10000)\n    def I():\n        return input()\n    def II():\n        return int(input())\n    def MII():\n        return map(int, input().split())\n    def LI():\n        return list(input())\n    def LII():\n        return list(map(int, input().split()))\n    def LFI():\n        return list(map(float, input().split()))\n    def LSI():\n        return list(map(str, input().split()))\n    mod = int(1e9 + 7) \n    mod = 998244353\n\ndef alya_and_permutation(t: int, n_list: list[int]) -> list[tuple[int, list[int]]]:\n    results = []\n    for n in n_list:\n        if n % 2:\n            s = [1, 3, n - 1, n]\n            ans = [i for i in range(1, n + 1) if i not in s]\n            ans += s\n            results.append((n, ans))\n        else:\n            tar = (1 << n.bit_length() - 1) - 1\n            if tar == 3:\n                results.append((7, [1, 2, 4, 6, 5, 3]))\n            else:\n                s = [1, 3, tar - 1, tar, n]\n                ans = [i for i in range(1, n + 1) if i not in s]\n                ans += s\n                results.append((tar | n, ans))\n    return results\n",
      "incorrect_solution": "# submission:  336976728\n# Test: #1, time: 62 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 6\n# 5\n# 6\n# 7\n# 8\n# 9\n# 10\n# Output\n# 5\n# 2 3 1 4 5\n# 7\n# 1 2 4 5 6 3\n# 7\n# 2 3 4 5 1 6 7\n# 14\n# 1 2 3 4 5 6 7 8\n# 9\n# 2 3 4 5 6 7 1 8 9\n# 15\n# 1 2 3 4 5 6 8 9 10 7\n# Answer\n# 5\n# 2 1 3 4 5 \n# 7\n# 1 2 4 6 5 3 \n# 7\n# 2 4 5 1 3 6 7 \n# 15\n# 2 4 5 1 3 6 7 8 \n# 9\n# 2 4 5 6 7 1 3 8 9 \n# 15\n# 1 2 3 4 5 6 8 10 9 7 \n# Checker Log\n# wrong answer Jury has better answer 15. (test case 4)\n\n\nimport math\n\ndef alya_and_permutation(t: int, n_list: list[int]) -> list[tuple[int, list[int]]]:\n    results = []\n    for n in n_list:\n        if n&1:\n            if n == 1:\n                results.append((0, [1]))\n            elif n == 3:\n                results.append((2, [1, 2, 3]))\n            else:\n                results.append((n, [s for s in range(2,n-1)]+[1,n-1,n]))\n        else:\n            if 2**int(math.log2(n)) == n:\n                results.append((2*n-2, [s for s in range(1,n+1)]))\n            else:\n                x = 2**(len(bin(n))-3)-1\n                results.append((2**(len(bin(n))-2)-1, [s for s in range(1,x)]+[s for s in range(x+1,n)]+[n,x]))\n    return results\n"
    }
  },
  {
    "id": "and_reconstruction",
    "requirements": {
      "signature": "def and_reconstruction(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[Union[int, list[int]]]",
      "description": "You are given an array $b$ of $n - 1$ integers.\n\null array $a$ of $n$ integers is called good if $b_i = a_i \\, \\& \\, a_{i + 1}$ for $1 \\le i \\le n-1$, where $\\&$ denotes the [bitwise AND operator](https://en.wikipedia.org/wiki/Bitwise_operation#AND).\n\nConstruct a good array, or report that no good arrays exist.\n\n# Input:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$) — the length of the array $a$.\n\nThe second line of each test case contains $n - 1$ integers $b_1, b_2, \\ldots, b_{n - 1}$ ($0 \\le b_i < 2^{30}$) — the elements of the array $b$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n# Output:\nFor each test case, output a single integer $-1$ if no good arrays exist.\n\nOtherwise, output $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^{30}$) — the elements of a good array $a$.\n\nIf there are multiple solutions, you may output any of them.\n\n# Example input:\n4\n2\n1\n3\n2 0\n4\n1 2 3\n5\n3 5 4 2\n\n# Example output:\n5 3\n3 2 1\n-1\n3 7 5 6 3\n\n# Notes:\nIn the first test case, $b = [1]$. A possible good array is $a=[5, 3]$, because $a_1 \\, \\& \\, a_2 = 5 \\, \\& \\, 3 = 1 = b_1$.\n\nIn the second test case, $b = [2, 0]$. A possible good array is $a=[3, 2, 1]$, because $a_1 \\, \\& \\, a_2 = 3 \\, \\& \\, 2 = 2 = b_1$ and $a_2 \\, \\& \\, a_3 = 2 \\, \\& \\, 1 = 0 = b_2$.\n\nIn the third test case, $b = [1, 2, 3]$. It can be shown that no good arrays exist, so the output is $-1$.\n\nIn the fourth test case, $b = [3, 5, 4, 2]$. A possible good array is $a=[3, 7, 5, 6, 3]$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[Tuple[int, list[int]]], results: list[Union[int, list[int]]]) -> bool:\n    for (test, result) in zip(test_cases, results):\n        n, b = test\n        if result == -1:\n            a = []\n            for i in range(n):\n                left = b[i - 1] if i > 0 else 0\n                right = b[i] if i < n - 1 else 0\n                a.append(left | right)\n            good = False\n            for i in range(n - 1):\n                if (a[i] & a[i + 1]) != b[i]:\n                    good = True\n            if not good:\n                return False\n        a = result\n        if len(a) != n:\n            return False\n        if any(x < 0 or x >= 2**30 for x in a):\n            return False\n        # Check AND condition\n        for i in range(n - 1):\n            if a[i] & a[i + 1] != b[i]:\n                return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(2, [1])], and_reconstruction(1, [(2, [1])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, [2, 0])], and_reconstruction(1, [(3, [2, 0])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(4, [1, 2, 3])], and_reconstruction(1, [(4, [1, 2, 3])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(5, [3, 5, 4, 2])], and_reconstruction(1, [(5, [3, 5, 4, 2])]))"
      }
    ],
    "metadata": {
      "problem_id": "1991B",
      "url": "https://codeforces.com/problemset/problem/1991/B",
      "title": "AND Reconstruction",
      "rating": 1100,
      "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 1000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  340077507\n# status: accepted\n\ndef and_reconstruction(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[Union[int, list[int]]]:\n    \"\"\"\n    Solve the Good Array problem.\n    \n    For each test case, we need to construct array a such that:\n    b[i] = a[i] & a[i+1] for all i from 0 to n-2\n    \n    Key insight: \n    - a[i] must contain all bits present in b[i-1] (if exists) and b[i] (if exists)\n    - After constructing a with minimum required bits, we verify if a[i] & a[i+1] = b[i]\n    - If any constraint fails, no solution exists\n    \"\"\"\n    results = []\n    \n    for test in test_cases:\n        n, b = test\n        \n        # Construct array a\n        a = [0] * n\n        \n        # For each position i, a[i] must have all bits from adjacent b values\n        for i in range(n):\n            if i > 0:  # a[i] must contain all bits of b[i-1] for constraint a[i-1] & a[i] = b[i-1]\n                a[i] |= b[i-1]\n            if i < n-1:  # a[i] must contain all bits of b[i] for constraint a[i] & a[i+1] = b[i]\n                a[i] |= b[i]\n        \n        # Verify if the constructed array satisfies all constraints\n        valid = True\n        for i in range(n-1):\n            if (a[i] & a[i+1]) != b[i]:\n                valid = False\n                break\n        \n        if valid:\n            results.append(a)\n        else:\n            results.append(-1)\n\n    return results\n",
      "incorrect_solution": "# submission: 328523171\n#  Test: #1, time: 62 ms., memory: 392 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 4\n# 2\n# 1\n# 3\n# 2 0\n# 4\n# 1 2 3\n# 5\n# 3 5 4 2\n# Output\n# 1073741823 1\n# 1073741823 2 1073741821\n# -1\n# -1\n# Answer\n# 1 1\n# 2 2 0\n# -1\n# 3 7 5 6 2\n# Checker Log\n# wrong answer you marked that no such array a exist, but the jury found a valid array a (test case 4)\n\nimport sys\n\ndef and_reconstruction(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[Union[int, list[int]]]:\n\n    results = []\n    \n    for test in test_cases:\n        n, b = test\n        \n        from collections import defaultdict\n        pos = defaultdict(list)\n        for idx, num in enumerate(b):\n            for m in range(30):\n                if (num >> m) & 1:\n                    pos[m].append(idx)\n        \n        valid = True\n        s_e = {}\n        for m in pos:\n            lst = pos[m]\n            first, last = lst[0], lst[-1]\n            if len(lst) != last - first + 1:\n                valid = False\n                break\n            s_e[m] = (first, last)\n        \n        if not valid:\n            results.append(-1)\n            continue\n        \n        mandatory_bits = [0] * n\n        for m in s_e:\n            s, e = s_e[m]\n            l = max(0, s)\n            r = min(e + 1, n - 1)\n            for i in range(l, r + 1):\n                mandatory_bits[i] |= (1 << m)\n        \n        possible = True\n        for i in range(n - 1):\n            if (mandatory_bits[i] & mandatory_bits[i + 1]) != b[i]:\n                possible = False\n                break\n        \n        if not possible:\n            results.append(-1)\n            continue\n        \n        opt_mask = 0\n        for m in range(30):\n            found = False\n            for i in range(n):\n                if (mandatory_bits[i] >> m) & 1:\n                    found = True\n                    break\n            if not found:\n                opt_mask |= (1 << m)\n        \n        a = []\n        for i in range(n):\n            val = mandatory_bits[i]\n            if i % 2 == 0:\n                val |= opt_mask\n            a.append(str(val))\n\n                        \n        results.append(a)\n\n    return results\n"
    }
  },
  {
    "id": "binary_colouring",
    "requirements": {
      "signature": "def binary_colouring(t: int, test_cases: list[int]) -> list[tuple[int, list[int]]]",
      "description": "You are given a positive integer $x$. Find any array of integers $a_0, a_1, \\ldots, a_{n-1}$ for which the following holds:\n\n  * $1 \\le n \\le 32$,    * $a_i$ is $1$, $0$, or $-1$ for all $0 \\le i \\le n - 1$,    * $x = \\displaystyle{\\sum_{i=0}^{n - 1}{a_i \\cdot 2^i}}$,    * There does not exist an index $0 \\le i \\le n - 2$ such that both $a_{i} \\neq 0$ and $a_{i + 1} \\neq 0$. \n\nIt can be proven that under the constraints of the problem, a valid array always exists.\n\n# Input:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains a single positive integer $x$ ($1 \\le x < 2^{30}$).\n\n# Output:\nFor each test case, output two lines.\n\nOn the first line, output an integer $n$ ($1 \\le n \\le 32$) — the length of the array $a_0, a_1, \\ldots, a_{n-1}$.\n\nOn the second line, output the array $a_0, a_1, \\ldots, a_{n-1}$.\n\nIf there are multiple valid arrays, you can output any of them.\n\n# Example input:\n7\n1\n14\n24\n15\n27\n11\n19\n\n# Example output:\n1\n1\n5\n0 -1 0 0 1\n6\n0 0 0 -1 0 1\n5\n-1 0 0 0 1\n6\n-1 0 -1 0 0 1\n5\n-1 0 -1 0 1\n5\n-1 0 1 0 1\n\n# Notes:\nIn the first test case, one valid array is $[1]$, since $(1) \\cdot 2^0 = 1$.\n\nIn the second test case, one possible valid array is $[0,-1,0,0,1]$, since $(0) \\cdot 2^0 + (-1) \\cdot 2^1 + (0) \\cdot 2^2 + (0) \\cdot 2^3 + (1) \\cdot 2^4 = -2 + 16 = 14$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int], results: list[tuple[int, list[int]]]) -> bool:\n    for (test, result) in zip(test_cases, results):\n        n, a = result\n        x = test\n        if not (1 <= n <= 32):\n            return False\n        if len(a) != n:\n            return False\n        # Check each element is -1, 0, or 1\n        for val in a:\n            if val not in [-1, 0, 1]:\n                return False\n        # Check sum equals x\n        total = sum(a[i] * (2 ** i) for i in range(n))\n        if total != x:\n            return False\n        # Check no consecutive non-zero elements\n        for i in range(n - 1):\n            if a[i] != 0 and a[i + 1] != 0:\n                return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [1], binary_colouring(1, [1]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [14], binary_colouring(1, [14]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [24], binary_colouring(1, [24]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [15], binary_colouring(1, [15]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [27], binary_colouring(1, [27]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [11], binary_colouring(1, [11]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_7():\n    assert __judge(1, [19], binary_colouring(1, [19]))"
      }
    ],
    "metadata": {
      "problem_id": "1977B",
      "url": "https://codeforces.com/problemset/problem/1977/B",
      "title": "Binary Colouring",
      "rating": 1100,
      "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy",
        "math"
      ],
      "div": "Div. 2",
      "time_limit_ms": 1000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  342858365\n# status: accepted\n\ndef setValue(index,value,v):\n    if index >= len(v):\n        v.append(value)\n    else :\n        v[index] = value \n\ndef binary_colouring(t: int, test_cases: list[int]) -> list[tuple[int, list[int]]]:\n    results = []\n    for test in test_cases:\n        n = test\n        bin_list = []\n        while n > 0 :\n            r = n % 2 \n            n //= 2\n            bin_list.append(r)\n        i = 0 \n        while i < len(bin_list) - 1:\n            if bin_list[i] == 1 and bin_list[i+1]==1:\n                index = i\n                while index < len(bin_list) and bin_list[index] == 1:\n                    index += 1 \n                index -= 1\n                setValue(i,-1,bin_list)\n                j = i + 1\n                while j <= index:\n                    setValue(j,0,bin_list)\n                    j +=1\n                setValue(index+1,1,bin_list)\n                i = index - 1\n            i+=1\n        results.append((len(bin_list), bin_list))\n    return results\n",
      "incorrect_solution": "# submission: 328337933\n\n# Test: #1, time: 108 ms., memory: 3248 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 7\n# 1\n# 14\n# 24\n# 15\n# 27\n# 11\n# 19\n# Output\n# 32\n# 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n# 32\n# 0 -1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n# 32\n# 0 0 0 -1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n# 32\n# -1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n# 32\n# -1 0 1 -1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n# 32\n# -1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n# 32\n# -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n# Answer\n# 31\n# 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n# 31\n# 0 -1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n# 31\n# 0 0 0 -1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n# 31\n# -1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n# 31\n# -1 0 -1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n# 31\n# -1 0 -1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n# 31\n# -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n# Checker Log\n# wrong answer wrong coefficient format (test case 5)\n\n\nimport sys\nimport string\nimport math\nimport array\nimport bisect\nimport os\n#import random\nimport heapq\nfrom io import BytesIO, IOBase\nfrom heapq import heappop,heappush\nfrom functools import lru_cache,cache\nfrom collections import deque,defaultdict,Counter,OrderedDict\nfrom itertools import permutations,combinations\n\nINF = float('inf')\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = sys.stdin.buffer.readline\n\nprintf = lambda x:sys.stdout.write(str(x)+' ')\nprinta = lambda x:sys.stdout.write('ans:'+str(x)+'\\n')\nprintt = lambda *x:print('test:',*x)\nask = lambda *x:print('?',*x,flush=True)\nreply = lambda *x:print('!',*x,flush=True)\n\nRI = lambda: int(sys.stdin.readline())\nRF = lambda: float(sys.stdin.readline())\nRS = lambda: sys.stdin.readline().strip()\nRFF = lambda: map(float, sys.stdin.readline().split())\nRII = lambda: map(int, sys.stdin.readline().split())\nRSS = lambda: map(str, sys.stdin.readline().strip().split())\nRIL = lambda: list(RII())\nRFL = lambda: list(RFF())\nRSL = lambda: list(RSS())\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ndef binary_colouring(t: int, test_cases: list[int]) -> list[tuple[int, list[int]]]:\n    results = []\n    for test in test_cases:\n        x = test\n        a = [0]*32\n        for j in range(32):\n            if x>>j&1==1:\n                a[j] = 1\n        j = 0\n        while j<=31:\n            if a[j]==1 and a[j+1]==1:\n                a[j] = -1\n                j += 1\n                while j<=31 and a[j]==1:\n                    a[j] = 0\n                    j += 1\n                a[j] = 1\n            j += 1\n        results.append((32, a))\n    return results\n"
    }
  },
  {
    "id": "choose_your_queries",
    "requirements": {
      "signature": "def choose_your_queries(n: int, q: int, queries: list[tuple[int, int]]) -> list[str]",
      "description": "You are given an array $a$, consisting of $n$ integers (numbered from $1$ to $n$). Initially, they are all zeroes.\n\nYou have to process $q$ queries. The $i$-th query consists of two different integers $x_i$ and $y_i$. During the $i$-th query, you have to choose an integer $p$ (which is either $x_i$ or $y_i$) and an integer $d$ (which is either $1$ or $-1$), and assign $a_p = a_p + d$.\n\nAfter each query, every element of $a$ should be a non-negative integer.\n\nProcess all queries in such a way that the sum of all elements of $a$ after the last query is the minimum possible.\n\n# Input:\nThe first line contains two integers $n$ and $q$ ($2 \\le n \\le 3 \\cdot 10^5$; $1 \\le q \\le 3 \\cdot 10^5$) — the number of elements in $a$ and the number of queries, respectively.\n\nThen $q$ lines follow. The $i$-th of these lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le n$; $x_i \\ne y_i$) — the description of the $i$-th query.\n\n# Output:\nFor each query, print a line containing two characters:\n\n  * the first character should be x if you choose $p=x_i$, or y if you choose $p=y_i$;    * the second character should be + if you choose $d=1$, or - if you choose $d=-1$. \n\nIf there are multiple answers, print any of them.\n\n# Example input:\n3 4\n1 2\n3 2\n3 1\n1 2\n\n# Example output:\ny+\nx+\nx-\ny-\n\n# Notes:\n\n"
    },
    "judge": "def __judge(n: int, q: int, queries: list[tuple[int, int]], result: list[str]) -> bool:\n    if len(result) != len(queries):\n        return False\n    a = [0] * n\n    for i, (x, y) in enumerate(queries):\n        choice = result[i]\n        if choice not in ['x+', 'x-', 'y+', 'y-']:\n            return False\n        p = x - 1 if choice[0] == 'x' else y - 1\n        delta = 1 if choice[1] == '+' else -1\n        a[p] += delta\n        if a[p] < 0:\n            return False\n    actual_sum = sum(a)\n    parent = list(range(n))\n    rank = [0] * n\n    for x, y in queries:\n        u = x - 1\n        v = y - 1\n        root_u = u\n        while parent[root_u] != root_u:\n            parent[root_u] = parent[parent[root_u]]\n            root_u = parent[root_u]\n        root_v = v\n        while parent[root_v] != root_v:\n            parent[root_v] = parent[parent[root_v]]\n            root_v = parent[root_v]\n        if root_u != root_v:\n            if rank[root_u] > rank[root_v]:\n                parent[root_v] = root_u\n            else:\n                parent[root_u] = root_v\n                if rank[root_u] == rank[root_v]:\n                    rank[root_v] += 1\n    counts = {}\n    for x, y in queries:\n        u = x - 1\n        v = y - 1\n        root_u = u\n        while parent[root_u] != root_u:\n            root_u = parent[root_u]\n        counts[root_u] = counts.get(root_u, 0) + 1\n    S = 0\n    for cnt in counts.values():\n        if cnt % 2 == 1:\n            S += 1\n    return actual_sum == S\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(3, 4, [(1, 2), (3, 2), (3, 1), (1, 2)], choose_your_queries(3, 4, [(1, 2), (3, 2), (3, 1), (1, 2)]))"
      }
    ],
    "metadata": {
      "problem_id": "2025F",
      "url": "https://codeforces.com/problemset/problem/2025/F",
      "title": "Choose Your Queries",
      "rating": 2700,
      "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "trees"
      ],
      "div": "Div. 2",
      "time_limit_ms": 3000,
      "memory_limit_mb": 512,
      "correct_solution": "# submission: 330981117\n# status: accepted\n# C++20 (GCC 13-64)\n\nCPP_SOLUTION=r\"\"\"\n#include <bits/stdc++.h>\n\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n \n#define threesum cin.tie(NULL); cout.tie(NULL); ios_base::sync_with_stdio(false)\n#define all(a) a.begin(), a.end()\n#define F first\n#define S second\n#define int long long\n#define pii pair<int, int>\n#define ppp pair<int, pii>\n#define dout cout << fixed << setprecision(15)\n#define mid ((l + r) >> 1)\n#define lc (id << 1)\n#define rc (lc + 1)\n\nmt19937 rng(chrono::steady_clock().now().time_since_epoch().count());\n\nconst int maxn = 1e6 + 10, maxm = 5e2 + 10, oo = 1e18 + 10, lg = 23, sq = 30, mod = 1e9 + 7;\n\nint n, m, h[maxn], p[maxn], ans[maxn], a[maxn];\n\nbool seen[maxn];\n\npii e[maxn];\n\nvector<pii> adj[maxn];\n\nvoid add(int v, int id){\n    ans[id] = v;\n    p[v] ^= 1;\n}\n\nvoid dfs(int v){\n    seen[v] = 1;\n    for(auto [u, i] : adj[v])\n        if(!seen[u]){\n            h[u] = h[v] + 1;\n            dfs(u);\n        }\n\n    for(auto [u, i] : adj[v])\n        if(h[v] < h[u])\n            add((p[u] ? u : v), i);\n}\n\nvoid q(int i){\n    if(ans[i] == e[i].F)\n        cout << \"x\";\n    else\n        cout << \"y\";\n\n    if(p[ans[i]])\n        cout << \"-\\n\";\n    else\n        cout << \"+\\n\";\n\n    p[ans[i]] ^= 1;\n}\n\nvoid solve()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= m;i++){\n        int u, v;\n        cin >> u >> v;\n        e[i] = {u, v};\n        adj[u].push_back({v, i});\n        adj[v].push_back({u, i});\n    }\n\n    for (int v = 1; v <= n;v++)\n        if(!seen[v])\n            dfs(v);\n\n    for (int v = 1; v <= n;v++)\n        p[v] = 0;\n\n    for (int i = 1; i <= m;i++)\n        q(i);\n}\n\nsigned main()\n{\n    threesum;\n\n    int t = 1;\n    //cin >> t;\n    while(t--)\n        solve();\n}\n\"\"\"\n\nimport tempfile\nimport subprocess\nimport os\nfrom typing import List, Tuple\n\ndef choose_your_queries(n: int, q: int, queries: List[Tuple[int, int]]) -> List[str]:\n    # Prepare input text according to the problem statement\n    lines = [f\"{n} {q}\"]\n    for x, y in queries:\n        lines.append(f\"{x} {y}\")\n    input_text = \"\\n\".join(lines) + \"\\n\"\n\n    # Work in a temporary directory\n    with tempfile.TemporaryDirectory() as tmpdir:\n        cpp_path = os.path.join(tmpdir, \"main.cpp\")\n        exe_path = os.path.join(tmpdir, \"a.out\")\n\n        # Write the C++ solution source\n        try:\n            with open(cpp_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(CPP_SOLUTION)\n        except Exception as e:\n            raise RuntimeError(f\"Failed to write C++ source: {e}\")\n\n        # Compile with g++\n        compile_cmd = [\n            \"g++\",\n            \"-O2\",\n            \"-pipe\",\n            \"-s\",\n            cpp_path,\n            \"-o\",\n            exe_path,\n        ]\n        try:\n            comp = subprocess.run(\n                compile_cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                check=False,\n            )\n        except FileNotFoundError:\n            raise RuntimeError(\"g++ not found. Please ensure g++ is installed and on PATH.\")\n        except Exception as e:\n            raise RuntimeError(f\"Compilation failed to start: {e}\")\n\n        if comp.returncode != 0:\n            raise RuntimeError(f\"Compilation error:\\nSTDOUT:\\n{comp.stdout}\\nSTDERR:\\n{comp.stderr}\")\n\n        # Execute with input and timeout\n        try:\n            run = subprocess.run(\n                [exe_path],\n                input=input_text,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                timeout=2.0,\n                check=False,\n            )\n        except subprocess.TimeoutExpired:\n            raise TimeoutError(\"Execution timed out after 2 seconds.\")\n        except Exception as e:\n            raise RuntimeError(f\"Execution failed to start: {e}\")\n\n        if run.returncode != 0:\n            raise RuntimeError(f\"Runtime error (exit code {run.returncode}):\\nSTDOUT:\\n{run.stdout}\\nSTDERR:\\n{run.stderr}\")\n\n        # Parse output: expect q lines, each like 'x+', 'y-', etc.\n        out_lines = [line.strip() for line in run.stdout.splitlines() if line.strip()]\n\n        if len(out_lines) != q:\n            # Some solutions may print extra whitespace or messages; try to filter valid tokens\n            filtered = [ln for ln in out_lines if len(ln) == 2 and ln[0] in (\"x\", \"y\") and ln[1] in (\"+\", \"-\")]\n            if len(filtered) != q:\n                raise ValueError(f\"Expected {q} answer lines, got {len(out_lines)}. Parsed valid tokens: {len(filtered)}.\\nOutput:\\n{run.stdout}\")\n            out_lines = filtered\n        else:\n            # Validate format\n            for ln in out_lines:\n                if len(ln) != 2 or ln[0] not in (\"x\", \"y\") or ln[1] not in (\"+\", \"-\"):\n                    raise ValueError(f\"Invalid output line format: '{ln}'\")\n\n        return out_lines\n",
      "incorrect_solution": "# submission: 336682739\n\n#  Test: #4, time: 62 ms., memory: 84 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 1000 1000\n# 944 844\n# 514 113\n# 733 613\n# 358 918\n# 393 558\n# 949 748\n# 971 16\n# 9 990\n# 996 989\n# 541 208\n# 899 350\n# 323 670\n# 84 493\n# 446 227\n# 180 403\n# 536 554\n# 919 67\n# 333 457\n# 483 925\n# 590 465\n# 346 172\n# 896 159\n# 204 312\n# 922 510\n# 394 957\n# 91 139\n# 236 163\n# 153 688\n# 821 284\n# 850 369\n# 993 752\n# 695 626\n# 110 844\n# 372 263\n# 424 134\n# 282 378\n# 539 83\n# 686 88\n# 157 706\n# 695 812\n# 680 935\n# 395 507\n# 197 369\n# 754 911\n# 188 299\n# 866 973\n# 414 839\n# 642 814\n# 675 758\n# 423 825\n# 500 89\n# 905 407\n# 810 116\n# 63 566\n# 444 461\n# 903 279\n# 894 20...\n# Output\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y-\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y-\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# x-\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y-\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y-\n# y+\n# y-\n# y+\n# y+\n# y+\n# y+\n# x-\n# y+\n# y+\n# y+\n# y-\n# y+\n# x-\n# y+\n# y+\n# y+\n# y+\n# x-\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# x-\n# y+\n# y-\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# x-\n# y+\n# y+\n# y+\n# y+\n# ...\n# Answer\n# y+\n# x+\n# y+\n# y+\n# x+\n# y+\n# y+\n# y+\n# y+\n# y+\n# x+\n# y+\n# x+\n# x+\n# x+\n# x+\n# y+\n# x+\n# x+\n# y+\n# x+\n# y+\n# x+\n# y+\n# y+\n# x+\n# x+\n# y+\n# y+\n# x+\n# x+\n# y+\n# y-\n# x+\n# y+\n# x+\n# y+\n# y+\n# y+\n# x+\n# x+\n# x+\n# x+\n# y+\n# y+\n# x+\n# y+\n# x+\n# x+\n# y+\n# x+\n# x+\n# x+\n# x+\n# y+\n# x+\n# y+\n# x+\n# y+\n# x+\n# x+\n# y+\n# x+\n# y+\n# x+\n# y+\n# y+\n# y+\n# x+\n# x+\n# x+\n# y+\n# x+\n# y-\n# y+\n# x+\n# x+\n# x+\n# y+\n# x+\n# y+\n# y+\n# x+\n# y+\n# x+\n# x+\n# x+\n# y+\n# y+\n# x+\n# y+\n# y+\n# y+\n# y+\n# x+\n# y+\n# y+\n# x+\n# y+\n# y+\n# x+\n# y+\n# x+\n# x-\n# x+\n# y+\n# x+\n# x+\n# x+\n# y+\n# y+\n# x+\n# y+\n# x+\n# x+\n# y-\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# y+\n# x+\n# x+\n# x+\n# x-\n# x+\n# ...\n\n# Checker Log\n# wrong answer jury has better answer\n\n\nimport sys\n\ndef choose_your_queries(n: int, q: int, queries: list[tuple[int, int]]) -> list[str]:\n    a = [0] * (n + 1)\n    current_sum = 0\n\n    results = []\n    \n    for i in range(q):\n        x, y = queries[i]\n        if i < q - 1:\n            if (a[x] > 0 or a[y] > 0) and current_sum >= 2:\n                if a[x] > 0 and a[y] > 0:\n                    if a[x] >= a[y]:\n                        results.append(\"x-\")\n                        a[x] -= 1\n                        current_sum -= 1\n                    else:\n                        results.append(\"y-\")\n                        a[y] -= 1\n                        current_sum -= 1\n                elif a[x] > 0:\n                    results.append(\"x-\")\n                    a[x] -= 1\n                    current_sum -= 1\n                else:\n                    results.append(\"y-\")\n                    a[y] -= 1\n                    current_sum -= 1\n            else:\n                if a[x] < a[y]:\n                    results.append(\"x+\")\n                    a[x] += 1\n                    current_sum += 1\n                elif a[y] < a[x]:\n                    results.append(\"y+\")\n                    a[y] += 1\n                    current_sum += 1\n                else:\n                    results.append(\"y+\")\n                    a[y] += 1\n                    current_sum += 1\n        else:\n            if a[x] > 0 and a[y] > 0:\n                if a[x] >= a[y]:\n                    results.append(\"x-\")\n                    a[x] -= 1\n                    current_sum -= 1\n                else:\n                    results.append(\"y-\")\n                    a[y] -= 1\n                    current_sum -= 1\n            elif a[x] > 0:\n                results.append(\"x-\")\n                a[x] -= 1\n                current_sum -= 1\n            elif a[y] > 0:\n                results.append(\"y-\")\n                a[y] -= 1\n                current_sum -= 1\n            else:\n                results.append(\"x+\")\n                a[x] += 1\n                current_sum += 1\n    return results\n"
    }
  },
  {
    "id": "common_generator",
    "requirements": {
      "signature": "def common_generator(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[int]",
      "description": "For two integers $x$ and $y$ ($x,y\\ge 2$), we will say that $x$ is a generator of $y$ if and only if $x$ can be transformed to $y$ by performing the following operation some number of times (possibly zero):\n\n  * Choose a divisor $d$ ($d\\ge 2$) of $x$, then increase $x$ by $d$. \n\nFor example,\n\n  * $3$ is a generator of $8$ since we can perform the following operations: $3 \\xrightarrow{d = 3} 6 \\xrightarrow{d = 2} 8$;    * $4$ is a generator of $10$ since we can perform the following operations: $4 \\xrightarrow{d = 4} 8 \\xrightarrow{d = 2} 10$;    * $5$ is not a generator of $6$ since we cannot transform $5$ into $6$ with the operation above. \n\nNow, Kevin gives you an array $a$ consisting of $n$ pairwise distinct integers ($a_i\\ge 2$).\n\nYou have to find an integer $x\\ge 2$ such that for each $1\\le i\\le n$, $x$ is a generator of $a_i$, or determine that such an integer does not exist.\n\n# Input:\nEach test contains multiple test cases. The first line of the input contains a single integer $t$ ($1\\le t\\le 10^4$) — the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1\\le n\\le 10^5$) — the length of the array $a$.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($2\\le a_i\\le 4\\cdot 10^5$) — the elements in the array $a$. It is guaranteed that the elements are pairwise distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n# Output:\nFor each test case, output a single integer $x$ — the integer you found. Print $-1$ if there does not exist a valid $x$.\n\nIf there are multiple answers, you may output any of them.\n\n# Example input:\n4\n3\n8 9 10\n4\n2 3 4 5\n2\n147 154\n5\n3 6 8 25 100000\n\n# Example output:\n2\n-1\n7\n3\n\n# Notes:\nIn the first test case, for $x=2$:\n\n  * $2$ is a generator of $8$, since we can perform the following operations: $2 \\xrightarrow{d = 2} 4 \\xrightarrow{d = 4} 8$;    * $2$ is a generator of $9$, since we can perform the following operations: $2 \\xrightarrow{d = 2} 4 \\xrightarrow{d = 2} 6 \\xrightarrow{d = 3} 9$.    * $2$ is a generator of $10$, since we can perform the following operations: $2 \\xrightarrow{d = 2} 4 \\xrightarrow{d = 2} 6 \\xrightarrow{d = 2} 8 \\xrightarrow{d = 2} 10$. \n\nIn the second test case, it can be proven that it is impossible to find a common generator of the four integers.\n"
    },
    "judge": "def __judge(t, test_cases: list[Tuple[int, list[int]]], results: list[int]) -> bool:\n    for ((n, a), x) in zip(test_cases, results):\n        if x < 2:\n            return False\n        if any(y < x for y in a):\n            return False\n        max_v = max(a)\n        spf = [0] * (max_v + 1)\n        for i in range(2, max_v + 1):\n            if spf[i] == 0:\n                spf[i] = i\n                ii = i * i\n                if ii <= max_v:\n                    for j in range(ii, max_v + 1, i):\n                        if spf[j] == 0:\n                            spf[j] = i\n        from collections import deque\n        visited = [False] * (max_v + 1)\n        q = deque([x])\n        visited[x] = True\n        def gen_divisors(val):\n            res = [1]\n            v = val\n            while v > 1:\n                p = spf[v]\n                if p == 0:\n                    p = v\n                cnt = 0\n                while v % p == 0:\n                    v //= p\n                    cnt += 1\n                cur = []\n                powp = 1\n                for _ in range(cnt + 1):\n                    for r in res:\n                        cur.append(r * powp)\n                    powp *= p\n                res = cur\n            for d in res:\n                if d >= 2:\n                    yield d\n        while q:\n            v = q.popleft()\n            for d in gen_divisors(v):\n                nv = v + d\n                if nv <= max_v and not visited[nv]:\n                    visited[nv] = True\n                    q.append(nv)\n        for y in a:\n            if not visited[y]:\n                return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, [8, 9, 10])], common_generator(1, [(3, [8, 9, 10])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(4, [2, 3, 4, 5])], common_generator(1, [(4, [2, 3, 4, 5])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(2, [147, 154])], common_generator(1, [(2, [147, 154])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(5, [3, 6, 8, 25, 100000])], common_generator(1, [(5, [3, 6, 8, 25, 100000])]))"
      }
    ],
    "metadata": {
      "problem_id": "2029E",
      "url": "https://codeforces.com/problemset/problem/2029/E",
      "title": "Common Generator",
      "rating": 2100,
      "tags": [
        "brute force",
        "math",
        "number theory"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 512,
      "correct_solution": "# submission: 339678899\n# status: accepted\n\nfrom sys import stdin, stdout\n\ndef common_generator(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[int]:\n\n    results = []\n\n    primes = set()\n\n    # each entry of sieve contains a prime divisor\n    sieve = [i for i in range (400001)]\n    for i in range(2,400001): # this range can be stopped at the square root if you only need a prime divisor\n        if sieve[i] == i:\n            primes.add(i)\n            j = i\n            while i*j <= 400000:\n                sieve[i*j] = i\n                j += 1\n\n    for test in test_cases:\n        n, a = test\n\n        if n == 1:\n            answer = a[0]\n\n        else:\n            smallest_entry = min(a)\n            largest_prime = -1\n            for i in range(n):\n                if a[i] in primes:\n                    largest_prime = max(largest_prime, a[i])\n\n            if largest_prime > smallest_entry:\n                answer = -1\n            elif largest_prime == -1:\n                answer = 2\n            else:\n                survive = True\n                for i in range(n):\n                    if a[i] == largest_prime:\n                        pass\n                    elif a[i] < 2*largest_prime:\n                        survive = False\n                        break\n                    elif a[i] % 2 == 0:\n                        pass\n                    else:\n                        k = a[i]\n                        smallest_factor = 40001\n                        while k != 1:\n                            smallest_factor = min(smallest_factor, sieve[k])\n                            k = k//sieve[k]\n\n                        if a[i] - smallest_factor < 2*largest_prime:\n                            survive = False\n                            break\n\n                if survive:\n                    answer = largest_prime\n                else:\n                    answer = -1\n\n        results.append(answer)\n    return results\n\n",
      "incorrect_solution": "# submission:  339678431\n\n#  Test: #2, time: 124 ms., memory: 8472 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 10000\n# 1\n# 2\n# 1\n# 3\n# 1\n# 4\n# 1\n# 5\n# 1\n# 6\n# 1\n# 7\n# 1\n# 8\n# 1\n# 9\n# 1\n# 10\n# 1\n# 11\n# 1\n# 12\n# 1\n# 13\n# 1\n# 14\n# 1\n# 15\n# 2\n# 2 3\n# 2\n# 2 4\n# 2\n# 2 5\n# 2\n# 2 6\n# 2\n# 2 7\n# 2\n# 2 8\n# 2\n# 2 9\n# 2\n# 2 10\n# 2\n# 2 11\n# 2\n# 2 12\n# 2\n# 2 13\n# 2\n# 2 14\n# 2\n# 2 15\n# 2\n# 3 4\n# 2\n# 3 5\n# 2\n# 3 6\n# 2\n# 3 7\n# 2\n# 3 8\n# 2\n# 3 9\n# 2\n# 3 10\n# 2\n# 3 11\n# 2\n# 3 12\n# 2\n# 3 13\n# 2\n# 3 14\n# 2\n# 3 15\n# 2\n# 4 5\n# 2\n# 4 6\n# 2\n# 4 7\n# 2\n# 4 8\n# 2\n# 4 9\n# 2\n# 4 10\n# 2\n# 4 11\n# 2\n# 4 12\n# 2\n# 4 13\n# 2\n# 4 14\n# 2\n# 4 15\n# 2\n# 5 6\n# 2\n# 5 7\n# 2\n# 5 8\n# 2\n# 5 9\n# 2\n# 5 10\n# 2\n# 5 11\n# 2\n# 5 12\n# 2\n# 5 13\n# 2\n# 5 14\n# 2\n# 5 15\n# 2\n# 6 7\n# 2\n# 6 8\n# 2\n# 6 9...\n# Output\n# 2\n# 3\n# 4\n# 5\n# 6\n# 7\n# 8\n# 9\n# 10\n# 11\n# 12\n# 13\n# 14\n# 15\n# -1\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 3\n# -1\n# 3\n# -1\n# 3\n# 3\n# 3\n# -1\n# 3\n# -1\n# 3\n# 3\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 5\n# -1\n# 5\n# -1\n# 5\n# -1\n# 5\n# -1\n# 5\n# 5\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 7\n# -1\n# 7\n# -1\n# 7\n# -1\n# 7\n# -1\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 11\n# -1\n# 11\n# -1\n# -1\n# 2\n# 2\n# 13\n# -1\n# 2\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2...\n# Answer\n# 2\n# 3\n# 2\n# 5\n# 2\n# 7\n# 2\n# 2\n# 2\n# 11\n# 2\n# 13\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# -1\n# 3\n# -1\n# 3\n# 3\n# 3\n# -1\n# 3\n# -1\n# 3\n# 3\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# -1\n# -1\n# -1\n# 5\n# -1\n# 5\n# -1\n# 5\n# 5\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 7\n# -1\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# -1\n# -1\n# -1\n# -1\n# 2\n# 2\n# -1\n# -1\n# 2\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 2\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# 2\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 2\n# 2\n# 2\n# -1\n# 2\n# -1\n# 2\n# Checker Log\n# wrong answer 3 cannot generator 4. :( (test case 28)\n\n\n\nfrom sys import stdin, stdout\n\n\ndef common_generator(t: int, test_cases: list[Tuple[int, list[int]]]) -> list[int]:\n\n    results = []\n\n    primes = set()\n\n    # each entry of sieve contains a prime divisor\n    sieve = [i for i in range (400001)]\n    for i in range(2,400001): # this range can be stopped at the square root if you only need a prime divisor\n        if sieve[i] == i:\n            primes.add(i)\n            j = i\n            while i*j <= 400000:\n                sieve[i*j] = i\n                j += 1\n\n    for test in test_cases:\n        n, a = test\n\n        if n == 1:\n            answer = a[0]\n\n        else:\n            smallest_entry = min(a)\n            largest_prime = -1\n            for i in range(n):\n                if a[i] in primes:\n                    largest_prime = max(largest_prime, a[i])\n\n            if largest_prime > smallest_entry:\n                answer = -1\n            elif largest_prime == -1:\n                answer = 2\n            else:\n                survive = True\n                for i in range(n):\n                    if a[i] % 2 == 0 or a[i] == largest_prime:\n                        pass\n                    else:\n                        k = a[i]\n                        smallest_factor = 40001\n                        while k != 1:\n                            smallest_factor = min(smallest_factor, sieve[k])\n                            k = k//sieve[k]\n\n                        if a[i] - smallest_factor < 2*largest_prime:\n                            survive = False\n                            break\n\n                if survive:\n                    answer = largest_prime\n                else:\n                    answer = -1\n\n        results.append(answer)\n    return results\n\n"
    }
  },
  {
    "id": "concatenation_of_arrays",
    "requirements": {
      "signature": "def concatenation_of_arrays(t: int, test_cases: list[tuple[int,list[tuple[int, int]]]]) -> list[list[int]]",
      "description": "You are given $n$ arrays $a_1$, $\\ldots$, $a_n$. The length of each array is two. Thus, $a_i = [a_{i, 1}, a_{i, 2}]$. You need to concatenate the arrays into a single array of length $2n$ such that the number of inversions$^{\\dagger}$ in the resulting array is minimized. Note that you do not need to count the actual number of inversions.\n\nMore formally, you need to choose a permutation$^{\\ddagger}$ $p$ of length $n$, so that the array $b = [a_{p_1,1}, a_{p_1,2}, a_{p_2, 1}, a_{p_2, 2}, \\ldots, a_{p_n,1}, a_{p_n,2}]$ contains as few inversions as possible.\n\n$^{\\dagger}$The number of inversions in an array $c$ is the number of pairs of indices $i$ and $j$ such that $i < j$ and $c_i > c_j$.\n\n$^{\\ddagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n# Input:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of arrays.\n\nEach of the following $n$ lines contains two integers $a_{i,1}$ and $a_{i,2}$ ($1 \\le a_{i,j} \\le 10^9$) — the elements of the $i$-th array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n# Output:\nFor each test case, output $2n$ integers — the elements of the array you obtained. If there are multiple solutions, output any of them.\n\n# Example input:\n4\n2\n1 4\n2 3\n3\n3 2\n4 3\n2 1\n5\n5 10\n2 3\n9 6\n4 1\n8 7\n1\n10 20\n\n# Example output:\n2 3 1 4\n2 1 3 2 4 3\n4 1 2 3 5 10 8 7 9 6\n10 20\n\n# Notes:\nIn the first test case, we concatenated the arrays in the order $2, 1$. Let's consider the inversions in the resulting array $b = [2, 3, 1, 4]$:\n\n  * $i = 1$, $j = 3$, since $b_1 = 2 > 1 = b_3$;   * $i = 2$, $j = 3$, since $b_2 = 3 > 1 = b_3$. \n\nThus, the number of inversions is $2$. It can be proven that this is the minimum possible number of inversions.\n\nIn the second test case, we concatenated the arrays in the order $3, 1, 2$. Let's consider the inversions in the resulting array $b = [2, 1, 3, 2, 4, 3]$:\n\n  * $i = 1$, $j = 2$, since $b_1 = 2 > 1 = b_2$;   * $i = 3$, $j = 4$, since $b_3 = 3 > 2 = b_4$;   * $i = 5$, $j = 6$, since $b_5 = 4 > 3 = b_6$. \n\nThus, the number of inversions is $3$. It can be proven that this is the minimum possible number of inversions.\n\nIn the third test case, we concatenated the arrays in the order $4, 2, 1, 5, 3$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int,list[tuple[int, int]]]], results: list[list[int]]) -> bool:\n    for (test, result) in zip(test_cases, results):\n        n, arrays = test\n        if len(result) != 2 * n:\n            return False\n        from collections import Counter\n        arr_counter = Counter(arrays)\n        for i in range(0, 2 * n, 2):\n            pair = (result[i], result[i+1])\n            if pair not in arr_counter or arr_counter[pair] == 0:\n                return False\n            arr_counter[pair] -= 1\n        if any(v != 0 for v in arr_counter.values()):\n            return False\n        def count_inversions(arr: list[int]) -> int:\n            if not arr:\n                return 0\n            vals = sorted(set(arr))\n            rank = {v: i+1 for i, v in enumerate(vals)}\n            size = len(vals)\n            bit = [0] * (size + 1)\n            def bit_add(i: int, delta: int) -> None:\n                while i <= size:\n                    bit[i] += delta\n                    i += i & -i\n            def bit_sum(i: int) -> int:\n                s = 0\n                while i > 0:\n                    s += bit[i]\n                    i -= i & -i\n                return s\n            inv = 0\n            seen = 0\n            for x in arr:\n                r = rank[x]\n                inv += seen - bit_sum(r)\n                bit_add(r, 1)\n                seen += 1\n            return inv\n        result_inversions = count_inversions(result)\n        sorted_arrays = sorted(arrays, key=lambda x: x[0] + x[1])\n        optimal = []\n        for arr in sorted_arrays:\n            optimal.extend(arr)\n        optimal_inversions = count_inversions(optimal)\n        if not(result_inversions == optimal_inversions):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(2, [(1, 4), (2, 3)])], concatenation_of_arrays(1, [(2, [(1, 4), (2, 3)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, [(3, 2), (4, 3), (2, 1)])], concatenation_of_arrays(1, [(3, [(3, 2), (4, 3), (2, 1)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1 [(5, [(5, 10), (2, 3), (9, 6), (4, 1), (8, 7)])], concatenation_of_arrays(1 [(5, [(5, 10), (2, 3), (9, 6), (4, 1), (8, 7)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(1, [(10, 20)])], concatenation_of_arrays(1, [(1, [(10, 20)])]))"
      }
    ],
    "metadata": {
      "problem_id": "2023A",
      "url": "https://codeforces.com/problemset/problem/2023/A",
      "title": "Concatenation of Arrays",
      "rating": 1300,
      "tags": [
        "constructive algorithms",
        "greedy",
        "math",
        "sortings"
      ],
      "div": "Div. 1",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 341501816\n# status: accepted\n\nfrom bisect import bisect_left\nfrom functools import reduce\nfrom operator import concat, iconcat, itemgetter\nimport sys\n\n\"\"\"\nsorting by either 1st or 2nd guarantees there will be no inversions in chosen dimension\nthe question is... \nis there something more optimal?\n1 9\n2 8\n1 9 2 8 --> 2 inversions: 9 > 2, 9 > 8\n2 8 1 9 --> 2 inversions: 2 > 1, 8 > 1\n\ngood candidate to try to write a proof for a hypothesis\n\nalso consider:\n- median / average\n\nmaybe can craft counter example where sort by 1 works better than sort by 2?\n\n1 5\n3 3\n9 2\n--> 6 by 1, 8 by 2\n\n5 1\n3 3\n2 9\n--> 8 by 1, 6 by 2\n\nwell, even if it was the case, how to choose the better of them?\n\n\noooh, what if we choose a minimum number every time?\n1 5 --> 1\n9 2 --> 2\nand tie breaks?\n1 3\n2 1\n\n\ntutorial suggested using sum,\nand their proof is: in an optimal solution swapping 2 arrays so that sum_1 < sum_2 does NOT increase inversions\nI guess the approach to this should've been to lay out _all_ possibilities? and inspect how my rules impact that:\n- sort by 1st\n- sort by 2nd\n- sort by min\n- sort by average (this would've worked actually, because it's the same as summation)\n- sort by sum\n\n1 2 3 4\n----\n1 2\n3 4\n----\n1 2\n3 4\n----\n1 3\n2 4\n----\n1 4\n2 3\n----\n\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 2 3\n1 4 3 2\n\n\nBased on proof, is there a case where after min sorting swapping will result in more inversions?\n3 1 2 4 -> 2\n\n1 2 3 4 -> 0\n\n4 1 2 2 -> 3\n2 2 1 4 -> 2\ncounter example\n\n\n\"\"\"\n\n\ndef concatenation_of_arrays(t: int, test_cases: list[tuple[int,list[tuple[int, int]]]]) -> list[list[int]]:\n    results = []\n    for test in test_cases:\n        n, A = test\n\n        def comp(v):\n            # return min(v), max(v)\n            return sum(v)\n\n        A = sorted(A, key=comp)\n        results.append(reduce(iconcat, A, []))\n    return results\n",
      "incorrect_solution": "# submission: 334651617\n\n#  Test: #2, time: 249 ms., memory: 7696 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 4368\n# 1\n# 1 1\n# 1\n# 1 2\n# 1\n# 1 3\n# 1\n# 1 4\n# 1\n# 2 1\n# 1\n# 2 2\n# 1\n# 2 3\n# 1\n# 2 4\n# 1\n# 3 1\n# 1\n# 3 2\n# 1\n# 3 3\n# 1\n# 3 4\n# 1\n# 4 1\n# 1\n# 4 2\n# 1\n# 4 3\n# 1\n# 4 4\n# 2\n# 1 1\n# 1 1\n# 2\n# 1 1\n# 1 2\n# 2\n# 1 1\n# 1 3\n# 2\n# 1 1\n# 1 4\n# 2\n# 1 1\n# 2 1\n# 2\n# 1 1\n# 2 2\n# 2\n# 1 1\n# 2 3\n# 2\n# 1 1\n# 2 4\n# 2\n# 1 1\n# 3 1\n# 2\n# 1 1\n# 3 2\n# 2\n# 1 1\n# 3 3\n# 2\n# 1 1\n# 3 4\n# 2\n# 1 1\n# 4 1\n# 2\n# 1 1\n# 4 2\n# 2\n# 1 1\n# 4 3\n# 2\n# 1 1\n# 4 4\n# 2\n# 1 2\n# 1 1\n# 2\n# 1 2\n# 1 2\n# 2\n# 1 2\n# 1 3\n# 2\n# 1 2\n# 1 4\n# 2\n# 1 2\n# 2 1\n# 2\n# 1 2\n# 2 2\n# 2\n# 1 2\n# 2 3\n# 2\n# 1 2\n# 2 4\n# 2\n# 1 2\n# 3 1\n# 2\n# 1 2\n# 3 2\n# 2\n# 1 2\n# 3 3\n# 2\n# 1 2\n# 3 4\n# 2\n# 1 2\n# 4 1\n# ...\n# Output\n# 1 1\n# 1 2\n# 1 3\n# 1 4\n# 2 1\n# 2 2\n# 2 3\n# 2 4\n# 3 1\n# 3 2\n# 3 3\n# 3 4\n# 4 1\n# 4 2\n# 4 3\n# 4 4\n# 1 1 1 1\n# 1 1 1 2\n# 1 1 1 3\n# 1 1 1 4\n# 1 1 2 1\n# 1 1 2 2\n# 1 1 2 3\n# 1 1 2 4\n# 1 1 3 1\n# 1 1 3 2\n# 1 1 3 3\n# 1 1 3 4\n# 1 1 4 1\n# 1 1 4 2\n# 1 1 4 3\n# 1 1 4 4\n# 1 1 1 2\n# 1 2 1 2\n# 1 2 1 3\n# 1 2 1 4\n# 1 2 2 1\n# 1 2 2 2\n# 1 2 2 3\n# 1 2 2 4\n# 1 2 3 1\n# 1 2 3 2\n# 1 2 3 3\n# 1 2 3 4\n# 1 2 4 1\n# 1 2 4 2\n# 1 2 4 3\n# 1 2 4 4\n# 1 1 1 3\n# 1 2 1 3\n# 1 3 1 3\n# 1 3 1 4\n# 1 3 2 1\n# 1 3 2 2\n# 1 3 2 3\n# 1 3 2 4\n# 1 3 3 1\n# 1 3 3 2\n# 1 3 3 3\n# 1 3 3 4\n# 1 3 4 1\n# 1 3 4 2\n# 1 3 4 3\n# 1 3 4 4\n# ...\n# Answer\n# 1 1 \n# 1 2 \n# 1 3 \n# 1 4 \n# 2 1 \n# 2 2 \n# 2 3 \n# 2 4 \n# 3 1 \n# 3 2 \n# 3 3 \n# 3 4 \n# 4 1 \n# 4 2 \n# 4 3 \n# 4 4 \n# 1 1 1 1 \n# 1 1 1 2 \n# 1 1 1 3 \n# 1 1 1 4 \n# 1 1 2 1 \n# 1 1 2 2 \n# 1 1 2 3 \n# 1 1 2 4 \n# 1 1 3 1 \n# 1 1 3 2 \n# 1 1 3 3 \n# 1 1 3 4 \n# 1 1 4 1 \n# 1 1 4 2 \n# 1 1 4 3 \n# 1 1 4 4 \n# 1 1 1 2 \n# 1 2 1 2 \n# 1 2 1 3 \n# 1 2 1 4 \n# 1 2 2 1 \n# 1 2 2 2 \n# 1 2 2 3 \n# 1 2 2 4 \n# 1 2 3 1 \n# 1 2 3 2 \n# 1 2 3 3 \n# 1 2 3 4 \n# 1 2 4 1 \n# 1 2 4 2 \n# 1 2 4 3 \n# 1 2 4 4 \n# 1 1 1 3 \n# 1 2 1 3 \n# 1 3 1 3 \n# 1 3 1 4 \n# 2 1 1 3 \n# 1 3 2 2 \n# 1 3 2 3 \n# 1 3 2 4 \n# 1 3 3 1 \n# 1 3 3...\n# Checker Log\n# wrong answer Jury has a better answer: 2 < 3 (test case 53)\n\n\n\nimport sys, os\nimport random\nfrom itertools import *\nfrom math import isqrt, sqrt, ceil, floor, factorial, comb, gcd, lcm\nfrom collections import defaultdict, Counter, deque, OrderedDict\nfrom heapq import heapify, heappush, heappop\nfrom functools import lru_cache, reduce\nfrom bisect import bisect_left, bisect_right\nfrom types import GeneratorType\n\nMOD1 = 10**9 + 7\nMOD2 = 998244353\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sieve(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    return [p for p in range(2, n + 1) if prime[p]]\n\ndef max_subarray(a):\n    ans = 0\n    mx = float(\"-inf\")\n    for i in a:\n        ans += i\n        mx = max(mx, ans)\n        if ans < 0:\n            ans = 0\n    return mx\n\ndef bit_array(a):\n    bit = [0] * 32\n    for i in a:\n        t = i\n        j = 0\n        while t:\n            bit[j] += t & 1\n            t >>= 1\n            j += 1\n    return bit\n\ndef prefix_sum(a):\n    n = len(a)\n    pre = [0] * (n + 1)\n    for i in range(n):\n        pre[i + 1] = pre[i] + a[i]\n    return pre\n\ndef suffix_sum(a):\n    n = len(a)\n    suf = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suf[i] = suf[i + 1] + a[i]\n    return suf\n\ndef Fact(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i ) % MOD1\n    return fact\n\ndef InvFact(n):\n    invfact = [1] * (n + 1)\n    invfact[n] = pow(factorial(n), MOD1 - 2, MOD1)\n    for i in range(n, 0, -1):\n        invfact[i - 1] = (invfact[i] * i) % MOD1\n    return invfact\n\nInp  = lambda c: c(input())\nPut  = lambda b: map(b, input().split())\nList = lambda a: list(map(a, input().split()))\ninf  = lambda : float(\"inf\")\n_inf = lambda : float(\"-inf\")\nnCr  = lambda n, r: factorial(n) // (factorial(r) * factorial(n-r))\n\n\n\ndef concatenation_of_arrays(t: int, test_cases: list[tuple[int,list[tuple[int, int]]]]) -> list[list[int]]:\n    results = []\n    for test in test_cases:\n        n, a = test\n        a.sort()\n        ans = []\n        for i , j in a:\n            ans += [i]\n            ans += [j]\n        results.append(ans)\n    return results\n"
    }
  },
  {
    "id": "cool_graph",
    "requirements": {
      "signature": "def cool_graph(t: int, test_cases: list[tuple[int,int,list[tuple[int, int]]]]) -> list[tuple[int, list[tuple[int, int, int]]]]",
      "description": "You are given an undirected graph with $n$ vertices and $m$ edges.\n\nYou can perform the following operation at most $2\\cdot \\max(n,m)$ times:\n\n  * Choose three distinct vertices $a$, $b$, and $c$, then for each of the edges $(a,b)$, $(b,c)$, and $(c,a)$, do the following:      * If the edge does not exist, add it. On the contrary, if it exists, remove it. \n\nA graph is called cool if and only if one of the following holds:\n\n  * The graph has no edges, or    * The graph is a tree. \n\nYou have to make the graph cool by performing the above operations. Note that you can use at most $2\\cdot \\max(n,m)$ operations.\n\nIt can be shown that there always exists at least one solution.\n\n# Input:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1\\le t\\le 10^4$) — the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($3\\le n\\le 10^5$, $0\\le m\\le \\min\\left(\\frac{n(n-1)}{2},2\\cdot 10^5\\right)$) — the number of vertices and the number of edges.\n\nThen $m$ lines follow, the $i$-th line contains two integers $u_i$ and $v_i$ ($1\\le u_i,v_i\\le n$) — the two nodes that the $i$-th edge connects.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $2\\cdot 10^5$.\n\nIt is guaranteed that there are no self-loops or multiple-edges in the given graph.\n\n# Output:\nFor each test case, in the first line output an integer $k$ ($0\\le k\\le 2\\cdot \\max(n, m)$) — the number of operations.\n\nThen output $k$ lines, the $i$-th line containing three distinct integers $a$, $b$, and $c$ ($1\\le a,b,c\\le n$) — the three integers you choose in the $i$-th operation.\n\nIf there are multiple solutions, you can output any of them.\n\n# Example input:\n5\n3 0\n3 1\n1 2\n3 2\n1 2\n2 3\n3 3\n1 2\n2 3\n3 1\n6 6\n1 2\n1 6\n4 5\n3 4\n4 6\n3 6\n\n# Example output:\n0\n1\n1 2 3\n0\n1\n1 2 3\n3\n1 3 6\n2 4 5\n3 4 6\n\n# Notes:\nIn the first test case, the graph is already cool because there are no edges.\n\nIn the second test case, after performing the only operation, the graph becomes a tree, so it is cool.\n\nIn the third test case, the graph is already cool because it is a tree.\n\nIn the fourth test case, after performing the only operation, the graph has no edges, so it is cool.\n\nIn the fifth test case:\n\nOperation| Graph before the operation| Graph after the operation   ---|---|---   $1$| ![](CDN_BASE_URL/2ae6076e1f03509c037a09c9076dda44)| ![](CDN_BASE_URL/f67f064593f982711104693ae4686716)   $2$| ![](CDN_BASE_URL/e255209e458ced6bc4506880eff20f51)| ![](CDN_BASE_URL/bd025bd4677e0b4aa572053845638281)   $3$| ![](CDN_BASE_URL/201da19f0948f088eeec88037834610e)| ![](CDN_BASE_URL/7190a38dd77c4ed23d9567462fd4f2f2)      Note that after the first operation, the graph has already become cool, and there are two extra operations. As the graph is still cool after the two extra operations, this is a valid answer.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int,int,list[tuple[int, int]]]], results: list[tuple[int, list[tuple[int, int, int]]]]) -> bool:\n    for (test, operations) in zip(test_cases, results):\n        n, m, edges = test\n        _, operations = operations\n        if len(operations) > 2 * max(n, len(edges)):\n            return False\n        adj = [set() for _ in range(n)]\n        for u, v in edges:\n            u0, v0 = u-1, v-1\n            adj[u0].add(v0)\n            adj[v0].add(u0)\n        for a, b, c in operations:\n            if len({a, b, c}) != 3:\n                return False\n            if not all(1 <= x <= n for x in [a, b, c]):\n                return False\n            a0, b0, c0 = a-1, b-1, c-1\n            for u, v in [(a0, b0), (b0, c0), (c0, a0)]:\n                if v in adj[u]:\n                    adj[u].remove(v)\n                    adj[v].remove(u)\n                else:\n                    adj[u].add(v)\n                    adj[v].add(u)\n        edge_count = sum(len(lst) for lst in adj) // 2\n        if edge_count not in (0, n-1):\n            return False\n        if edge_count == 0:\n            return True\n        visited = [False]*n\n        q = deque()\n        for i in range(n):\n            if len(adj[i]) > 0:\n                q.append(i)\n                visited[i] = True\n                break\n        count = 0\n        while q:\n            u = q.popleft()\n            count += 1\n            for v in adj[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    q.append(v)\n        return count == n\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, 0, [])], cool_graph(1, [(3, 0, [])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, 1, [(1, 2)])], cool_graph(1, [(3, 1, [(1, 2)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(3, 2, [(1, 2), (2, 3)])], cool_graph(1, [(3, 2, [(1, 2), (2, 3)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(3, 3, [(1, 2), (2, 3), (3, 1)])], cool_graph(1, [(3, 3, [(1, 2), (2, 3), (3, 1)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(6, 6, [(1, 2), (1, 6), (4, 5), (3, 4), (4, 6), (3, 6)])], cool_graph(1, [(6, 6, [(1, 2), (1, 6), (4, 5), (3, 4), (4, 6), (3, 6)])]))"
      }
    ],
    "metadata": {
      "problem_id": "2029D",
      "url": "https://codeforces.com/problemset/problem/2029/D",
      "title": "Cool Graph",
      "rating": 1900,
      "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "graphs",
        "trees"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 3000,
      "memory_limit_mb": 512,
      "correct_solution": "# submission:  333716467\n# status: accepted\n\nimport sys, threading\n\ndef cool_graph(t: int, test_cases: list[tuple[int,int,list[tuple[int, int]]]]) -> list[tuple[int, list[tuple[int, int, int]]]]:\n\n    results = []\n    for test in test_cases:\n        n, m = test[0], test[1]\n        connected = [0 for i in range(n + 1)]\n        ops = []\n        random_connected = -1\n        edges = []\n\n        for u, v in test[2]:\n            edges.append((min(u, v), max(u, v)))\n\n        edges.sort()\n\n        for u, v in edges:\n            if u > 1 and v > 1:\n                ops.append((1, u, v))\n                connected[u] ^= 1\n                connected[v] ^= 1\n            else:\n                if u == 1:\n                    connected[v] = 1\n                else:\n                    connected[u] = 1\n\n        for i in range(2, n + 1):\n            if connected[i]:\n                random_connected = i\n                break\n\n        if random_connected == -1:\n            output_list = []\n            for i in range(len(ops)):\n                output_list.append((ops[i][0], ops[i][1], ops[i][2]))\n            results.append((len(ops), output_list))\n        else:\n            for i in range(2, n + 1):\n                if not connected[i]:\n                    ops.append((1, i, random_connected))\n                    random_connected = i\n\n            output_list = []\n            for i in range(len(ops)):\n                output_list.append((ops[i][0], ops[i][1], ops[i][2]))\n            results.append((len(ops), output_list))\n\n    return results\n",
      "incorrect_solution": "# submission:  341266774\n\n#  Test: #1, time: 61 ms., memory: 36 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 5\n# 3 0\n# 3 1\n# 1 2\n# 3 2\n# 1 2\n# 2 3\n# 3 3\n# 1 2\n# 2 3\n# 3 1\n# 6 6\n# 1 2\n# 1 6\n# 4 5\n# 3 4\n# 4 6\n# 3 6\n# Output\n# 0\n# 0\n# 0\n# 1\n# 3 1 2\n# 2\n# 3 6 4\n# 6 3 1\n# Answer\n# 0\n# 1\n# 2 1 3\n# 2\n# 2 1 3\n# 3 1 2\n# 1\n# 1 2 3\n# 5\n# 1 2 6\n# 3 4 6\n# 6 2 1\n# 6 1 3\n# 4 5 6\n# Checker Log\n# wrong answer The graph is not cool. :( (test case 2)\n\n\ndef make_graph_cool(n, m, edges):\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    visited = [False]*n\n    parent = [-1]*n\n    ops = []\n\n    def dfs(u, par):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                parent[v] = u\n                dfs(v, u)\n            elif v != par and parent[u] != v:\n                # Found a cycle, pick triangle (u, v, par)\n                if par != -1:\n                    ops.append((u+1, v+1, par+1))\n                    # Remove edges (u,v), (v,par), (par,u)\n                    # (simulate toggling)\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1)\n    return ops\n\ndef cool_graph(t: int, test_cases: list[tuple[int,int,list[tuple[int, int]]]]) -> list[tuple[int, list[tuple[int, int, int]]]]:\n\n    results = []\n    for test in test_cases:\n        n, m, edges = test\n        ops = make_graph_cool(n, m, edges)\n        results.append((len(ops), ops))\n    return results\n"
    }
  },
  {
    "id": "different_string",
    "requirements": {
      "signature": "def different_string(t: int, strings: list[str]) -> list[Union[str, tuple[str, str]]]",
      "description": "You are given a string $s$ consisting of lowercase English letters.\n\nRearrange the characters of $s$ to form a new string $r$ that is not equal to $s$, or report that it's impossible.\n\n# Input:\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 1000$) — the number of test cases.\n\nThe only line of each test case contains a string $s$ of length at most $10$ consisting of lowercase English letters.\n\n# Output:\nFor each test case, if no such string $r$ exists as described in the statement, output \"NO\" (without quotes).\n\nOtherwise, output \"YES\" (without quotes). Then, output one line — the string $r$, consisting of letters of string $s$.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nIf multiple answers are possible, you can output any of them.\n\n# Example input:\n8\ncodeforces\naaaaa\nxxxxy\nco\nd\nnutdealer\nmwistht\nhhhhhhhhhh\n\n# Example output:\nYES\nforcodesec\nNO\nYES\nxxyxx\nYES\noc\nNO\nYES\nundertale\nYES\nthtsiwm\nNO\n\n# Notes:\nIn the first test case, another possible answer is $\\texttt{forcescode}$.\n\nIn the second test case, all rearrangements of $\\texttt{aaaaa}$ are equal to $\\texttt{aaaaa}$.\n"
    },
    "judge": "def __judge(t:int, strings: list[str], results: list[Union[str, tuple[str, str]]]) -> bool:\n    for (s, result) in zip(strings, results):\n        if result == 'NO':\n            # Check if all characters in s are the same\n            if not(len(set(s)) == 1):\n                return False\n            continue\n        if not isinstance(result, tuple):\n            return False\n        if result[0].upper() != 'YES':\n            return False\n        r = result[1]\n        # Check if r is a valid rearrangement of s and r != s\n        if not(sorted(s) == sorted(r) and s != r):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, ['codeforces'], different_string(1, ['codeforces']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, ['aaaaa'], different_string(1, ['aaaaa']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, ['xxxxy'], different_string(1, ['xxxxy']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, ['co'], different_string(1, ['co']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, ['d'], different_string(1, ['d']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, ['nutdealer'], different_string(1, ['nutdealer']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_7():\n    assert __judge(1, ['mwistht'], different_string(1, ['mwistht']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_8():\n    assert __judge(1, ['hhhhhhhhhh'], different_string(1, ['hhhhhhhhhh']))"
      }
    ],
    "metadata": {
      "problem_id": "1971B",
      "url": "https://codeforces.com/problemset/problem/1971/B",
      "title": "Different String",
      "rating": 800,
      "tags": [
        "implementation",
        "strings"
      ],
      "div": "Div. 4",
      "time_limit_ms": 1000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 343167949\n# status: accepted\n\ndef different_string(t: int, strings: list[str]) -> list[Union[str, tuple[str, str]]]:\n    results = []\n    for n in strings:\n        Str = n[0]\n\n        for i in range(len(n)):\n            if n[i] != Str:\n                results.append(('YES', n[:i-1] + n[i] + n[i-1] + n[i+1:]))\n                break\n        else:\n            results.append('NO')\n    return results\n",
      "incorrect_solution": "# submission: 343128586\n\n#  Test: #2, time: 203 ms., memory: 2900 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 1000\n# a\n# b\n# c\n# d\n# e\n# aa\n# ab\n# ac\n# ad\n# ae\n# ba\n# bb\n# bc\n# bd\n# be\n# ca\n# cb\n# cc\n# cd\n# ce\n# da\n# db\n# dc\n# dd\n# de\n# ea\n# eb\n# ec\n# ed\n# ee\n# aaa\n# aab\n# aac\n# aad\n# aae\n# aba\n# abb\n# abc\n# abd\n# abe\n# aca\n# acb\n# acc\n# acd\n# ace\n# ada\n# adb\n# adc\n# add\n# ade\n# aea\n# aeb\n# aec\n# aed\n# aee\n# baa\n# bab\n# bac\n# bad\n# bae\n# bba\n# bbb\n# bbc\n# bbd\n# bbe\n# bca\n# bcb\n# bcc\n# bcd\n# bce\n# bda\n# bdb\n# bdc\n# bdd\n# bde\n# bea\n# beb\n# bec\n# bed\n# bee\n# caa\n# cab\n# cac\n# cad\n# cae\n# cba\n# cbb\n# cbc\n# cbd\n# cbe\n# cca\n# ccb\n# ccc\n# ccd\n# cce\n# cda\n# cdb\n# cdc\n# cdd\n# cde\n# cea\n# ceb\n# cec\n# ced\n# cee\n# daa\n# dab\n# dac\n# ...\n# Output\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# YES\n# ba\n# YES\n# ca\n# YES\n# da\n# YES\n# ea\n# YES\n# ab\n# NO\n# YES\n# cb\n# YES\n# db\n# YES\n# eb\n# YES\n# ac\n# YES\n# bc\n# NO\n# YES\n# dc\n# YES\n# ec\n# YES\n# ad\n# YES\n# bd\n# YES\n# cd\n# NO\n# YES\n# ed\n# YES\n# ae\n# YES\n# be\n# YES\n# ce\n# YES\n# de\n# NO\n# NO\n# YES\n# baa\n# YES\n# caa\n# YES\n# daa\n# YES\n# eaa\n# YES\n# aba\n# YES\n# bba\n# YES\n# cba\n# YES\n# dba\n# YES\n# eba\n# YES\n# aca\n# YES\n# bca\n# YES\n# cca\n# YES\n# dca\n# YES\n# eca\n# YES\n# ada\n# YES\n# bda\n# YES\n# cda\n# YES\n# dda\n# YES\n# eda\n# YES\n# aea\n# YES\n# bea\n# YES\n# cea\n# YES\n# dea\n# YES\n# eea\n# YES\n# aab\n# YES\n# bab\n# YES\n# cab\n# YES\n# dab\n# YES\n# ea...\n# Answer\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# YES\n# ba\n# YES\n# ca\n# YES\n# da\n# YES\n# ea\n# YES\n# ab\n# NO\n# YES\n# cb\n# YES\n# db\n# YES\n# eb\n# YES\n# ac\n# YES\n# bc\n# NO\n# YES\n# dc\n# YES\n# ec\n# YES\n# ad\n# YES\n# bd\n# YES\n# cd\n# NO\n# YES\n# ed\n# YES\n# ae\n# YES\n# be\n# YES\n# ce\n# YES\n# de\n# NO\n# NO\n# YES\n# baa\n# YES\n# caa\n# YES\n# daa\n# YES\n# eaa\n# YES\n# baa\n# YES\n# bab\n# YES\n# bac\n# YES\n# bad\n# YES\n# bae\n# YES\n# caa\n# YES\n# cab\n# YES\n# cac\n# YES\n# cad\n# YES\n# cae\n# YES\n# daa\n# YES\n# dab\n# YES\n# dac\n# YES\n# dad\n# YES\n# dae\n# YES\n# eaa\n# YES\n# eab\n# YES\n# eac\n# YES\n# ead\n# YES\n# eae\n# YES\n# aba\n# YES\n# abb\n# YES\n# abc\n# YES\n# abd\n# YES\n# ab...\n# Checker Log\n# wrong answer t is equal to s (test case 36)\n\ndef different_string(t: int, strings: list[str]) -> list[Union[str, tuple[str, str]]]:\n    results = []\n    for a in strings:\n        if len(set(a))>1:\n            results.append(('YES', a[::-1]))\n        else:\n            results.append('NO')\n    return results\n"
    }
  },
  {
    "id": "earning_on_bets",
    "requirements": {
      "signature": "def earning_on_bets(t: int, test_cases: list[int, list[int]]) -> list[Union[int,list[int]]]",
      "description": "You have been offered to play a game. In this game, there are $n$ possible outcomes, and for each of them, you must bet a certain integer amount of coins. In the event that the $i$-th outcome turns out to be winning, you will receive back the amount of coins equal to your bet on that outcome, multiplied by $k_i$. Note that exactly one of the $n$ outcomes will be winning.\n\nYour task is to determine how to distribute the coins in such a way that you will come out ahead in the event of any winning outcome. More formally, the total amount of coins you bet on all outcomes must be strictly less than the number of coins received back for each possible winning outcome.\n\n# Input:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 50$) — the number of outcomes.\n\nThe second line of each test case contains $n$ integers $k_1,k_2,\\ldots,k_n$ ($2 \\le k_i \\le 20$) — the multiplier for the amount of coins if the $i$-th outcome turns out to be winning.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output $-1$ if there is no way to distribute the coins as required. Otherwise, output $n$ integers $x_1, x_2,\\ldots, x_n$ ($1 \\le x_i \\le 10^{9}$) — your bets on the outcomes.\n\nIt can be shown that if a solution exists, there is always a solution that satisfies these constraints.\n\nIf there are multiple suitable solutions, output any of them.\n\n# Example input:\n6\n3\n3 2 7\n2\n3 3\n5\n5 5 5 5 5\n6\n7 9 3 17 9 13\n3\n6 3 2\n5\n9 4 6 8 3\n\n# Example output:\n27 41 12 \n1 1 \n-1\n1989 1547 4641 819 1547 1071 \n-1\n8 18 12 9 24\n\n# Notes:\nIn the first test case, the coins can be distributed as follows: $27$ coins on the first outcome, $41$ coins on the second outcome, $12$ coins on the third outcome. Then the total amount of coins bet on all outcomes is $27 + 41 + 12 = 80$ coins. If the first outcome turns out to be winning, you will receive back $3 \\cdot 27 = 81$ coins, if the second outcome turns out to be winning, you will receive back $2 \\cdot 41 = 82$ coins, if the third outcome turns out to be winning, you will receive back $7 \\cdot 12 = 84$ coins. All these values are strictly greater than $80$.\n\nIn the second test case, one way is to bet one coin on each of the outcomes.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int, list[int]], results: list[Union[int,list[int]]]) -> bool:\n    for (test, result) in zip(test_cases, results):\n        n, k = test\n        if result == -1:\n            from math import gcd\n            def lcm(a, b):\n                return a * b // gcd(a, b)\n            current_lcm = 1\n            for ki in k:\n                current_lcm = lcm(current_lcm, ki)\n            sum_terms = 0\n            for ki in k:\n                sum_terms += current_lcm // ki\n            if not(sum_terms >= current_lcm):\n                return False\n            continue\n        if not isinstance(result, list):\n            return False\n        x = result\n        if len(x) != n:\n            return False\n        if any(xi < 1 or xi > 10**9 for xi in x):\n            return False\n        total = sum(x)\n        for i in range(n):\n            if x[i] * k[i] <= total:\n                return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, [3, 2, 7])], earning_on_bets(1, [(3, [3, 2, 7])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(2, [3, 3])], earning_on_bets(1, [(2, [3, 3])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(5, [5, 5, 5, 5, 5])], earning_on_bets(1, [(5, [5, 5, 5, 5, 5])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(6, [7, 9, 3, 17, 9, 13])], earning_on_bets(1, [(6, [7, 9, 3, 17, 9, 13])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(3, [6, 3, 2])], earning_on_bets(1, [(3, [6, 3, 2])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [(5, [9, 4, 6, 8, 3])], earning_on_bets(1, [(5, [9, 4, 6, 8, 3])]))"
      }
    ],
    "metadata": {
      "problem_id": "1979C",
      "url": "https://codeforces.com/problemset/problem/1979/C",
      "title": "Earning on Bets",
      "rating": 1200,
      "tags": [
        "binary search",
        "combinatorics",
        "constructive algorithms",
        "number theory"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  340042696\n# status: accepted\n\nimport math\nfrom fractions import Fraction\n\ndef lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef lcm_of_list(lst):\n    current = 1\n    for num in lst:\n        current = lcm(current, num)\n    return current\n\ndef earning_on_bets(t: int, test_cases: list[int, list[int]]) -> list[Union[int,list[int]]]:\n    results = []\n    for test in test_cases:\n        n, k_list = test\n        if n >= 20:\n            results.append(-1)\n        else:\n            total_reciprocal = Fraction(0)\n            for k in k_list:\n                total_reciprocal += Fraction(1, k)\n            if total_reciprocal >= 1:\n                results.append(-1)\n            else:\n                D = lcm_of_list(k_list)\n                res = [D // k for k in k_list]\n                results.append(res)\n    return results\n",
      "incorrect_solution": "# submission: 340591441\n\n#  Test: #2, time: 61 ms., memory: 2568 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 10000\n# 1\n# 2\n# 1\n# 3\n# 1\n# 4\n# 1\n# 5\n# 2\n# 2 2\n# 2\n# 2 3\n# 2\n# 2 4\n# 2\n# 2 5\n# 2\n# 3 2\n# 2\n# 3 3\n# 2\n# 3 4\n# 2\n# 3 5\n# 2\n# 4 2\n# 2\n# 4 3\n# 2\n# 4 4\n# 2\n# 4 5\n# 2\n# 5 2\n# 2\n# 5 3\n# 2\n# 5 4\n# 2\n# 5 5\n# 3\n# 2 2 2\n# 3\n# 2 2 3\n# 3\n# 2 2 4\n# 3\n# 2 2 5\n# 3\n# 2 3 2\n# 3\n# 2 3 3\n# 3\n# 2 3 4\n# 3\n# 2 3 5\n# 3\n# 2 4 2\n# 3\n# 2 4 3\n# 3\n# 2 4 4\n# 3\n# 2 4 5\n# 3\n# 2 5 2\n# 3\n# 2 5 3\n# 3\n# 2 5 4\n# 3\n# 2 5 5\n# 3\n# 3 2 2\n# 3\n# 3 2 3\n# 3\n# 3 2 4\n# 3\n# 3 2 5\n# 3\n# 3 3 2\n# 3\n# 3 3 3\n# 3\n# 3 3 4\n# 3\n# 3 3 5\n# 3\n# 3 4 2\n# 3\n# 3 4 3\n# 3\n# 3 4 4\n# 3\n# 3 4 5\n# 3\n# 3 5 2\n# 3\n# 3 5 3\n# 3\n# 3 5 4\n# 3\n# 3 5 5\n# 3\n# 4 2 2\n# 3\n# 4 2 3\n# 3\n# 4 2 4\n# 3\n# ...\n# Output\n# 1\n# 1\n# 1\n# 1\n# -1\n# 3 2\n# 4 2\n# 5 2\n# 2 3\n# 3 3\n# 4 3\n# 5 3\n# 2 4\n# 3 4\n# 4 4\n# 5 4\n# 2 5\n# 3 5\n# 4 5\n# 5 5\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 20 10 8\n# -1\n# -1\n# 20 8 10\n# 25 10 10\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 12 12 9\n# 15 15 9\n# -1\n# 12 9 12\n# 16 12 12\n# 20 15 12\n# -1\n# 15 9 15\n# 20 12 15\n# 25 15 15\n# -1\n# -1\n# -1\n# 10 20 8\n# -1\n# 9 12 12\n# 12 16 12\n# 15 20 12\n# -1\n# 12 12 16\n# 16 16 16\n# 20 20 16\n# 10 8 20\n# 15 12 20\n# 20 16 20\n# 25 20 20\n# -1\n# -1\n# 8 20 10\n# 10 25 10\n# -1\n# 9 15 15\n# 12 20 15\n# 15 25 15\n# 8 10 20\n# 12 15 20\n# 16 20 20\n# 20 25 20\n# 10 10 ...\n# Answer\n# 1 \n# 1 \n# 1 \n# 1 \n# -1\n# 3 2 \n# 2 1 \n# 5 2 \n# 2 3 \n# 1 1 \n# 4 3 \n# 5 3 \n# 1 2 \n# 3 4 \n# 1 1 \n# 5 4 \n# 2 5 \n# 3 5 \n# 4 5 \n# 1 1 \n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 10 5 4 \n# -1\n# -1\n# 10 4 5 \n# 5 2 2 \n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 4 4 3 \n# 5 5 3 \n# -1\n# 4 3 4 \n# 4 3 3 \n# 20 15 12 \n# -1\n# 5 3 5 \n# 20 12 15 \n# 5 3 3 \n# -1\n# -1\n# -1\n# 5 10 4 \n# -1\n# 3 4 4 \n# 3 4 3 \n# 15 20 12 \n# -1\n# 3 3 4 \n# 1 1 1 \n# 5 5 4 \n# 5 4 10 \n# 15 12 20 \n# 5 4 5 \n# 5 4 4 \n# -1\n# -1\n# 4 10 5 \n# 2 5 2 \n# -1\n# 3 5 5 \n# 12 20 15 \n# 3 5 3 \n# 4 5 10 \n# 12 15 20 \n# 4 5 5 \n# 4 5 4 \n# 2 2 5 \n# 3 3 5...\n# Checker Log\n# wrong answer Integer parameter [name=x[1]] equals to 1280000000, violates the range [-1, 10^9] (test case 5612)\n\nimport sys\n\ndef earning_on_bets(t: int, test_cases: list[int, list[int]]) -> list[Union[int,list[int]]]:\n    results = []\n    for test in test_cases:\n        n, k = test\n        \n        # 计算倒数和判断可行性\n        sum_reciprocal = 0.0\n        possible = True\n        for ki in k:\n            if ki == 0:\n                possible = False\n                break\n            sum_reciprocal += 1.0 / ki\n        if not possible or sum_reciprocal >= 1.0 - 1e-9:  # 避免浮点数误差\n            results.append(-1)\n            continue\n        \n        # 计算所有k的乘积（用于构造x_i）\n        product = 1\n        for ki in k:\n            product *= ki\n        \n        # 构造每个x_i = product / k_i\n        x = [product // ki for ki in k]  # 整数除法（确保x_i为整数）\n        results.append(x)\n    return results\n"
    }
  },
  {
    "id": "find_k_distinct_points",
    "requirements": {
      "signature": "def find_k_distinct_points(t: int, test_cases: list[tuple[int, int, int]]) -> list[list[tuple[int, int]]]",
      "description": "I couldn't think of a good title for this problem, so I decided to learn from LeetCode.\n\n— Sun Tzu, The Art of War\n\nYou are given three integers $x_c$, $y_c$, and $k$ ($-100 \\leq x_c, y_c \\leq 100$, $1 \\leq k \\leq 1000$).\n\nYou need to find $k$ distinct points ($x_1, y_1$), ($x_2, y_2$), $\\ldots$, ($x_k, y_k$), having integer coordinates, on the 2D coordinate plane such that:\n\n  * their center$^{\\text{∗}}$ is ($x_c, y_c$)    * $-10^9 \\leq x_i, y_i \\leq 10^9$ for all $i$ from $1$ to $k$ \n\nIt can be proven that at least one set of $k$ distinct points always exists that satisfies these conditions.\n\n$^{\\text{∗}}$The center of $k$ points ($x_1, y_1$), ($x_2, y_2$), $\\ldots$, ($x_k, y_k$) is $\\left( \\frac{x_1 + x_2 + \\ldots + x_k}{k}, \\frac{y_1 + y_2 + \\ldots + y_k}{k} \\right)$.\n\n# Input:\nThe first line contains $t$ ($1 \\leq t \\leq 100$) — the number of test cases.\n\nEach test case contains three integers $x_c$, $y_c$, and $k$ ($-100 \\leq x_c, y_c \\leq 100$, $1 \\leq k \\leq 1000$) — the coordinates of the center and the number of distinct points you must output.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $1000$.\n\n# Output:\nFor each test case, output $k$ lines, the $i$-th line containing two space separated integers, $x_i$ and $y_i$, ($-10^9 \\leq x_i, y_i \\leq 10^9$) — denoting the position of the $i$-th point.\n\nIf there are multiple answers, print any of them. It can be shown that a solution always exists under the given constraints.\n\n# Example input:\n4\n10 10 1\n0 0 3\n-5 -8 8\n4 -5 3\n\n# Example output:\n10 10\n-1 -1\n5 -1\n-4 2\n-6 -7\n-5 -7\n-4 -7\n-4 -8\n-4 -9\n-5 -9\n-6 -9\n-6 -8\n1000 -1000\n-996 995\n8 -10\n\n# Notes:\nFor the first test case, $\\left( \\frac{10}{1}, \\frac{10}{1} \\right) = (10, 10)$.\n\nFor the second test case, $\\left( \\frac{-1 + 5 - 4}{3}, \\frac{-1 -1 + 2}{3} \\right) = (0, 0)$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int, int, int]], results: list[list[tuple[int, int]]]) -> bool:\n    for (test, result) in zip(test_cases, results):\n        xc, yc, k = test\n        if len(result) != k:\n            return False\n        if len(set(result)) != k:  # Check distinct\n            return False\n        # Check all coordinates are within bounds\n        for x, y in result:\n            if not (-10**9 <= x <= 10**9 and -10**9 <= y <= 10**9):\n                return False\n        # Check center\n        sum_x = sum(x for x, y in result)\n        sum_y = sum(y for x, y in result)\n        if not( sum_x == k * xc and sum_y == k * yc):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(10, 10, 1)], find_k_distinct_points(1, [(10, 10, 1)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(0, 0, 3)], find_k_distinct_points(1, [(0, 0, 3)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(-5, -8, 8)], find_k_distinct_points(1, [(-5, -8, 8)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(4, -5, 3)], find_k_distinct_points(1, [(4, -5, 3)]))"
      }
    ],
    "metadata": {
      "problem_id": "1998A",
      "url": "https://codeforces.com/problemset/problem/1998/A",
      "title": "Find K Distinct Points with Fixed Center",
      "rating": 800,
      "tags": [
        "constructive algorithms",
        "implementation",
        "math"
      ],
      "div": "Div. 2",
      "time_limit_ms": 1000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 343158406\n# status: accepted\n\ndef find_k_distinct_points(t: int, test_cases: list[tuple[int, int, int]]) -> list[list[tuple[int, int]]]:\n    results = []\n    for test in test_cases:\n        xc, yc, k = test\n        points = []\n        if k % 2 == 1:\n            # include the center itself\n            points.append((xc, yc))\n            half = (k - 1) // 2\n            for i in range(1, half + 1):\n                points.append((xc + i, yc + i))\n                points.append((xc - i, yc - i))\n        else:\n            half = k // 2\n            for i in range(1, half + 1):\n                points.append((xc + i, yc + i))\n                points.append((xc - i, yc - i))\n        results.append(points)\n    return results\n",
      "incorrect_solution": "# submission:  336945528\n\n#  Test: #1, time: 46 ms., memory: 92 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 4\n# 10 10 1\n# 0 0 3\n# -5 -8 8\n# 4 -5 3\n# Output\n# 10 10\n# 2 2\n# 0 0\n# -2 -2\n# -3 -6\n# -7 -10\n# -1 -4\n# -9 -12\n# 1 -2\n# -11 -14\n# 3 0\n# -13 -16\n# 6 6\n# 4 -5\n# 2 -7\n# Answer\n# 10 10\n# 1 0\n# -1 0\n# 0 0\n# -4 -8\n# -6 -8\n# -3 -8\n# -7 -8\n# -2 -8\n# -8 -8\n# -1 -8\n# -9 -8\n# 5 -5\n# 3 -5\n# 4 -5\n# Checker Log\n# wrong answer center is not (4, -5) (test case 4)\n\n\ndef find_k_distinct_points(t: int, test_cases: list[tuple[int, int, int]]) -> list[list[tuple[int, int]]]:\n    results = []\n    for test in test_cases:\n\n        x,y,k = test\n        if k == 1:\n            results.append([(x, y)])\n            continue\n        totalx = x \n        totaly = y \n        xpoints = []\n        ypoints = []\n        if k % 2 == 0:\n            for i in range(1, k//2 + 1):\n                posx = totalx + (2*i)\n                negx = totalx - (2*i)\n                xpoints.append(posx)\n                xpoints.append(negx)\n\n                posy = totaly + (2*i)\n                negy = totaly - (2*i)\n                ypoints.append(posy)\n                ypoints.append(negy)\n        else:\n\n            ntotalx = totalx + 2\n            ntotaly = totaly + 2\n\n            for i in range(0, k//2):\n                posx = ntotalx + (2*i)\n                posy = ntotalx + (2*i)\n\n                xpoints.append(posx)\n                ypoints.append(posy)\n            for i in range(0, k//2 + 1):\n                negx = totalx - (2*i)\n                negy = totaly - (2*i)\n\n                xpoints.append(negx)\n                ypoints.append(negy)\n\n        results.append(list[zip(xpoints, ypoints)])\n\n    return results\n"
    }
  },
  {
    "id": "fixing_binary_string",
    "requirements": {
      "signature": "def fixing_binary_string(t: int, test_cases: list[tuple[int, int, str]]) -> list[int]",
      "description": "You are given a binary string $s$ of length $n$, consisting of zeros and ones. You can perform the following operation exactly once:\n\n  1. Choose an integer $p$ ($1 \\le p \\le n$).    2. Reverse the substring $s_1 s_2 \\ldots s_p$. After this step, the string $s_1 s_2 \\ldots s_n$ will become $s_p s_{p-1} \\ldots s_1 s_{p+1} s_{p+2} \\ldots s_n$.    3. Then, perform a cyclic shift of the string $s$ to the left $p$ times. After this step, the initial string $s_1s_2 \\ldots s_n$ will become $s_{p+1}s_{p+2} \\ldots s_n s_p s_{p-1} \\ldots s_1$. \n\nFor example, if you apply the operation to the string 110001100110 with $p=3$, after the second step, the string will become 011001100110, and after the third step, it will become 001100110011.\n\nA string $s$ is called $k$-proper if two conditions are met:\n\n  * $s_1=s_2=\\ldots=s_k$;    * $s_{i+k} \\neq s_i$ for any $i$ ($1 \\le i \\le n - k$). \n\nFor example, with $k=3$, the strings 000, 111000111, and 111000 are $k$-proper, while the strings 000000, 001100, and 1110000 are not.\n\nYou are given an integer $k$, which is a divisor of $n$. Find an integer $p$ ($1 \\le p \\le n$) such that after performing the operation, the string $s$ becomes $k$-proper, or determine that it is impossible. Note that if the string is initially $k$-proper, you still need to apply exactly one operation to it.\n\n# Input:\nEach test consists of multiple test cases. The first line contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n$, $2 \\le n \\le 10^5$) — the length of the string $s$ and the value of $k$. It is guaranteed that $k$ is a divisor of $n$.\n\nThe second line of each test case contains a binary string $s$ of length $n$, consisting of the characters 0 and 1.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output a single integer — the value of $p$ to make the string $k$-proper, or $-1$ if it is impossible.\n\nIf there are multiple solutions, output any of them.\n\n# Example input:\n7\n8 4\n11100001\n4 2\n1110\n12 3\n111000100011\n5 5\n00000\n6 1\n101001\n8 4\n01110001\n12 2\n110001100110\n\n# Example output:\n3\n-1\n7\n5\n4\n-1\n3\n\n# Notes:\nIn the first test case, if you apply the operation with $p=3$, after the second step of the operation, the string becomes 11100001, and after the third step, it becomes 00001111. This string is $4$-proper.\n\nIn the second test case, it can be shown that there is no operation after which the string becomes $2$-proper.\n\nIn the third test case, if you apply the operation with $p=7$, after the second step of the operation, the string becomes 100011100011, and after the third step, it becomes 000111000111. This string is $3$-proper.\n\nIn the fourth test case, after the operation with any $p$, the string becomes $5$-proper.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int, int, str]], results: list[int]) -> bool:\n    for test, p in zip(test_cases, results):\n        n, k, s = test\n        if p == -1:\n            # Check if no valid p exists\n            last_char = s[-1]\n            x = 0\n            for i in reversed(range(n)):\n                if s[i] == last_char:\n                    x += 1\n                else:\n                    break\n\n            if x > k:\n                continue # No solution exists\n\n            candidates = []\n            if x == k:\n                # Case x == k\n                found = False\n                for i in reversed(range(n - k)):\n                    if s[i] == s[i + k]:\n                        candidates.append(i + 1)\n                        found = True\n                        break\n                candidates.append(n)  # Fallback to p = n\n            else:\n                # Case x < k\n                i = 0\n                added = False\n                while i < n:\n                    if s[i] != last_char:\n                        i += 1\n                        continue\n                    j = i\n                    while j + 1 < n and s[j + 1] == last_char:\n                        j += 1\n                    block_len = j - i + 1\n                    if block_len + x == k:\n                        candidates.append(j + 1)\n                        added = True\n                        break\n                    elif block_len + x == 2 * k:\n                        candidates.append(i + (k - x))\n                        added = True\n                        break\n                    i = j + 1\n                if not added:\n                    candidates.append(n)\n\n            # Check all candidates\n            valid_found = False\n            for candidate_p in candidates:\n                if not (1 <= candidate_p <= n):\n                    continue\n                # Apply reverse and shift\n                reversed_part = s[candidate_p - 1::-1]\n                new_s = reversed_part + s[candidate_p:]\n                rotated = new_s[candidate_p:] + new_s[:candidate_p]\n                # Check if k-proper\n                valid = True\n                if not all(c == rotated[0] for c in rotated[:k]):\n                    valid = False\n                else:\n                    for i in range(len(rotated) - k):\n                        if rotated[i] == rotated[i + k]:\n                            valid = False\n                            break\n                if valid:\n                    valid_found = True\n                    break\n            if valid_found:\n                return False\n        else:\n            # Check if p is valid\n            if not (1 <= p <= n):\n                return False\n            # Apply reverse and shift\n            reversed_part = s[p - 1::-1]\n            new_s = reversed_part + s[p:]\n            rotated = new_s[p:] + new_s[:p]\n            # Check if k-proper\n            if not all(c == rotated[0] for c in rotated[:k]):\n                return False\n            for i in range(n - k):\n                if rotated[i] == rotated[i + k]:\n                    return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(8, 4, '11100001')], fixing_binary_string(1, [(8, 4, '11100001')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(4, 2, '1110')], fixing_binary_string(1, [(4, 2, '1110')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(12, 3, '111000100011')], fixing_binary_string(1, [(12, 3, '111000100011')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(5, 5, '00000')], fixing_binary_string(1, [(5, 5, '00000')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(6, 1, '101001')], fixing_binary_string(1, [(6, 1, '101001')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [(8, 4, '01110001')], fixing_binary_string(1, [(8, 4, '01110001')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_7():\n    assert __judge(1, [(12, 2, '110001100110')], fixing_binary_string(1, [(12, 2, '110001100110')]))"
      }
    ],
    "metadata": {
      "problem_id": "1979D",
      "url": "https://codeforces.com/problemset/problem/1979/D",
      "title": "Fixing a Binary String",
      "rating": 1800,
      "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dp",
        "greedy",
        "hashing",
        "strings"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 343197938\n# status: accepted\n\ndef fixing_binary_string(t: int, test_cases: list[tuple[int, int, str]]) -> list[int]:\n    results = []\n    for test in test_cases:\n        n, k, c = test\n\n        pfx0, pfx1, dp1 = [], [], [0] * n\n\n        for i in range(n):\n            if i == 0:\n                pfx0.append(int(c[i] == '0'))\n                pfx1.append(int(c[i] == '1'))\n            else:\n                pfx0.append(pfx0[-1] + int(c[i] == '0'))\n                pfx1.append(pfx1[-1] + int(c[i] == '1'))\n\n        for i in range(n - 1, -1, -1):\n            if i + k - 1 >= n:\n                dp1[i] = 0\n                continue\n\n            amt = -1\n            if c[i] == '1':\n                if i == 0:\n                    amt = pfx1[i + k - 1]\n                else:\n                    amt = pfx1[i + k - 1] - pfx1[i - 1]\n            else:\n                if i == 0:\n                    amt = pfx0[i + k - 1]\n                else:\n                    amt = pfx0[i + k - 1] - pfx0[i - 1]\n\n            if c[i] == '1' and amt == k:\n                dp1[i] = k\n                if i + k < n and c[i + k] == '0':\n                    dp1[i] += dp1[i + k]\n            elif c[i] == '0' and amt == k:\n                dp1[i] = k\n                if i + k < n and c[i + k] == '1':\n                    dp1[i] += dp1[i + k]\n\n        if dp1[0] == n:\n            results.append(n)\n            continue\n\n        res = -1\n\n        for p in range(n - 1):\n            st, end = (p + 1) % k, k - (p + 1) % k\n\n            if end == 0:\n                end = k\n\n            l, r, v = p + 1, n - end - 1, (p + 1) // k * k\n\n            if dp1[l] < r - l + 1 or c[n - end - 1] == c[n - end]:\n                continue\n\n            start_idx = n - end\n            if c[n - end] == '1':\n                amt = pfx1[n - 1] - (pfx1[start_idx - 1] if start_idx > 0 else 0)\n            else:\n                amt = pfx0[n - 1] - (pfx0[start_idx - 1] if start_idx > 0 else 0)\n            if amt != end:\n                continue\n\n            if c[n - end] == '1':\n                if v == 0:\n                    v2 = pfx1[p]\n                else:\n                    v2 = pfx1[p] - pfx1[v - 1]\n            else:\n                if v == 0:\n                    v2 = pfx0[p]\n                else:\n                    v2 = pfx0[p] - pfx0[v - 1]\n\n            if c[n - end] == '1' and v2 == st and (v - 1 < 0 or c[v - 1] == '0') and dp1[0] >= v:\n                res = p + 1\n                break\n            elif c[n - end] == '0' and v2 == st and (v - 1 < 0 or c[v - 1] == '1') and dp1[0] >= v:\n                res = p + 1\n                break\n\n        if res != -1:\n            results.append(res)\n        else:\n            results.append(-1)\n    return results\n\n",
      "incorrect_solution": "# submission: 336539125\n\n#  Test: #2, time: 249 ms., memory: 9028 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 10000\n# 2 1\n# 00\n# 2 2\n# 00\n# 2 1\n# 10\n# 2 2\n# 10\n# 2 1\n# 01\n# 2 2\n# 01\n# 2 1\n# 11\n# 2 2\n# 11\n# 3 1\n# 000\n# 3 3\n# 000\n# 3 1\n# 100\n# 3 3\n# 100\n# 3 1\n# 010\n# 3 3\n# 010\n# 3 1\n# 110\n# 3 3\n# 110\n# 3 1\n# 001\n# 3 3\n# 001\n# 3 1\n# 101\n# 3 3\n# 101\n# 3 1\n# 011\n# 3 3\n# 011\n# 3 1\n# 111\n# 3 3\n# 111\n# 4 1\n# 0000\n# 4 2\n# 0000\n# 4 4\n# 0000\n# 4 1\n# 1000\n# 4 2\n# 1000\n# 4 4\n# 1000\n# 4 1\n# 0100\n# 4 2\n# 0100\n# 4 4\n# 0100\n# 4 1\n# 1100\n# 4 2\n# 1100\n# 4 4\n# 1100\n# 4 1\n# 0010\n# 4 2\n# 0010\n# 4 4\n# 0010\n# 4 1\n# 1010\n# 4 2\n# 1010\n# 4 4\n# 1010\n# 4 1\n# 0110\n# 4 2\n# 0110\n# 4 4\n# 0110\n# 4 1\n# 1110\n# 4 2\n# 1110\n# 4 4\n# 1110\n# 4 1\n# 000...\n# Output\n# -1\n# 2\n# 2\n# -1\n# 2\n# -1\n# -1\n# 2\n# -1\n# 3\n# -1\n# -1\n# 3\n# -1\n# 1\n# -1\n# 1\n# -1\n# 3\n# -1\n# -1\n# -1\n# -1\n# 3\n# -1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# -1\n# 2\n# 1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 2\n# 1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# 5\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 5\n# -1\n# 1\n# -1\n# -1\n# -1\n# 3\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 3\n# -1\n# -1\n# -1\n# 1\n# -1\n# 5\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1...\n# Answer\n# -1\n# 2\n# 2\n# -1\n# 2\n# -1\n# -1\n# 2\n# -1\n# 3\n# -1\n# -1\n# 3\n# -1\n# 1\n# -1\n# 1\n# -1\n# 3\n# -1\n# -1\n# -1\n# -1\n# 3\n# -1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# -1\n# 2\n# 1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 2\n# 1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 4\n# -1\n# 5\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 5\n# -1\n# 1\n# -1\n# -1\n# -1\n# 3\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# 3\n# -1\n# -1\n# -1\n# 1\n# -1\n# 5\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1\n# -1...\n# Checker Log\n# wrong answer Participant didn't find a solution, but jury did (test case 2010)\n\ndef fixing_binary_string(t: int, test_cases: list[tuple[int, int, str]]) -> list[int]:\n  results = []\n  for test in test_cases:\n    n,k,s = test\n    x = s[n-1]; cnt=0\n    for i in range(n-1,-1,-1):\n      if s[i]!=x: break\n      cnt+=1\n    if cnt>k: results.append(-1)\n    elif cnt==k:\n      x = s[0]; c=0\n      flag = 1; res = n\n      for i in range(n):\n        if x==s[i]: c+=1\n        else:\n          if c==2*k:\n            if res==n and x!=s[n-1]: res=i-k\n            else: flag=0\n          elif c!=k:\n            flag=0\n          c=1; x=s[i]\n      if flag: results.append(res)\n      else: results.append(-1)\n    else:\n      x = s[0]; c=0\n      flag = 1; res = n\n      for i in range(n):\n        if x==s[i]: c+=1\n        else:\n          if c in [k-cnt, cnt+k]:\n            if res==n and x==s[n-1]: res=i-k*(c==cnt+k)\n            else: flag=0\n          elif c!=k:\n            flag=0\n          c=1; x=s[i]\n      if flag: results.append(res)\n      else: results.append(-1)\n  return results\n"
    }
  },
  {
    "id": "generate_permutation",
    "requirements": {
      "signature": "def generate_permutation(t: int, test_cases: list[int]) -> list[list[int]]",
      "description": "There is an integer sequence $a$ of length $n$, where each element is initially $-1$.\n\nMisuki has two typewriters where the first one writes letters from left to right, with a pointer initially pointing to $1$, and another writes letters from right to left with a pointer initially pointing to $n$.\n\nMisuki would choose one of the typewriters and use it to perform the following operations until $a$ becomes a permutation of $[1, 2, \\ldots, n]$\n\n  * write number: write the minimum positive integer that isn't present in the array $a$ to the element $a_i$, $i$ is the position where the pointer points at. Such operation can be performed only when $a_i = -1$.    * carriage return: return the pointer to its initial position (i.e. $1$ for the first typewriter, $n$ for the second)    * move pointer: move the pointer to the next position, let $i$ be the position the pointer points at before this operation, if Misuki is using the first typewriter, $i := i + 1$ would happen, and $i := i - 1$ otherwise. Such operation can be performed only if after the operation, $1 \\le i \\le n$ holds. \n\nYour task is to construct any permutation $p$ of length $n$, such that the minimum number of carriage return operations needed to make $a = p$ is the same no matter which typewriter Misuki is using.\n\n# Input:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 500$) — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of the permutation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output a line of $n$ integers, representing the permutation $p$ of length $n$ such that the minimum number of carriage return operations needed to make $a = p$ is the same no matter which typewriter Misuki is using, or $-1$ if it is impossible to do so.\n\nIf there are multiple valid permutations, you can output any of them.\n\n# Example input:\n3\n1\n2\n3\n\n# Example output:\n1\n-1\n3 1 2\n\n# Notes:\nIn the first testcase, it's possible to make $a = p = [1]$ using $0$ carriage return operations.\n\nIn the second testcase, it is possible to make $a = p = [1, 2]$ with the minimal number of carriage returns as follows:\n\nIf Misuki is using the first typewriter:\n\n  * Write number: write $1$ to $a_1$, $a$ becomes $[1, -1]$    * Move pointer: move the pointer to the next position. (i.e. $2$)    * Write number: write $2$ to $a_2$, $a$ becomes $[1, 2]$ \n\nIf Misuki is using the second typewriter:\n\n  * Move pointer: move the pointer to the next position. (i.e. $1$)    * Write number: write $1$ to $a_1$, $a$ becomes $[1, -1]$    * Carriage return: return the pointer to $2$.    * Write number: write $2$ to $a_2$, $a$ becomes $[1, 2]$ \n\nIt can be proven that the minimum number of carriage returns needed to transform $a$ into $p$ when using the first typewriter is $0$ and it is $1$ when using the second one, so this permutation is not valid.\n\nSimilarly, $p = [2, 1]$ is also not valid, so there is no solution for $n = 2$.\n\nIn the third testcase, it is possibile to make $a = p = [3, 1, 2]$ with $1$ carriage return with both the first and the second typewriter. It can be proven that, for both typewriters, it is impossible to write $p$ with $0$ carriage returns.\n\nWith the first typewriter it is possible to:\n\n  * Move pointer: move the pointer to the next position. (i.e. $2$)    * Write number: write $1$ to $a_2$, $a$ becomes $[-1, 1, -1]$    * Move pointer: move the pointer to the next position. (i.e. $3$)    * Write number: write $2$ to $a_3$, $a$ becomes $[-1, 1, 2]$    * Carriage return: return the pointer to $1$.    * Write number: write $3$ to $a_1$, $a$ becomes $[3,1,2]$ \n\nWith the second typewriter it is possible to:\n\n  * Move pointer: move the pointer to the next position. (i.e. $2$)    * Write number: write $1$ to $a_2$, $a$ becomes $[-1, 1, -1]$    * Carriage return: return the pointer to $3$.    * Write number: write $2$ to $a_3$, $a$ becomes $[-1, 1, 2]$    * Move pointer: move the pointer to the next position. (i.e. $2$)    * Move pointer: move the pointer to the next position. (i.e. $1$)    * Write number: write $3$ to $a_1$, $a$ becomes $[3, 1, 2]$\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int], results: list[list[int]]) -> bool:\n    for (n, result) in zip(test_cases, results):\n        if result == [-1]:\n            if not( n % 2 == 0):\n                return False\n            continue\n        if len(result) != n:\n            return False\n        if sorted(result) != list(range(1, n + 1)):\n            return False\n        pos = [0] * (n + 1)\n        for idx in range(n):\n            pos[result[idx]] = idx\n        c1 = sum(1 for x in range(1, n) if pos[x] > pos[x + 1])\n        c2 = sum(1 for x in range(1, n) if pos[x] < pos[x + 1])\n        if not( c1 == c2):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [1], generate_permutation(1, [1]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [2], generate_permutation(1, [2]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [3], generate_permutation(1, [3]))"
      }
    ],
    "metadata": {
      "problem_id": "2001B",
      "url": "https://codeforces.com/problemset/problem/2001/B",
      "title": "Generate Permutation",
      "rating": 800,
      "tags": [
        "constructive algorithms"
      ],
      "div": "Div. 2",
      "time_limit_ms": 1500,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 340844395\n# status: accepted\n\ndef generate_permutation(t: int, test_cases: list[int]) -> list[list[int]]:\n    results = []\n    for test in test_cases:\n        n = test\n        if n%2 == 0:\n            results.append(-1)\n        else:\n            results.append(list(range(n,0,-2)) + list(range(2,n,2)))\n    return results\n",
      "incorrect_solution": "# submission:  342492614\n\n#  Test: #2, time: 124 ms., memory: 15872 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 3\n# 13\n# 123456\n# 76531\n# Output\n# 13 1 2 3 4 5 6 7 8 9 10 11 12\n# 123456 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 1...\n# Answer\n# 1 3 2 5 4 7 6 9 8 11 10 13 12\n# -1\n# 1 3 2 5 4 7 6 9 8 11 10 13 12 15 14 17 16 19 18 21 20 23 22 25 24 27 26 29 28 31 30 33 32 35 34 37 36 39 38 41 40 43 42 45 44 47 46 49 48 51 50 53 52 55 54 57 56 59 58 61 60 63 62 65 64 67 66 69 68 71 70 73 72 75 74 77 76 79 78 81 80 83 82 85 84 87 86 89 88 91 90 93 92 95 94 97 96 99 98 101 100 103 102 105 104 107 106 109 108 111 110 113 112 115 114 117 116 119 118 121 120 123 122 125 124 127 126 129 128 131 130 133 132 135 134 137 136 139 138 141 140 143 142 145 144 147 ...\n# Checker Log\n# wrong answer participant gives invalid answer. (test case 1)\n\ndef generate_permutation(t: int, test_cases: list[int]) -> list[list[int]]:\n    results = []\n    for n in test_cases:\n        if n == 1:\n            results.append([1])\n        elif n == 2:\n            results.append([-1])\n        else:\n            # Construct permutation as [n, 1, 2, ..., n-1]\n            permutation = [n] + list(range(1, n))\n            results.append(permutation)\n    return results\n"
    }
  },
  {
    "id": "gorilla_and_permutation",
    "requirements": {
      "signature": "def gorilla_and_permutation(t: int, test_cases: list[tuple[int, int, int]]) -> list[list[int]]",
      "description": "Gorilla and Noobish_Monk found three numbers $n$, $m$, and $k$ ($m < k$). They decided to construct a permutation$^{\\dagger}$ of length $n$.\n\nFor the permutation, Noobish_Monk came up with the following function: $g(i)$ is the sum of all the numbers in the permutation on a prefix of length $i$ that are not greater than $m$. Similarly, Gorilla came up with the function $f$, where $f(i)$ is the sum of all the numbers in the permutation on a prefix of length $i$ that are not less than $k$. A prefix of length $i$ is a subarray consisting of the first $i$ elements of the original array.\n\nFor example, if $n = 5$, $m = 2$, $k = 5$, and the permutation is $[5, 3, 4, 1, 2]$, then:\n\n  * $f(1) = 5$, because $5 \\ge 5$; $g(1) = 0$, because $5 > 2$;    * $f(2) = 5$, because $3 < 5$; $g(2) = 0$, because $3 > 2$;    * $f(3) = 5$, because $4 < 5$; $g(3) = 0$, because $4 > 2$;    * $f(4) = 5$, because $1 < 5$; $g(4) = 1$, because $1 \\le 2$;    * $f(5) = 5$, because $2 < 5$; $g(5) = 1 + 2 = 3$, because $2 \\le 2$. \n\nHelp them find a permutation for which the value of $\\left(\\sum_{i=1}^n f(i) - \\sum_{i=1}^n g(i)\\right)$ is maximized.\n\n$^{\\dagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in any order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation (as $2$ appears twice in the array) and $[1,3,4]$ is also not a permutation (as $n=3$, but $4$ appears in the array).\n\n# Input:\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$)  — the number of test cases.\n\nThe only line of each case contains three integers $n$, $m$, $k$ ($2\\le n \\le 10^5$; $1 \\le m < k \\le n$) — the size of the permutation to be constructed and two integers.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output the permutation  — a set of numbers that satisfies the conditions of the problem. If there are multiple solutions, output any of them.\n\n# Example input:\n3\n5 2 5\n3 1 3\n10 3 8\n\n# Example output:\n5 3 4 1 2\n3 2 1\n10 9 8 4 7 5 6 1 2 3\n\n# Notes:\nIn the first example, $\\left(\\sum_{i=1}^n f(i) - \\sum_{i=1}^n g(i)\\right) = 5 \\cdot 5 - (0 \\cdot 3 + 1 + 3) = 25 - 4 = 21$\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int, int, int]], results: list[list[int]]) -> bool:\n    for test, result in zip(test_cases, results):\n        n, m, k = test\n\n        if len(result) != n:\n            return False\n        if sorted(result) != list(range(1, n + 1)):\n            return False\n        std_perm = list(range(n, m, -1)) + list(range(1, m + 1))\n        def compute_score(perm):\n            score = 0\n            for idx, num in enumerate(perm):\n                pos = idx + 1\n                if num >= k:\n                    score += num * (n - pos + 1)\n                if num <= m:\n                    score -= num * (n - pos + 1)\n            return score\n        given_score = compute_score(result)\n        optimal_score = compute_score(std_perm)\n        if not (given_score == optimal_score):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(5, 2, 5)], gorilla_and_permutation(1, [(5, 2, 5)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, 1, 3)], gorilla_and_permutation(1, [(3, 1, 3)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(10, 3, 8)], gorilla_and_permutation(1, [(10, 3, 8)]))"
      }
    ],
    "metadata": {
      "problem_id": "1992C",
      "url": "https://codeforces.com/problemset/problem/1992/C",
      "title": "Gorilla and Permutation",
      "rating": 900,
      "tags": [
        "constructive algorithms",
        "math"
      ],
      "div": "Div. 3",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  343156767\n# status: accepted\n\ndef gorilla_and_permutation(t: int, test_cases: list[tuple[int, int, int]]) -> list[list[int]]:\n    results = []\n    for test in test_cases:\n        n, m, k = test\n        arr = [i for i in range(1, n+1)]\n        greater = sorted([x for x in arr if x >= k], reverse=True)\n        smaller = sorted([x for x in arr if x <= m])\n        neutral = [x for x in arr if m < x < k]\n        ans = greater + neutral + smaller\n        results.append(ans)\n    return results\n",
      "incorrect_solution": "# submission: 341166539\n\n#  Test: #1, time: 93 ms., memory: 740 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 3\n# 5 2 5\n# 3 1 3\n# 10 3 8\n# Output\n# 5 4 3 2 1\n# 3 2 1\n# 10 9 8 7 6 5 4 3 2 1\n# Answer\n# 5 4 3 1 2 \n# 3 2 1 \n# 10 9 8 7 6 5 4 1 2 3 \n# Checker Log\n# wrong answer Jury has better answer (test case 1)\n\n\n\nfrom sys import stdin\nimport math, collections, heapq, itertools, functools\n\ndef gorilla_and_permutation(t: int, test_cases: list[tuple[int, int, int]]) -> list[list[int]]:\n    results = []\n    for test in test_cases:\n        n, m, k = test\n        ans = [i for i in range(n, 0, -1)]\n        results.append(ans)\n    return results\n"
    }
  },
  {
    "id": "grid_reset",
    "requirements": {
      "signature": "def grid_reset(t: int, test_cases: list[tuple[int, int, int, int, str]]) -> list[Union[int, list[tuple[int, int]]]]",
      "description": "You are given a grid consisting of $n$ rows and $m$ columns, where each cell is initially white. Additionally, you are given an integer $k$, where $1 \\le k \\le \\min(n, m)$.\n\nYou will process $q$ operations of two types:\n\n  * $\\mathtt{H}$ (horizontal operation) — You choose a $1 \\times k$ rectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.    * $\\mathtt{V}$ (vertical operation) — You choose a $k \\times 1$ rectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black. \n\nAfter each operation, if any rows or columns become completely black, all cells in these rows and columns are simultaneously reset to white. Specifically, if all cells in the row and column a cell is contained in become black, all cells in both the row and column will be reset to white.\n\nChoose the rectangles in a way that you can perform all given operations, or determine that it is impossible.\n\n# Input:\nEach test contains multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. The description of test cases follows.\n\nThe first line of each test case contains four integers $n$, $m$, $k$, and $q$ ($1 \\le n, m \\le 100$, $1 \\le k \\le \\min(n, m)$, $1 \\le q \\le 1000$) — the number of rows and columns in the grid, the size of the operation rectangle, and the number of operations, respectively.\n\nThe second line of each test case contains a string $s$ of length $q$, consisting only of characters $\\mathtt{H}$ and $\\mathtt{V}$ — the sequence of operation types.\n\nIt is guaranteed that the sum of $q$ over all test cases does not exceed $1000$.\n\n# Output:\nFor each test case, output a single integer $-1$ if it is impossible to perform all the operations.\n\nOtherwise, output $q$ lines. Each line contains two integers $i$, $j$ ($1 \\le i \\le n$, $1 \\le j \\le m$) — the coordinates of the top-left cell of the operation rectangle.\n\nIf there are multiple solutions, output any of them.\n\n# Example input:\n1\n4 5 3 6\nHVVHHV\n\n# Example output:\n1 1\n2 1\n1 1\n2 3\n3 3\n2 2\n\n# Notes:\n![](CDN_BASE_URL/4e8cc9bc31ec8a5ba8c074c199a00b25) Illustration of example.\n\nThe first operation is horizontal. The operation rectangle starts at $(1,1)$ and is a $1 \\times 3$ rectangle. After the operation, cells $(1,1)$, $(1,2)$, and $(1,3)$ become black.\n\nThe second operation is vertical. The operation rectangle starts at $(2,1)$ and is a $3 \\times 1$ rectangle. After the operation, cells $(2,1)$, $(3,1)$, and $(4,1)$ become black. At this point, the first column becomes completely black, so all cells in the first column are reset to white.\n\nThe third operation is vertical. The operation rectangle starts at $(1,1)$ and is a $3 \\times 1$ rectangle. After the operation, cells $(1,1)$, $(2,1)$, and $(3,1)$ become black.\n\nThe fourth operation is horizontal. The operation rectangle starts at $(2,3)$ and is a $1 \\times 3$ rectangle. After the operation, cells $(2,3)$, $(2,4)$, and $(2,5)$ become black.\n\nThe fifth operation is horizontal. The operation rectangle starts at $(3,3)$ and is a $1 \\times 3$ rectangle. After the operation, cells $(3,3)$, $(3,4)$, and $(3,5)$ become black.\n\nThe sixth operation is vertical. The operation rectangle starts at $(2,2)$ and is a $3 \\times 1$ rectangle. After the operation, cells $(2,2)$, $(3,2)$, and $(4,2)$ become black. At this point, two rows and one column become completely black, so all cells in these rows and the column are reset to white.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int, int, int, int, str]], results: list[Union[int, list[tuple[int, int]]]]) -> bool:\n    for (n, m, k, q, ops), result in zip(test_cases, results):\n        if result == -1:\n            return False\n        lines = result\n        if len(lines) != len(ops):\n            return False\n        grid = [[False] * m for _ in range(n)]\n        for step, (op_char, line) in enumerate(zip(ops, lines), start=1):\n            parts = line\n            if len(parts) != 2:\n                return False\n            try:\n                i = int(parts[0])\n                j = int(parts[1])\n            except ValueError:\n                return False\n            if not (1 <= i <= n and 1 <= j <= m):\n                return False\n            r0 = i - 1\n            c0 = j - 1\n            if op_char == 'H':\n                if c0 + k - 1 >= m:\n                    return False\n                for c in range(c0, c0 + k):\n                    if grid[r0][c]:\n                        return False\n                for c in range(c0, c0 + k):\n                    grid[r0][c] = True\n            elif op_char == 'V':\n                if r0 + k - 1 >= n:\n                    return False\n                for r in range(r0, r0 + k):\n                    if grid[r][c0]:\n                        return False\n                for r in range(r0, r0 + k):\n                    grid[r][c0] = True\n            else:\n                return False\n            full_rows = [r for r in range(n) if all(grid[r][c] for c in range(m))]\n            full_cols = [c for c in range(m) if all(grid[r][c] for r in range(n))]\n            if full_rows or full_cols:\n                for r in full_rows:\n                    for c in range(m):\n                        grid[r][c] = False\n                for c in full_cols:\n                    for r in range(n):\n                        grid[r][c] = False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(4, 5, 3, 6, 'HVVHHV')], grid_reset(1, [(4, 5, 3, 6, 'HVVHHV')]))"
      }
    ],
    "metadata": {
      "problem_id": "1991G",
      "url": "https://codeforces.com/problemset/problem/1991/G",
      "title": "Grid Reset",
      "rating": 2700,
      "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  317671649\n# status: accepted\n\nclass GridResetSolver:\n    \"\"\"A solver for the Grid Reset problem, processing operations on a grid.\n\n    This class handles multiple test cases, each involving an n x m grid with q\n    operations (horizontal 'H' or vertical 'V'). Each operation selects a 1xk or\n    kx1 rectangle, and the solver outputs the top-left coordinates. It assumes\n    operations are always possible, as per the original logic, without tracking\n    the grid state or handling impossible cases.\n    \"\"\"\n    def __init__(self):\n        # Number of rows in the grid\n        self.row_count = 0\n        # Number of columns in the grid\n        self.column_count = 0\n        # Size of the rectangle (k)\n        self.rectangle_size = 0\n        # Number of operations to perform\n        self.operation_count = 0\n        # String of operations ('H' or 'V')\n        self.operation_sequence = \"\"\n        # List of (row, col) coordinates for operations\n        self.operation_coordinates = []\n\n    def process_square_grid(self):\n        \"\"\"Handles the case where row_count == rectangle_size and column_count == rectangle_size.\n\n        For a square grid where both dimensions equal the rectangle size, every\n        operation uses the top-left corner (1, 1), as the entire row or column is\n        covered and reset.\n        \"\"\"\n        for _ in range(self.operation_count):\n            self.operation_coordinates.append((1, 1))\n\n    def process_rows_equal_size(self):\n        \"\"\"Handles the case where row_count == rectangle_size.\n\n        Horizontal operations cycle through rows starting from 1, while vertical\n        operations always use the last column.\n        \"\"\"\n        # Track the current row for horizontal operations\n        current_row = 0\n        for op in self.operation_sequence:\n            if op == 'H':\n                current_row = (current_row % self.row_count) + 1\n                self.operation_coordinates.append((current_row, 1))\n            else:\n                self.operation_coordinates.append((1, self.column_count))\n\n    def process_columns_equal_size(self):\n        \"\"\"Handles the case where column_count == rectangle_size.\n\n        Vertical operations cycle through columns starting from 1, while horizontal\n        operations always use the last row.\n        \"\"\"\n        # Track the current column for vertical operations\n        current_column = 0\n        for op in self.operation_sequence:\n            if op == 'V':\n                current_column = (current_column % self.column_count) + 1\n                self.operation_coordinates.append((1, current_column))\n            else:\n                self.operation_coordinates.append((self.row_count, 1))\n\n    def process_general_case(self):\n        \"\"\"Handles the general case where row_count != rectangle_size and column_count != rectangle_size.\n\n        Uses a strategy to select rows and columns, adjusting indices based on the\n        original logic with reset points for rows and columns.\n        \"\"\"\n        # Current row index for horizontal operations\n        next_row_index = self.row_count\n        # Current column index for vertical operations\n        next_column_index = self.column_count\n        # Reset row index (originally 'p')\n        kResetRow = self.rectangle_size\n        # Reset column index (originally 'q')\n        kResetColumn = self.rectangle_size\n        # Constants for initial row and column resets\n        kInitialRow = self.rectangle_size\n        kInitialColumn = self.rectangle_size\n\n        for op in self.operation_sequence:\n            if op == 'H':\n                self.operation_coordinates.append((next_row_index, 1))\n                next_row_index -= 1\n                if next_row_index == 0:\n                    if next_column_index <= self.rectangle_size:\n                        kResetColumn = next_column_index\n                        next_column_index = self.column_count\n                        next_row_index = kInitialRow\n                    else:\n                        next_row_index = self.row_count\n                elif next_row_index == self.rectangle_size:\n                    next_row_index = kResetRow\n                    kResetRow = kInitialRow\n            else:\n                self.operation_coordinates.append((1, next_column_index))\n                next_column_index -= 1\n                if next_column_index == 0:\n                    if next_row_index <= self.rectangle_size:\n                        kResetRow = next_row_index\n                        next_row_index = self.row_count\n                        next_column_index = kInitialColumn\n                    else:\n                        next_column_index = self.column_count\n                elif next_column_index == self.rectangle_size:\n                    next_column_index = kResetColumn\n                    kResetColumn = kInitialColumn\n\n    def run(self, t: int, test_cases: list[tuple[int, int, int, int, str]]) -> list[Union[int, list[tuple[int, int]]]]:\n        \"\"\"Runs the solver for all test cases.\n\n        Reads the number of test cases, processes each one, and outputs results.\n        \"\"\"\n        results = []\n        for test in test_cases:\n            # Read n, m, k, q\n            params = test\n            self.row_count = params[0]\n            self.column_count = params[1]\n            self.rectangle_size = params[2]\n            self.operation_count = params[3]\n            # Read the operation sequence\n            self.operation_sequence = params[4]\n            # Initialize coordinates list\n            self.operation_coordinates = []\n\n            if self.row_count == self.rectangle_size and self.column_count == self.rectangle_size:\n                self.process_square_grid()\n            elif self.row_count == self.rectangle_size:\n                self.process_rows_equal_size()\n            elif self.column_count == self.rectangle_size:\n                self.process_columns_equal_size()\n            else:\n                self.process_general_case()\n\n            results.append(self.operation_coordinates)\n\n        return results\n\n\ndef grid_reset(t: int, test_cases: list[tuple[int, int, int, int, str]]) -> list[Union[int, list[tuple[int, int]]]]:\n    solver = GridResetSolver()\n    return solver.run(t, test_cases)\n",
      "incorrect_solution": "# submission: 332933354\n\n#  Test: #2, time: 31 ms., memory: 656 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 14\n# 4 4 3 1\n# V\n# 5 5 3 198\n# HVVHVHVVHVVHVHHHVVVHHVVHVHVHHVVVHHHHVVVVVVVHVVVHHHVVHVHHVVVVHHHHVHHVVVHHHVHVVVVHHHHHHVHVHHHHHVHHVVHVVHHHHVVVVVHHHVHHHHVVHVVVVHHVVVHHVHVVHHHHHVVVHHHVVVVVHVHHVVHVVVHVHHVHHVVHVHVHHVVHHHHVVVHHHVVVVHVHVH\n# 3 4 3 91\n# VHHHHHHHVHVHVHVVHHVVHHVHVVVHHHHHHVHVVHVHHVVHHHHHHHVVVHHVHVVVVVHVHVVHVHHHHHHHHHHHHHHHHHHHHVH\n# 1 1 1 71\n# VHVHHHHHHHHHHHHHHHHHHHHVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVHVVVVVVHVHHVVVH\n# 4 3 3 4\n# HVVV\n# 2 3 2 245\n# HHHVVVHVHVVHVVHVHVVHVVVVHVHVHHVVHVVHHVHVVHHHVVVVHVVHHHHVVVHHHHHHHVHHVHVV...\n# Output\n# 1 1\n# -1\n# 1 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 1 4\n# 1 1\n# 1 4\n# 1 1\n# 1 4\n# 1 1\n# 1 4\n# 1 1\n# 1 1\n# 2 1\n# 1 4\n# 1 1\n# 1 1\n# 2 1\n# 1 4\n# 1 1\n# 1 4\n# 1 1\n# 1 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 1 1\n# 1 4\n# 1 1\n# 1 1\n# 1 4\n# 1 1\n# 2 1\n# 1 4\n# 1 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 1 4\n# 1 1\n# 1 1\n# 1 1\n# 2 1\n# 1 4\n# 1 1\n# 1 4\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 4\n# 1 1\n# 1 4\n# 1 1\n# 1 1\n# 1 4\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 3 1\n# 1 1\n# 2 1\n# 1 4\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 1\n# 1 ...\n# Answer\n# 1 4\n# 5 1\n# 1 5\n# 1 4\n# 1 1\n# 1 3\n# 4 1\n# 1 1\n# 1 2\n# 2 1\n# 1 3\n# 1 2\n# 5 1\n# 1 1\n# 4 1\n# 3 1\n# 5 1\n# 1 5\n# 1 4\n# 1 3\n# 4 1\n# 1 1\n# 1 1\n# 1 2\n# 2 1\n# 1 3\n# 5 1\n# 1 2\n# 4 1\n# 3 1\n# 1 1\n# 1 5\n# 1 4\n# 1 1\n# 2 1\n# 3 1\n# 5 1\n# 1 5\n# 1 4\n# 1 3\n# 1 2\n# 1 1\n# 1 5\n# 1 4\n# 1 1\n# 1 3\n# 1 2\n# 1 1\n# 4 1\n# 3 1\n# 2 1\n# 1 5\n# 1 4\n# 1 1\n# 1 3\n# 5 1\n# 4 1\n# 1 1\n# 1 2\n# 1 3\n# 1 2\n# 5 1\n# 4 1\n# 2 1\n# 3 1\n# 1 1\n# 5 1\n# 4 1\n# 1 1\n# 1 2\n# 1 3\n# 5 1\n# 4 1\n# 3 1\n# 1 5\n# 2 1\n# 1 4\n# 1 1\n# 1 2\n# 1 3\n# 1 1\n# 5 1\n# 4 1\n# 3 1\n# 2 1\n# 1 1\n# 1 5\n# 5 1\n# 1 4\n# 1 1\n# 2 1\n# 3 1\n# 4 1\n# 3 1\n# 1 5\n# 2 1\n# 1 1\n# 1 4\n# 1 3\n# 5 1\n# 1 2\n# 1 1\n# 4...\n# Checker Log\n# wrong answer you marked it impossible when it is possible (test case 2)\n\n\nimport sys\n\ndef grid_reset(t: int, test_cases: list[tuple[int, int, int, int, str]]) -> list[Union[int, list[tuple[int, int]]]]:\n    results = []\n    for test in test_cases:\n        n, m, k, q, s = test\n\n        grid = [[0]*m for _ in range(n)]  # 0 = white, 1 = black\n        ans = []\n\n        def reset_if_needed():\n            # Find full-black rows and columns\n            full_rows = [all(grid[r][c] == 1 for c in range(m)) for r in range(n)]\n            full_cols = [all(grid[r][c] == 1 for r in range(n)) for c in range(m)]\n            if not any(full_rows) and not any(full_cols):\n                return\n            R = {r for r in range(n) if full_rows[r]}\n            C = {c for c in range(m) if full_cols[c]}\n            if not R and not C:\n                return\n            # Reset simultaneously: any cell in a row in R or a column in C becomes white\n            for r in R:\n                for c in range(m):\n                    grid[r][c] = 0\n            for c in C:\n                for r in range(n):\n                    grid[r][c] = 0\n\n        possible = True\n        for op in s:\n            placed = False\n            if op == 'H':\n                # look for 1 x k all-white\n                for r in range(n):\n                    c = 0\n                    while c <= m - k and not placed:\n                        ok = True\n                        for x in range(k):\n                            if grid[r][c+x] != 0:\n                                ok = False\n                                # small skip optimization: jump to after this blocked cell\n                                c += x + 1\n                                break\n                        if ok:\n                            # paint\n                            for x in range(k):\n                                grid[r][c+x] = 1\n                            ans.append((r+1, c+1))\n                            placed = True\n                            reset_if_needed()\n                        # if ok, we already placed; if not ok, c already advanced; continue\n                    if placed:\n                        break\n            else:  # 'V'\n                # look for k x 1 all-white\n                for c in range(m):\n                    r = 0\n                    while r <= n - k and not placed:\n                        ok = True\n                        for x in range(k):\n                            if grid[r+x][c] != 0:\n                                ok = False\n                                r += x + 1\n                                break\n                        if ok:\n                            for x in range(k):\n                                grid[r+x][c] = 1\n                            ans.append((r+1, c+1))\n                            placed = True\n                            reset_if_needed()\n                    if placed:\n                        break\n\n            if not placed:\n                possible = False\n                break\n\n        if not possible:\n            results.append(-1)\n        else:\n            results.append(ans)\n\n    return results\n"
    }
  },
  {
    "id": "increasing_sequence_fixed_or",
    "requirements": {
      "signature": "def increasing_sequence_fixed_or(t: int, test_cases: list[int]) -> list[tuple[int,list[int]]]",
      "description": "You are given a positive integer $n$. Find the longest sequence of positive integers $a=[a_1,a_2,\\ldots,a_k]$ that satisfies the following conditions, and print the sequence:\n\n  * $a_i\\le n$ for all $1\\le i\\le k$.    * $a$ is strictly increasing. That is, $a_i>a_{i-1}$ for all $2\\le i\\le k$.    * $a_i\\,|\\,a_{i-1}=n$ for all $2\\le i\\le k$, where $|$ denotes the [bitwise OR operation](https://en.wikipedia.org/wiki/Bitwise_operation#OR).\n\n# Input:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). Description of the test cases follows.\n\nThe only line of each test case contains one integer $n$ ($1\\le n\\le 10^{18}$).\n\nIt's guaranteed that the sum of lengths of the longest valid sequences does not exceed $5\\cdot 10^5$.\n\n# Output:\nFor each testcase, print two lines. In the first line, print the length of your constructed sequence, $k$. In the second line, print $k$ positive integers, denoting the sequence. If there are multiple longest sequences, you can print any of them.\n\n# Example input:\n4\n1\n3\n14\n23\n\n# Example output:\n1\n1\n3\n1 2 3\n4\n4 10 12 14\n5\n7 18 21 22 23\n\n# Notes:\n\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int], results: list[tuple[int,list[int]]]) -> bool:\n    for n, result_tuple in zip(test_cases, results):\n        _, result = result_tuple\n        if any(x < 1 or x > n for x in result):\n            return False\n        for i in range(1, len(result)):\n            if result[i] <= result[i-1]:\n                return False\n        for i in range(1, len(result)):\n            if (result[i] | result[i-1]) != n:\n                return False\n        m = bin(n).count('1')\n        expected_length = 1 if m == 1 else m + 1\n        if not (len(result) == expected_length):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [1], increasing_sequence_fixed_or(1, [1]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [3], increasing_sequence_fixed_or(1, [3]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [14], increasing_sequence_fixed_or(1, [14]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [23], increasing_sequence_fixed_or(1, [23]))"
      }
    ],
    "metadata": {
      "problem_id": "1988C",
      "url": "https://codeforces.com/problemset/problem/1988/C",
      "title": "Increasing Sequence with Fixed OR",
      "rating": 1300,
      "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 512,
      "correct_solution": "# submission:  341567947\n# status: accepted\n\nimport math\n\ndef increasing_sequence_fixed_or(t: int, test_cases: list[int]) -> list[tuple[int,list[int]]]:\n    results = []\n    for test in test_cases:\n        n=test\n        x=int(math.log2(n)//1)\n        if 2**(x)==n:\n            results.append((1, [int(n)]))\n        else:\n            t=[]\n            l=[]\n            i=0\n            a=n\n            while a>0:\n                if a%2==1:\n                    t.append(int(i))\n                    i=i+1\n                else:\n                    i=i+1\n                a=a//2\n            y=len(t)\n            for j in range(y):\n                l.append(int(n-2**(t[y-1-j])))\n            l.append(n)\n            results.append((int(y+1), l))\n    return results\n",
      "incorrect_solution": "# submission: 339287062\n\n#  Test: #2, time: 140 ms., memory: 5560 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 1000\n# 1\n# 2\n# 3\n# 4\n# 5\n# 6\n# 7\n# 8\n# 9\n# 10\n# 11\n# 12\n# 13\n# 14\n# 15\n# 16\n# 17\n# 18\n# 19\n# 20\n# 21\n# 22\n# 23\n# 24\n# 25\n# 26\n# 27\n# 28\n# 29\n# 30\n# 31\n# 32\n# 33\n# 34\n# 35\n# 36\n# 37\n# 38\n# 39\n# 40\n# 41\n# 42\n# 43\n# 44\n# 45\n# 46\n# 47\n# 48\n# 49\n# 50\n# 51\n# 52\n# 53\n# 54\n# 55\n# 56\n# 57\n# 58\n# 59\n# 60\n# 61\n# 62\n# 63\n# 64\n# 65\n# 66\n# 67\n# 68\n# 69\n# 70\n# 71\n# 72\n# 73\n# 74\n# 75\n# 76\n# 77\n# 78\n# 79\n# 80\n# 81\n# 82\n# 83\n# 84\n# 85\n# 86\n# 87\n# 88\n# 89\n# 90\n# 91\n# 92\n# 93\n# 94\n# 95\n# 96\n# 97\n# 98\n# 99\n# 100\n# 1000000000000000000\n# 999999999999999999\n# 999999999999999998\n# 999999999999999997\n# 999999999999999996\n# 999999999999...\n# Output\n# 1\n# 1\n# 1\n# 2\n# 3\n# 1 2 3\n# 1\n# 4\n# 3\n# 1 4 5\n# 3\n# 2 4 6\n# 4\n# 3 5 6 7\n# 1\n# 8\n# 3\n# 1 8 9\n# 3\n# 2 8 10\n# 4\n# 3 9 10 11\n# 3\n# 4 8 12\n# 4\n# 5 9 12 13\n# 4\n# 6 10 12 14\n# 5\n# 7 11 13 14 15\n# 1\n# 16\n# 3\n# 1 16 17\n# 3\n# 2 16 18\n# 4\n# 3 17 18 19\n# 3\n# 4 16 20\n# 4\n# 5 17 20 21\n# 4\n# 6 18 20 22\n# 5\n# 7 19 21 22 23\n# 3\n# 8 16 24\n# 4\n# 9 17 24 25\n# 4\n# 10 18 24 26\n# 5\n# 11 19 25 26 27\n# 4\n# 12 20 24 28\n# 5\n# 13 21 25 28 29\n# 5\n# 14 22 26 28 30\n# 6\n# 15 23 27 29 30 31\n# 1\n# 32\n# 3\n# 1 32 33\n# 3\n# 2 32 34\n# 4\n# 3 33 34 35\n# 3\n# 4 32 36\n# 4\n# 5 33 36 37\n# 4\n# 6 34 36 38\n# 5\n# 7 35 37 38 39\n# 3\n# ...\n# Answer\n# 1\n# 1\n# 1\n# 2\n# 3\n# 1 2 3 \n# 1\n# 4\n# 3\n# 1 4 5 \n# 3\n# 2 4 6 \n# 4\n# 3 5 6 7 \n# 1\n# 8\n# 3\n# 1 8 9 \n# 3\n# 2 8 10 \n# 4\n# 3 9 10 11 \n# 3\n# 4 8 12 \n# 4\n# 5 9 12 13 \n# 4\n# 6 10 12 14 \n# 5\n# 7 11 13 14 15 \n# 1\n# 16\n# 3\n# 1 16 17 \n# 3\n# 2 16 18 \n# 4\n# 3 17 18 19 \n# 3\n# 4 16 20 \n# 4\n# 5 17 20 21 \n# 4\n# 6 18 20 22 \n# 5\n# 7 19 21 22 23 \n# 3\n# 8 16 24 \n# 4\n# 9 17 24 25 \n# 4\n# 10 18 24 26 \n# 5\n# 11 19 25 26 27 \n# 4\n# 12 20 24 28 \n# 5\n# 13 21 25 28 29 \n# 5\n# 14 22 26 28 30 \n# 6\n# 15 23 27 29 30 31 \n# 1\n# 32\n# 3\n# 1 32 33 \n# 3\n# 2 32 34 \n# 4\n# 3 33 34 35 \n# 3\n# 4 32 36 \n# 4\n# 5 33 36 37 \n# 4\n# 6...\n# Checker Log\n# wrong answer a[1] OR a[2] is not n (test case 101)\n\n\n\nimport cmath\nimport heapq\nimport itertools\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom math import ceil, factorial, floor, gcd, inf\n\nxors = random.randint(1, 1000000000)\ncon = lambda x: x ^ xors\nnumber = lambda: int(sys.stdin.readline().strip())\nnumbers = lambda: list(map(int, sys.stdin.readline().strip().split()))\nwords = lambda: sys.stdin.readline().strip().split()\nword = lambda: sys.stdin.readline().strip()\nyn = lambda condition: \"YES\" if condition else \"NO\"\nprefixSum = lambda arr: list(itertools.accumulate(arr))\n\n\ndef increasing_sequence_fixed_or(t: int, test_cases: list[int]) -> list[tuple[int,list[int]]]:\n    results = []\n    for test in test_cases:\n        n = test\n        res = [n]\n        ons = []\n        for i in range(32):\n            if n & (1 << i):\n                ons.append(i)\n\n            def findnum(pos):\n                ret = 0\n                for i in range(32):\n                    if i != pos and n & (1 << i):\n                        ret |= 1 << i\n                return ret\n\n        for pos in ons:\n            if findnum(pos):\n                res.append(findnum(pos))\n        results.append((len(res), sorted(res)))\n    return results\n"
    }
  },
  {
    "id": "ingenuity_2",
    "requirements": {
      "signature": "def ingenuity_2(t: int, test_cases: list[tuple[int, str]]) -> list[str]",
      "description": "Let's imagine the surface of Mars as an infinite coordinate plane. Initially, the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the point with coordinates $(0, 0)$. A set of instructions $s$ consisting of $n$ instructions of the following types was specially developed for them:\n\n  * N: move one meter north (from point $(x, y)$ to $(x, y + 1)$);    * S: move one meter south (from point $(x, y)$ to $(x, y - 1)$);    * E: move one meter east (from point $(x, y)$ to $(x + 1, y)$);    * W: move one meter west (from point $(x, y)$ to $(x - 1, y)$). \n\nEach instruction must be executed either by the rover or by the helicopter. Moreover, each device must execute at least one instruction. Your task is to distribute the instructions in such a way that after executing all $n$ instructions, the helicopter and the rover end up at the same point, or determine that this is impossible.\n\n# Input:\nThe first line of input contains $t$ ($1 \\leq t \\leq 10^4$) — the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of instructions.\n\nThe second line of each test case contains a string $s$ of length $n$ consisting of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10 ^ 5$.\n\n# Output:\nFor each test case, if the required distribution of instructions exists, output a string $p$ of length $n$ consisting of the characters 'R', 'H'. If the $i$-th operation should be executed by the rover, then $p_i=\\text{R}$, if the $i$-th operation should be executed by the helicopter, then $p_i=\\text{H}$. If there are multiple solutions, output any of them.\n\nOtherwise, output NO.\n\n# Example input:\n10\n6\nNENSNE\n3\nWWW\n6\nNESSWS\n2\nSN\n2\nWE\n4\nSSNN\n4\nWESN\n2\nSS\n4\nEWNN\n4\nWEWE\n\n# Example output:\nRRHRRH\nNO\nHRRHRH\nNO\nNO\nRHRH\nRRHH\nRH\nRRRH\nRRHH\n\n# Notes:\nLet's consider the first example: the string $S = \\texttt{NENSNE}$. One of the possible solutions, shown in the figure below, is $p = \\texttt{RRHRRH}$, using which both the rover and the helicopter will end up one meter north and one meter east.\n\n![](CDN_BASE_URL/266d0d868dd4494e2ec9dbaf74403e88)\n\nFor WWW, the solution is impossible.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int, str]], results: list[str]) -> bool:\n    for (n, s), result in zip(test_cases, results):\n        if result == 'NO':\n            x_total = 0\n            y_total = 0\n            for c in s:\n                if c == 'E':\n                    x_total += 1\n                elif c == 'W':\n                    x_total -= 1\n                elif c == 'N':\n                    y_total += 1\n                elif c == 'S':\n                    y_total -= 1\n            if x_total % 2 != 0 or y_total % 2 != 0:\n                #return True\n                continue\n            if x_total == 0 and y_total == 0:\n                if n == 2:\n                    #return True\n                    continue\n                else:\n                    return False\n            return False\n        if len(result) != n:\n            return False\n        rx, ry, hx, hy = 0, 0, 0, 0\n        r_count, h_count = 0, 0\n        for i in range(n):\n            dx, dy = 0, 0\n            if s[i] == 'N': dy = 1\n            elif s[i] == 'S': dy = -1\n            elif s[i] == 'E': dx = 1\n            elif s[i] == 'W': dx = -1\n            if result[i] == 'R':\n                rx += dx\n                ry += dy\n                r_count += 1\n            elif result[i] == 'H':\n                hx += dx\n                hy += dy\n                h_count += 1\n            else:\n                return False\n        if not(rx == hx and ry == hy and r_count > 0 and h_count > 0):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(6, 'NENSNE')], ingenuity_2(1, [(6, 'NENSNE')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, 'WWW')], ingenuity_2(1, [(3, 'WWW')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(6, 'NESSWS')], ingenuity_2(1, [(6, 'NESSWS')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(2, 'SN')], ingenuity_2(1, [(2, 'SN')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(2, 'WE')], ingenuity_2(1, [(2, 'WE')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [(4, 'SSNN')], ingenuity_2(1, [(4, 'SSNN')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_7():\n    assert __judge(1, [(4, 'WESN')], ingenuity_2(1, [(4, 'WESN')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_8():\n    assert __judge(1, [(2, 'SS')], ingenuity_2(1, [(2, 'SS')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_9():\n    assert __judge(1, [(4, 'EWNN')], ingenuity_2(1, [(4, 'EWNN')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_10():\n    assert __judge(1, [(4, 'WEWE')], ingenuity_2(1, [(4, 'WEWE')]))"
      }
    ],
    "metadata": {
      "problem_id": "1974D",
      "url": "https://codeforces.com/problemset/problem/1974/D",
      "title": "Ingenuity-2",
      "rating": 1400,
      "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
      ],
      "div": "Div. 3",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 342212368\n# status: accepted\n\n# cook your dish here\n\ndef ingenuity_2(t: int, test_cases: list[tuple[int, str]]) -> list[str]:\n    results = []\n    for test in test_cases:\n        n, s = test\n\n        x,y=0,0 \n        for i in s:\n            if i=='N':\n                y+=1 \n            elif i=='S':\n                y-=1 \n            elif i=='W':\n                x-=1 \n            else:\n                x+=1 \n\n\n        if x%2==0 and y%2==0:\n            if x==y==0:\n                if 'S' in s and 'N' in s:\n                    s=list(s)\n                    ans=['H' for i in range(n)]\n                    idx1=s.index('S')\n                    idx2=s.index('N')\n                    ans[idx1]='R'\n                    ans[idx2]='R'\n                    if len(ans)==2:\n                        results.append(\"NO\")\n\n                    else:\n                        results.append(\"\".join(ans))\n\n                elif 'W' in s and 'E' in s:\n                    s=list(s)\n                    ans=['H' for i in range(n)]\n                    idx1=s.index('E')\n                    idx2=s.index('W')\n                    ans[idx1]='R'\n                    ans[idx2]='R'\n                    if len(ans)==2:\n                        results.append(\"NO\")\n                    else:\n                        results.append(\"\".join(ans))\n                else:\n                    results.append(\"NO\")\n\n            else:\n                ans=['H' for i in range(n)]\n\n                t1=('E' if x>0 else 'W')\n                t2=('N' if y>0 else 'S')\n\n                req1,req2=abs(x)//2,abs(y)//2 \n                # print(x,y)\n                for i in range(n):\n                    if s[i]==t1 and req1>0:\n                        req1-=1 \n                        ans[i]='R'\n                    if s[i]==t2 and req2>0:\n                        req2-=1\n                        ans[i]='R'\n                    if req1==req2==0:\n                        break \n\n                results.append(''.join(ans))\n\n\n\n\n        else:\n            results.append(\"NO\")\n\n    return results\n\n",
      "incorrect_solution": "# submission:  334536392\n\n#  Test: #2, time: 265 ms., memory: 8844 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 10000\n# 1\n# N\n# 1\n# S\n# 1\n# E\n# 1\n# W\n# 2\n# NN\n# 2\n# SN\n# 2\n# EN\n# 2\n# WN\n# 2\n# NS\n# 2\n# SS\n# 2\n# ES\n# 2\n# WS\n# 2\n# NE\n# 2\n# SE\n# 2\n# EE\n# 2\n# WE\n# 2\n# NW\n# 2\n# SW\n# 2\n# EW\n# 2\n# WW\n# 3\n# NNN\n# 3\n# SNN\n# 3\n# ENN\n# 3\n# WNN\n# 3\n# NSN\n# 3\n# SSN\n# 3\n# ESN\n# 3\n# WSN\n# 3\n# NEN\n# 3\n# SEN\n# 3\n# EEN\n# 3\n# WEN\n# 3\n# NWN\n# 3\n# SWN\n# 3\n# EWN\n# 3\n# WWN\n# 3\n# NNS\n# 3\n# SNS\n# 3\n# ENS\n# 3\n# WNS\n# 3\n# NSS\n# 3\n# SSS\n# 3\n# ESS\n# 3\n# WSS\n# 3\n# NES\n# 3\n# SES\n# 3\n# EES\n# 3\n# WES\n# 3\n# NWS\n# 3\n# SWS\n# 3\n# EWS\n# 3\n# WWS\n# 3\n# NNE\n# 3\n# SNE\n# 3\n# ENE\n# 3\n# WNE\n# 3\n# NSE\n# 3\n# SSE\n# 3\n# ESE\n# 3\n# WSE\n# 3\n# NEE\n# 3\n# SEE\n# 3\n# EEE\n# 3\n# WEE\n# 3\n# NWE\n# 3\n# SWE\n# ...\n# Output\n# NO\n# NO\n# NO\n# NO\n# HR\n# NO\n# NO\n# NO\n# NO\n# HR\n# NO\n# NO\n# NO\n# NO\n# HR\n# NO\n# NO\n# NO\n# NO\n# HR\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# HHRR\n# RHRR\n# NO\n# NO\n# HRRR\n# HRHR\n# NO\n# NO\n# NO\n# NO\n# HRHR\n# RRHR\n# NO\n# NO\n# RRHR\n# HRHR\n# HRRR\n# HHRR\n# NO\n# NO\n# HHRR\n# HRRH\n# NO\n# NO\n# NO\n# NO\n# HRRR\n# HHRR\n# NO\n# NO\n# HHRR\n# HRRR\n# NO\n# NO\n# HHRR\n# R...\n# Answer\n# NO\n# NO\n# NO\n# NO\n# RH\n# NO\n# NO\n# NO\n# NO\n# RH\n# NO\n# NO\n# NO\n# NO\n# RH\n# NO\n# NO\n# NO\n# NO\n# RH\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# RRHH\n# HRHH\n# NO\n# NO\n# RHHH\n# RHRH\n# NO\n# NO\n# NO\n# NO\n# RHRH\n# RRRH\n# NO\n# NO\n# RRRH\n# RHRH\n# RHHH\n# RRHH\n# NO\n# NO\n# RRHH\n# RHHH\n# NO\n# NO\n# NO\n# NO\n# RHHH\n# RRHH\n# NO\n# NO\n# RRHH\n# RHHH\n# NO\n# NO\n# RRHH\n# R...\n# Checker Log\n# wrong answer Rover at (0, -2), heli at (0, 0) (test case 106)\n\n\n\n\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport math\n\n\ndef ingenuity_2(t: int, test_cases: list[tuple[int, str]]) -> list[str]:\n    results = []\n    for test in test_cases:\n        n, ins = test\n        ans = ['R'] * n\n        x = y = 0\n        for v in ins:\n            if v == 'E':\n                x += 1\n            elif v == 'W':\n                x -= 1\n            elif v == 'N':\n                y += 1\n            else:\n                y -= 1\n        if x % 2 != 0 or y % 2 != 0 or (x == 0 and y == 0 and n <= 2):\n            results.append('NO')\n        else:\n            x //= 2\n            y //= 2\n            if x == 0 and y == 0:\n                ans[0] = 'H'\n                for i in range(1, n):\n                    if (ins[i] == 'W' and ins[0] == 'E') or (ins[i] == 'E' and ins[0] == 'W') or (ins[i] == 'N' and ins[0] == 'S') or (ins[i] == 'S' and ins[0] == 'N'):\n                        ans[i] = 'H'\n                        break\n            else:\n                for i, v in enumerate(ins):\n                    if (x > 0 and v == 'E') or (x < 0 and v == 'W'):\n                        ans[i] = 'H'\n                        x = x + 1 if x < 0 else x - 1\n                    if (y > 0 and v == 'N') or (y < 0 and v == 'S'):\n                        ans[i] = 'H'\n                        y = x + 1 if y < 0 else y - 1\n            results.append(''.join(ans))\n    return results\n"
    }
  },
  {
    "id": "manhattan_permutations",
    "requirements": {
      "signature": "def manhattan_permutations(t: int, test_cases: list[tuple[int,int]]) -> list[tuple[str,list[int]]]",
      "description": "Let's call the Manhattan value of a permutation$^{\\dagger}$ $p$ the value of the expression $|p_1 - 1| + |p_2 - 2| + \\ldots + |p_n - n|$.\n\nFor example, for the permutation $[1, 2, 3]$, the Manhattan value is $|1 - 1| + |2 - 2| + |3 - 3| = 0$, and for the permutation $[3, 1, 2]$, the Manhattan value is $|3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4$.\n\nYou are given integers $n$ and $k$. Find a permutation $p$ of length $n$ such that its Manhattan value is equal to $k$, or determine that no such permutation exists.\n\n$^{\\dagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\n# Input:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^{4}$) — the number of test cases. The description of the test cases follows.\n\nThe only line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^{5}, 0 \\le k \\le 10^{12}$) — the length of the permutation and the required Manhattan value.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^{5}$.\n\n# Output:\nFor each test case, if there is no suitable permutation, output \"No\". Otherwise, in the first line, output \"Yes\", and in the second line, output $n$ distinct integers $p_1, p_2, \\ldots, p_n$ ($1 \\le p_i \\le n$) — a suitable permutation.\n\nIf there are multiple solutions, output any of them.\n\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n# Example input:\n8\n3 4\n4 5\n7 0\n1 1000000000000\n8 14\n112 777\n5 12\n5 2\n\n# Example output:\nYes\n3 1 2\nNo\nYes\n1 2 3 4 5 6 7\nNo\nYes\n8 2 3 4 5 6 1 7\nNo\nYes\n5 4 3 1 2\nYes\n2 1 3 4 5\n\n# Notes:\nIn the first test case, the permutation $[3, 1, 2]$ is suitable, its Manhattan value is $|3 - 1| + |1 - 2| + |2 - 3| = 2 + 1 + 1 = 4$.\n\nIn the second test case, it can be proven that there is no permutation of length $4$ with a Manhattan value of $5$.\n\nIn the third test case, the permutation $[1,2,3,4,5,6,7]$ is suitable, its Manhattan value is $|1-1|+|2-2|+|3-3|+|4-4|+|5-5|+|6-6|+|7-7|=0$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int,int]], results: list[tuple[str,list[int]]]) -> bool:\n    for (n, k), result in zip(test_cases, results):\n        if isinstance(result, str) and result.upper() == 'NO':\n            max_val = (n * n) // 2\n            if not (k > max_val or k % 2 != 0):\n                return False\n            continue\n        if isinstance(result, str) or result[0].upper() != 'YES':\n            return False\n        perm = result[1]\n        if len(perm) != n:\n            return False\n        if sorted(perm) != list(range(1, n + 1)):\n            return False\n        manhattan = sum(abs(perm[i] - (i + 1)) for i in range(n))\n        if not( manhattan == k):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, 4)], manhattan_permutations(1, [(3, 4)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(4, 5)], manhattan_permutations(1, [(4, 5)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(7, 0)], manhattan_permutations(1, [(7, 0)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(1, 1000000000000)], manhattan_permutations(1, [(1, 1000000000000)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(8, 14)], manhattan_permutations(1, [(8, 14)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [(112, 777)], manhattan_permutations(1, [(112, 777)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_7():\n    assert __judge(1, [(5, 12)], manhattan_permutations(1, [(5, 12)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_8():\n    assert __judge(1, [(5, 2)], manhattan_permutations(1, [(5, 2)]))"
      }
    ],
    "metadata": {
      "problem_id": "1978C",
      "url": "https://codeforces.com/problemset/problem/1978/C",
      "title": "Manhattan Permutations",
      "rating": 1300,
      "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation",
        "math"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 337258409\n# status: accepted\n\ndef manhattan_permutations(t: int, test_cases: list[tuple[int,int]]) -> list[tuple[str,list[int]]]:\n    results = []\n    for test in test_cases:\n        n,k=test\n        a=[i for i in range(1,n+1)]\n        if k%2==1:\n            results.append(\"NO\")\n            continue\n        i=1\n        j=n\n        temp=0\n        while temp<k and i<=j:\n            if temp==k:\n                break\n            if temp+2*(j-i)<=k:\n                a[i-1],a[j-1]=a[j-1],a[i-1]\n                temp+=(2*(j-i))\n                i+=1\n                j-=1\n\n            else:\n                j-=1\n        if temp==k:\n            results.append((\"YES\", a))\n        else:\n            results.append(\"NO\")\n    return results\n",
      "incorrect_solution": "# submission: 341754597\n\n#  Test: #1, time: 77 ms., memory: 28 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 8\n# 3 4\n# 4 5\n# 7 0\n# 1 1000000000000\n# 8 14\n# 112 777\n# 5 12\n# 5 2\n# Output\n# Yes\n# 3 2 1\n# No\n# Yes\n# 1 2 3 4 5 6 7\n# No\n# Yes\n# 8 2 3 4 5 6 7 1\n# No\n# Yes\n# 5 3 2 1 4\n# Yes\n# 2 1 3 4 5\n# Answer\n# Yes\n# 3 2 1 \n# No\n# Yes\n# 1 2 3 4 5 6 7 \n# No\n# Yes\n# 8 2 3 4 5 6 7 1 \n# No\n# Yes\n# 5 4 3 2 1 \n# Yes\n# 2 1 3 4 5 \n# Checker Log\n# wrong answer Manhattan value isn't equal to k (test case 7)\n\n\n\ndef manhattan_permutations(t: int, test_cases: list[tuple[int,int]]) -> list[tuple[str,list[int]]]:\n    results = []\n    for test in test_cases:\n\n        size, target = test\n        maxsum = 0\n\n        for i in range(size):\n            maxsum += abs( size-i*2-1 )\n\n        if target % 2 or target > maxsum:\n            results.append(\"No\")\n            continue\n\n        array = []\n\n        target = target>>1\n\n        remaining = size\n\n        while 1:\n\n            currentmove = min(target,remaining-1)\n            target -= currentmove\n\n            if target != 0:\n                array.append(remaining)\n                remaining -= 1\n            else:\n                subarray = [ (i+1) for i in range(remaining) ]\n                temp = subarray[0]\n                subarray[0] = subarray[currentmove]\n                subarray[currentmove] = temp\n\n                array += subarray\n                break\n\n        results.append((\"Yes\", array))\n\n    return results\n"
    }
  },
  {
    "id": "manhattan_triangle",
    "requirements": {
      "signature": "def manhattan_triangle(t: int, test_cases: list[tuple[int, int, list[tuple[int, int]]]]) -> list[tuple[int, int, int]]",
      "description": "The Manhattan distance between two points $(x_1, y_1)$ and $(x_2, y_2)$ is defined as: $$|x_1 - x_2| + |y_1 - y_2|.$$\n\nWe call a Manhattan triangle three points on the plane, the Manhattan distances between each pair of which are equal.\n\nYou are given a set of pairwise distinct points and an even integer $d$. Your task is to find any Manhattan triangle, composed of three distinct points from the given set, where the Manhattan distance between any pair of vertices is equal to $d$.\n\n# Input:\nEach test consists of multiple test cases. The first line contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $d$ ($3 \\le n \\le 2 \\cdot 10^5$, $2 \\le d \\le 4 \\cdot 10^5$, $d$ is even) — the number of points and the required Manhattan distance between the vertices of the triangle.\n\nThe $(i + 1)$-th line of each test case contains two integers $x_i$ and $y_i$ ($-10^5 \\le x_i, y_i \\le 10^5$) — the coordinates of the $i$-th point. It is guaranteed that all points are pairwise distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output three distinct integers $i$, $j$, and $k$ ($1 \\le i,j,k \\le n$) — the indices of the points forming the Manhattan triangle. If there is no solution, output \"$0\\ 0\\ 0$\" (without quotes).\n\nIf there are multiple solutions, output any of them.\n\n# Example input:\n6\n6 4\n3 1\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n5 4\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n6 6\n3 1\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n4 4\n3 0\n0 3\n-3 0\n0 -3\n10 8\n2 1\n-5 -1\n-4 -1\n-5 -3\n0 1\n-2 5\n-4 4\n-4 2\n0 0\n-4 1\n4 400000\n100000 100000\n-100000 100000\n100000 -100000\n-100000 -100000\n\n# Example output:\n2 6 1\n4 3 5\n3 5 1\n0 0 0\n6 1 3\n0 0 0\n\n# Notes:\nIn the first test case:\n\n![](CDN_BASE_URL/d4e05137288270ab95be887865fe7aa8) Points $A$, $B$, and $F$ form a Manhattan triangle, the Manhattan distance between each pair of vertices is $4$. Points $D$, $E$, and $F$ can also be the answer.\n\nIn the third test case:\n\n![](CDN_BASE_URL/ccf6b49ba1a3bb8d87cffad3da846f32) Points $A$, $C$, and $E$ form a Manhattan triangle, the Manhattan distance between each pair of vertices is $6$.\n\nIn the fourth test case, there are no two points with a Manhattan distance of $4$, and therefore there is no suitable Manhattan triangle.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int, int, list[tuple[int, int]]]], results: list[tuple[int, int, int]]) -> bool:\n    for (n, d, points), result in zip(test_cases, results):\n        i, j, k = result\n        if (i, j, k) == (0, 0, 0):\n            sum_groups = {}\n            for idx, (x, y) in enumerate(points):\n                s = x + y\n                if s not in sum_groups:\n                    sum_groups[s] = []\n                sum_groups[s].append((x, idx))\n            for key in sum_groups:\n                sum_groups[key].sort()\n            found = False\n            for idx, (x, y) in enumerate(points):\n                s = x + y\n                if s not in sum_groups:\n                    continue\n                lst = sum_groups[s]\n                xs = [item[0] for item in lst]\n                target_x = x + (d // 2)\n                low = 0\n                high = len(xs)\n                while low < high:\n                    mid = (low + high) // 2\n                    if xs[mid] < target_x:\n                        low = mid + 1\n                    else:\n                        high = mid\n                pos = low\n                if pos < len(xs) and xs[pos] == target_x:\n                    s_plus = s + d\n                    if s_plus in sum_groups:\n                        third_list = sum_groups[s_plus]\n                        t_xs = [item[0] for item in third_list]\n                        x_min = target_x\n                        x_max = target_x + (d // 2)\n                        low3 = 0\n                        high3 = len(t_xs)\n                        while low3 < high3:\n                            mid3 = (low3 + high3) // 2\n                            if t_xs[mid3] < x_min:\n                                low3 = mid3 + 1\n                            else:\n                                high3 = mid3\n                        pos3 = low3\n                        if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                            found = True\n                            break\n                    if not found:\n                        s_minus = s - d\n                        if s_minus in sum_groups:\n                            third_list = sum_groups[s_minus]\n                            t_xs = [item[0] for item in third_list]\n                            x_min = x - (d // 2)\n                            x_max = target_x - (d // 2)\n                            low3 = 0\n                            high3 = len(t_xs)\n                            while low3 < high3:\n                                mid3 = (low3 + high3) // 2\n                                if t_xs[mid3] < x_min:\n                                    low3 = mid3 + 1\n                                else:\n                                    high3 = mid3\n                            pos3 = low3\n                            if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                                found = True\n                                break\n                if found:\n                    break\n            if not found:\n                diff_groups = {}\n                for idx, (x, y) in enumerate(points):\n                    diff = x - y\n                    if diff not in diff_groups:\n                        diff_groups[diff] = []\n                    diff_groups[diff].append((x, idx))\n                for key in diff_groups:\n                    diff_groups[key].sort()\n                for idx, (x, y) in enumerate(points):\n                    diff = x - y\n                    if diff not in diff_groups:\n                        continue\n                    lst = diff_groups[diff]\n                    xs = [item[0] for item in lst]\n                    target_x = x + (d // 2)\n                    low = 0\n                    high = len(xs)\n                    while low < high:\n                        mid = (low + high) // 2\n                        if xs[mid] < target_x:\n                            low = mid + 1\n                        else:\n                            high = mid\n                    pos = low\n                    if pos < len(xs) and xs[pos] == target_x:\n                        diff_plus = diff + d\n                        if diff_plus in diff_groups:\n                            third_list = diff_groups[diff_plus]\n                            t_xs = [item[0] for item in third_list]\n                            x_min = target_x\n                            x_max = target_x + (d // 2)\n                            low3 = 0\n                            high3 = len(t_xs)\n                            while low3 < high3:\n                                mid3 = (low3 + high3) // 2\n                                if t_xs[mid3] < x_min:\n                                    low3 = mid3 + 1\n                                else:\n                                    high3 = mid3\n                            pos3 = low3\n                            if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                                found = True\n                                break\n                        if not found:\n                            diff_minus = diff - d\n                            if diff_minus in diff_groups:\n                                third_list = diff_groups[diff_minus]\n                                t_xs = [item[0] for item in third_list]\n                                x_min = x - (d // 2)\n                                x_max = target_x - (d // 2)\n                                low3 = 0\n                                high3 = len(t_xs)\n                                while low3 < high3:\n                                    mid3 = (low3 + high3) // 2\n                                    if t_xs[mid3] < x_min:\n                                        low3 = mid3 + 1\n                                    else:\n                                        high3 = mid3\n                                pos3 = low3\n                                if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                                    found = True\n                                    break\n                    if found:\n                        break\n            if found:\n                return False\n        else:\n            if not (1 <= i <= n and 1 <= j <= n and 1 <= k <= n):\n                return False\n            if len({i-1, j-1, k-1}) != 3:\n                return False\n            p1 = points[i-1]\n            p2 = points[j-1]\n            p3 = points[k-1]\n            d12 = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n            d13 = abs(p1[0] - p3[0]) + abs(p1[1] - p3[1])\n            d23 = abs(p2[0] - p3[0]) + abs(p2[1] - p3[1])\n            if not( d12 == d and d13 == d and d23 == d):\n                return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(6, 4, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)])], manhattan_triangle(1, [(6, 4, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(5, 4, [(0, 0), (0, -2), (5, -3), (3, -5), (2, -2)])], manhattan_triangle(1, [(5, 4, [(0, 0), (0, -2), (5, -3), (3, -5), (2, -2)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(6, 6, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)])], manhattan_triangle(1, [(6, 6, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(4, 4, [(3, 0), (0, 3), (-3, 0), (0, -3)])], manhattan_triangle(1, [(4, 4, [(3, 0), (0, 3), (-3, 0), (0, -3)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(10, 8, [(2, 1), (-5, -1), (-4, -1), (-5, -3), (0, 1), (-2, 5), (-4, 4), (-4, 2), (0, 0), (-4, 1)])], manhattan_triangle(1, [(10, 8, [(2, 1), (-5, -1), (-4, -1), (-5, -3), (0, 1), (-2, 5), (-4, 4), (-4, 2), (0, 0), (-4, 1)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [(4, 400000, [(100000, 100000), (-100000, 100000), (100000, -100000), (-100000, -100000)])], manhattan_triangle(1, [(4, 400000, [(100000, 100000), (-100000, 100000), (100000, -100000), (-100000, -100000)])]))"
      }
    ],
    "metadata": {
      "problem_id": "1979E",
      "url": "https://codeforces.com/problemset/problem/1979/E",
      "title": "Manhattan Triangle",
      "rating": 2400,
      "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "geometry",
        "implementation",
        "two pointers"
      ],
      "div": "Div. 2",
      "time_limit_ms": 3000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  339391377\n# status: accepted\n\ndef BP(p, v, m):\n  l, r = -1, len(p)\n  while l < r-1:\n    b = (l+r)//2\n    x, i = p[b]\n    if x < v:\n      l = b\n    else:\n      r = b\n  if r == len(p): return None, None\n  x, i = p[r]\n  if x < v or x > m: return None, None\n  return x, i\ndef mini(p, d):\n  D = {}\n  V = {}\n  H = {}\n  for y, x, i in p:\n    if (y-d, x) in D:\n      i2 = D[(y-d, x)]\n      if x-d in V:\n        y2, i3 = V[(x-d)]\n        if y2 >= y-d:\n          return (i+1, i2+1, i3+1)\n      if x+d in V:\n        y2, i3 = V[(x+d)]\n        if y2 >= y-d:\n          return i+1, i2+1, i3+1\n    if (y, x-d) in D and y-d in H:\n      i2 = D[(y, x-d)]\n      x2, i3 = BP(H[y-d], x-d, x)\n      if i3 != None:\n        return (i+1, i2+1, i3+1)\n    D[(y, x)] = i\n    V[x] = (y, i)\n    if y not in H:\n      H[y] = [(x, i)]\n    else:\n      H[y].append((x, i))\n    return None\n\n\ndef manhattan_triangle(t: int, test_cases: list[tuple[int, int, list[tuple[int, int]]]]) -> list[tuple[int, int, int]]:\n  results = []\n  for test in test_cases:\n    n, d, pairs = test\n    p = []\n    for i, (a, b) in enumerate(pairs):\n        u, v = a+b, a-b\n        p.append((u, v, i))\n    p.sort()\n    result_1 = mini(p, d)\n    if result_1 is not None:\n      results.append(result_1)\n      continue\n    for i in range(n):\n      a, b, v = p[i]\n      p[i] = (-a, -b, v)\n    p.reverse()\n    result_2 = mini(p, d)\n    if result_2 is not None:\n      results.append(result_2)\n      continue      \n    results.append((0, 0, 0))\n  return results\n",
      "incorrect_solution": "# submission: 339391260\n\n#  Test: #2, time: 374 ms., memory: 8920 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 10000\n# 3 2\n# -2 -2\n# -2 -1\n# -2 0\n# 3 2\n# -2 -2\n# -2 -1\n# -2 1\n# 3 2\n# -2 -2\n# -2 -1\n# -2 2\n# 3 2\n# -2 -2\n# -2 -1\n# -1 -2\n# 3 2\n# -2 -2\n# -2 -1\n# -1 -1\n# 3 2\n# -2 -2\n# -2 -1\n# -1 0\n# 3 2\n# -2 -2\n# -2 -1\n# -1 1\n# 3 2\n# -2 -2\n# -2 -1\n# -1 2\n# 3 2\n# -2 -2\n# -2 -1\n# 0 -2\n# 3 2\n# -2 -2\n# -2 -1\n# 0 -1\n# 3 2\n# -2 -2\n# -2 -1\n# 0 0\n# 3 2\n# -2 -2\n# -2 -1\n# 0 1\n# 3 2\n# -2 -2\n# -2 -1\n# 0 2\n# 3 2\n# -2 -2\n# -2 -1\n# 1 -2\n# 3 2\n# -2 -2\n# -2 -1\n# 1 -1\n# 3 2\n# -2 -2\n# -2 -1\n# 1 0\n# 3 2\n# -2 -2\n# -2 -1\n# 1 1\n# 3 2\n# -2 -2\n# -2 -1\n# 1 2\n# 3 2\n# -2 -2\n# -2 -1\n# 2 -2\n# 3 2\n# -2 -2\n# -2 -1\n# 2 -1\n# 3 2\n# -2 ...\n# Output\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 3 1 2\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# ...\n# Answer\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 2 3 1\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# 0 0 0\n# ...\n# Checker Log\n# wrong answer points don't form a manhattan triangle with side 6 (test case 4605)\n\n\ndef BP(p, v, m):\n  l, r = -1, len(p)\n  while l < r-1:\n    b = (l+r)//2\n    x, i = p[b]\n    if x < v:\n      l = b\n    else:\n      r = b\n  if r == len(p): return None, None\n  x, i = p[r]\n  if x < v or x > m: return None, None\n  return x, i\ndef mini(p, d):\n  D = {}\n  V = {}\n  H = {}\n  for y, x, i in p:\n    if (y-d, x) in D:\n      i2 = D[(y-d, x)]\n      if x-d in V:\n        y2, i3 = V[(x-d)]\n        if y2 >= y-d:\n          return (i+1, i2+1, i3+1)\n      if x+d in V:\n        y2, i3 = V[(x+d)]\n        if y2 >= y-d:\n          return i+1, i2+1, i3+1\n    if (y, x-d) in D and y-d in H:\n      i2 = D[(y, x-d)]\n      x2, i3 = BP(H[y-d], x-d, x)\n      if i3 != None:\n        return (i+1, i2+1, i3+1)\n    D[(y, x)] = i\n    V[x] = (y, i)\n    if y not in H:\n      H[y] = [(x, i)]\n    else:\n      H[y].append((x, i))\n    return None\n\n\ndef manhattan_triangle(t: int, test_cases: list[tuple[int, int, list[tuple[int, int]]]]) -> list[tuple[int, int, int]]:\n  results = []\n  for test in test_cases:\n    n, d, pairs = test\n    p = []\n    for i, (a, b) in enumerate(pairs):    \n        u, v = a+b, a-b\n        p.append((u, v, i))\n    p.sort()\n    result_1 = mini(p, d)\n    if result_1 is not None:\n      results.append(result_1)\n      continue\n    for i in range(n):\n      a, b, i = p[i]\n      p[i] = (-a, -b, i)\n    p.reverse()\n    result_2 = mini(p, d)\n    if result_2 is not None:\n      results.append(result_2)\n      continue      \n    results.append((0, 0, 0))\n  return results\n"
    }
  },
  {
    "id": "medians_2032",
    "requirements": {
      "signature": "def medians_2032(t: int, test_cases: list[tuple[int,int]]) -> list[Union[int, tuple[int, list[int]]]]",
      "description": "You are given an array $a = [1, 2, \\ldots, n]$, where $n$ is odd, and an integer $k$.\n\nYour task is to choose an odd positive integer $m$ and to split $a$ into $m$ subarrays$^{\\dagger}$ $b_1, b_2, \\ldots, b_m$ such that:\n\n  * Each element of the array $a$ belongs to exactly one subarray.    * For all $1 \\le i \\le m$, $|b_i|$ is odd, i.e., the length of each subarray is odd.    * $\\operatorname{median}([\\operatorname{median}(b_1), \\operatorname{median}(b_2), \\ldots, \\operatorname{median}(b_m)]) = k$, i.e., the median$^{\\ddagger}$ of the array of medians of all subarrays must equal $k$. $\\operatorname{median}(c)$ denotes the median of the array $c$. \n\n$^{\\dagger}$A subarray of the array $a$ of length $n$ is the array $[a_l, a_{l + 1}, \\ldots, a_r]$ for some integers $1 \\le l \\le r \\le n$.\n\n$^{\\ddagger}$A median of the array of odd length is the middle element after the array is sorted in non-decreasing order. For example: $\\operatorname{median}([1,2,5,4,3]) = 3$, $\\operatorname{median}([3,2,1]) = 2$, $\\operatorname{median}([2,1,2,1,2,2,2]) = 2$.\n\n# Input:\nEach test consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 5000$) — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k \\le n < 2 \\cdot 10^5$, $n$ is odd) — the length of array $a$ and the desired median of the array of medians of all subarrays.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case:\n\n  * If there is no suitable partition, output $-1$ in a single line.    * Otherwise, in the first line, output an odd integer $m$ ($1 \\le m \\le n$), and in the second line, output $m$ distinct integers $p_1, p_2 , p_3 , \\ldots, p_m$ ($1 = p_1 < p_2 < p_3 < \\ldots < p_m \\le n$) — denoting the left borders of each subarray. \n\nIn detail, for a valid answer $[p_1, p_2, \\ldots, p_m]$:\n\n  * $b_1 = \\left[ a_{p_1}, a_{p_1 + 1}, \\ldots, a_{p_2 - 1} \\right]$    * $b_2 = \\left[ a_{p_2}, a_{p_2 + 1}, \\ldots, a_{p_3 - 1} \\right]$    * $\\ldots$    * $b_m = \\left[ a_{p_m}, a_{p_m + 1}, \\ldots, a_n \\right]$. \n\nIf there are multiple solutions, you can output any of them.\n\n# Example input:\n4\n1 1\n3 2\n3 3\n15 8\n\n# Example output:\n1\n1\n3\n1 2 3\n-1\n5\n1 4 7 10 13\n\n# Notes:\nIn the first test case, the given partition has $m = 1$ and $b_1 = [1]$. It is obvious that $\\operatorname{median}([\\operatorname{median}([1])]) = \\operatorname{median}([1]) = 1$.\n\nIn the second test case, the given partition has $m = 3$ and:\n\n  * $b_1 = [1]$    * $b_2 = [2]$    * $b_3 = [3]$ \n\nTherefore, $\\operatorname{median}([\\operatorname{median}([1]), \\operatorname{median}([2]), \\operatorname{median}([3])]) = \\operatorname{median}([1, 2, 3]) = 2$.\n\nIn the third test case, there is no valid partition for $k = 3$.\n\nIn the fourth test case, the given partition has $m = 5$ and:\n\n  * $b_1 = [1, 2, 3]$    * $b_2 = [4, 5, 6]$    * $b_3 = [7, 8, 9]$    * $b_4 = [10, 11, 12]$    * $b_5 = [13, 14, 15]$ \n\nTherefore, $\\operatorname{median}([\\operatorname{median}([1, 2, 3]), \\operatorname{median}([4, 5, 6]), \\operatorname{median}([7, 8, 9]), \\operatorname{median}([10, 11, 12]), \\operatorname{median}([13, 14, 15])]) = \\operatorname{median}([2, 5, 8, 11, 14]) = 8$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int,int]], results: list[Union[int, tuple[int, list[int]]]]) -> bool:\n    for (n, k), result in zip(test_cases, results):\n        if result == -1:\n            if not((n > 1) and (k == 1 or k == n)):\n                return False\n            continue\n        m = result[0]\n        if m % 2 == 0:\n            return False\n        p = result[1]\n        if len(p)!=m:\n            return False\n        if p[0]!=1:\n            return False\n        for i in range(1, m):\n            if p[i]<=p[i-1]:\n                return False\n        if p[-1]>n:\n            return False\n        starts = p\n        ends = []\n        for i in range(m-1):\n            ends.append(p[i+1]-1)\n        ends.append(n)\n        for i in range(m):\n            s = starts[i]\n            e = ends[i]\n            if s>e or e>n: return False\n            if (e - s +1) %2 ==0: return False\n        medians = []\n        for i in range(m):\n            s = starts[i]\n            e = ends[i]\n            mid = (s + e) //2\n            medians.append(mid)\n        medians.sort()\n        if not (medians[len(medians)//2] ==k):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(1, 1)], medians_2032(1, [(1, 1)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, 2)], medians_2032(1, [(3, 2)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(3, 3)], medians_2032(1, [(3, 3)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(15, 8)], medians_2032(1, [(15, 8)]))"
      }
    ],
    "metadata": {
      "problem_id": "2032B",
      "url": "https://codeforces.com/problemset/problem/2032/B",
      "title": "Medians",
      "rating": 1100,
      "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
      ],
      "div": "Div. 2",
      "time_limit_ms": 1000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  341664390\n# status: accepted\n\nfrom bisect import bisect_left\nimport sys\n\ninput = lambda: sys.stdin.readline().strip()\nints = lambda: list(map(int, input().split()))\n\n\"\"\"\n1 2 3 4 5\npossible m:\n1, 3, 5\n\n1 2 3 4 5 6 7 8 9\npossible m:\n1, 3, 5, 7, 9\npossible k?\n\n1 no\n(1)(2)(3 4 5 6 7 8 9)   --> 2\n(1) (2 3 4) (5 6 7 8 9) --> 3\n(1 2 3) (4) (5 6 7 8 9) --> 4\n(1 2 3 4 5 6 7 8 9)     --> 5\n(1 2 3 4 5) (6) (7 8 9) --> 6\n(1 2 3 4 5) (6 7 8) (9) --> 7\n(1 2 3 4 5 6 7) (8) (9) --> 8\n9 no\n\n1 2 3 4 5 6 7 8 9 10 11\n5:\n(1 2 3) (4 5 6) (7 8 9 10 11)\n\n1 2 3 4 5 6 7 8 9 10 11 12 13\n5:\n(1 2 3) (4 5 6) (7 8 9 10 11 12 13)\n\nfor even:\nm = 3, pick idx\n\nfor odd:\nm = 3\n\"\"\"\n\ndef medians_2032(t: int, test_cases: list[tuple[int,int]]) -> list[Union[int, tuple[int, list[int]]]]:\n    results = []\n    for test in test_cases:\n        n, k = test\n\n        if n == 1:\n            results.append((1,[1]))\n            continue\n\n        if k == 1 or k == n:\n            results.append(-1)\n            continue\n\n        ans = [1]\n        if k % 2 == 0:\n            ans.append(k)\n            ans.append(k+1)\n        else:\n            ans.append(k-1)\n            ans.append(k+2)\n        results.append((3, [1, ans[1], ans[2]]))\n\n    return results\n",
      "incorrect_solution": "# submission: 339440491\n\n#  Test: #2, time: 109 ms., memory: 5736 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 2823\n# 1 1\n# 3 1\n# 3 2\n# 3 3\n# 5 1\n# 5 2\n# 5 3\n# 5 4\n# 5 5\n# 7 1\n# 7 2\n# 7 3\n# 7 4\n# 7 5\n# 7 6\n# 7 7\n# 9 1\n# 9 2\n# 9 3\n# 9 4\n# 9 5\n# 9 6\n# 9 7\n# 9 8\n# 9 9\n# 11 1\n# 11 2\n# 11 3\n# 11 4\n# 11 5\n# 11 6\n# 11 7\n# 11 8\n# 11 9\n# 11 10\n# 11 11\n# 13 1\n# 13 2\n# 13 3\n# 13 4\n# 13 5\n# 13 6\n# 13 7\n# 13 8\n# 13 9\n# 13 10\n# 13 11\n# 13 12\n# 13 13\n# 15 1\n# 15 2\n# 15 3\n# 15 4\n# 15 5\n# 15 6\n# 15 7\n# 15 8\n# 15 9\n# 15 10\n# 15 11\n# 15 12\n# 15 13\n# 15 14\n# 15 15\n# 17 1\n# 17 2\n# 17 3\n# 17 4\n# 17 5\n# 17 6\n# 17 7\n# 17 8\n# 17 9\n# 17 10\n# 17 11\n# 17 12\n# 17 13\n# 17 14\n# 17 15\n# 17 16\n# 17 17\n# 19 1\n# 19 2\n# 19 3\n# 19 4\n# ...\n# Output\n# 1\n# 1\n# -1\n# 3\n# 1 2 3\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 3 4\n# 3\n# 1 4 5\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 3 4\n# 3\n# 1 4 5\n# 3\n# 1 5 6\n# 3\n# 1 6 7\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 3 4\n# 3\n# 1 4 5\n# 3\n# 1 5 6\n# 3\n# 1 6 7\n# 3\n# 1 7 8\n# 3\n# 1 8 9\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 3 4\n# 3\n# 1 4 5\n# 3\n# 1 5 6\n# 3\n# 1 6 7\n# 3\n# 1 7 8\n# 3\n# 1 8 9\n# 3\n# 1 9 10\n# 3\n# 1 10 11\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 3 4\n# 3\n# 1 4 5\n# 3\n# 1 5 6\n# 3\n# 1 6 7\n# 3\n# 1 7 8\n# 3\n# 1 8 9\n# 3\n# 1 9 10\n# 3\n# 1 10 11\n# 3\n# 1 11 12\n# 3\n# 1 12 13\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 3 4\n# 3\n# 1 4 5\n# 3\n# 1 5 6\n# 3\n# 1 6 7\n# 3\n# 1 7 8\n# 3\n# 1 8 9\n# 3\n# 1 9 10\n# 3\n# ...\n# Answer\n# 1\n# 1\n# -1\n# 3\n# 1 2 3\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 2 5\n# 3\n# 1 4 5\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 2 5\n# 3\n# 1 4 5\n# 3\n# 1 4 7\n# 3\n# 1 6 7\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 2 5\n# 3\n# 1 4 5\n# 3\n# 1 4 7\n# 3\n# 1 6 7\n# 3\n# 1 6 9\n# 3\n# 1 8 9\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 2 5\n# 3\n# 1 4 5\n# 3\n# 1 4 7\n# 3\n# 1 6 7\n# 3\n# 1 6 9\n# 3\n# 1 8 9\n# 3\n# 1 8 11\n# 3\n# 1 10 11\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 2 5\n# 3\n# 1 4 5\n# 3\n# 1 4 7\n# 3\n# 1 6 7\n# 3\n# 1 6 9\n# 3\n# 1 8 9\n# 3\n# 1 8 11\n# 3\n# 1 10 11\n# 3\n# 1 10 13\n# 3\n# 1 12 13\n# -1\n# -1\n# 3\n# 1 2 3\n# 3\n# 1 2 5\n# 3\n# 1 4 5\n# 3\n# 1 4 7\n# 3\n# 1 6 7\n# 3\n# 1 6 9\n# 3\n# 1 8 9\n# 3\n# 1 8 11\n# 3\n# ...\n# Checker Log\n# wrong answer 2-th subarray has even length (test case 7)\n\n\n\nimport sys\n\n\ndef solve(n, k):\n    if k == 1 and n == 1:\n        return [1]\n    if k == 1 or k == n:\n        return -1\n    \n    return [1, k, k + 1]\n\n\ndef medians_2032(t: int, test_cases: list[tuple[int,int]]) -> list[Union[int, tuple[int, list[int]]]]:\n    results = []\n    for test in test_cases:\n        n, k = test\n        res = solve(n, k)\n        if res != -1:\n            results.append((len(res), res))\n        else:\n            results.append(res)\n    return results\n"
    }
  },
  {
    "id": "minimise_oneness",
    "requirements": {
      "signature": "def minimise_oneness(t: int, test_cases: list[int]) -> list[str]",
      "description": "For an arbitrary binary string $t$$^{\\text{∗}}$, let $f(t)$ be the number of non-empty subsequences$^{\\text{†}}$ of $t$ that contain only $\\mathtt{0}$, and let $g(t)$ be the number of non-empty subsequences of $t$ that contain at least one $\\mathtt{1}$.\n\nNote that for $f(t)$ and for $g(t)$, each subsequence is counted as many times as it appears in $t$. E.g., $f(\\mathtt{000}) = 7, g(\\mathtt{100}) = 4$.\n\nWe define the oneness of the binary string $t$ to be $|f(t)-g(t)|$, where for an arbitrary integer $z$, $|z|$ represents the absolute value of $z$.\n\nYou are given a positive integer $n$. Find a binary string $s$ of length $n$ such that its oneness is as small as possible. If there are multiple strings, you can print any of them.\n\n$^{\\text{∗}}$A binary string is a string that only consists of characters $\\texttt{0}$ and $\\texttt{1}$.\n\n$^{\\text{†}}$A sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements. For example, subsequences of $\\mathtt{1011101}$ are $\\mathtt{0}$, $\\mathtt{1}$, $\\mathtt{11111}$, $\\mathtt{0111}$, but not $\\mathtt{000}$ nor $\\mathtt{11100}$.\n\n# Input:\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) — the number of test cases.\n\nThe only line of each test case contains an integer $n$ ($1 \\leq n \\leq 2\\cdot10^5$) — the length of $s$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot10^5$.\n\n# Output:\nFor each test case, output $s$ on a new line. If multiple answers exist, output any.\n\n# Example input:\n3\n1\n2\n3\n\n# Example output:\n0\n01\n010\n\n# Notes:\nIn the first test case, for the example output, $f(t)=1$ because there is one subsequence that contains only $\\mathtt{0}$ ($\\mathtt{0}$), and $g(t)=0$ because there are no subsequences that contain at least one $1$. The oneness is $|1-0|=1$. The output $\\mathtt{1}$ is correct as well because its oneness is $|0-1|=1$.\n\nFor the example output of the second test case, $f(t)=1$ because there is one non-empty subsequence that contains only $\\mathtt{0}$, and $g(t)=2$ because there are two non-empty subsequences that contain at least one $\\mathtt{1}$ ($\\mathtt{01}$ and $\\mathtt{1}$). The oneness is thus $|1-2|=1$. It can be shown that $1$ is the minimum possible value of its oneness over all possible binary strings of size $2$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int], results: list[str]) -> bool:\n    for (n, result) in zip(test_cases, results):\n        if len(result) != n:\n            return False\n        if not all(c in '01' for c in result):\n            return False\n        count0 = result.count('0')\n        count1 = result.count('1')\n        f_val = (1 << count0) - 1\n        g_val = (1 << n) - 1 - f_val\n        oneness = abs(f_val - g_val)\n        if not(oneness == 1):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [1], minimise_oneness(1, [1]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [2], minimise_oneness(1, [2]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [3], minimise_oneness(1, [3]))"
      }
    ],
    "metadata": {
      "problem_id": "2030B",
      "url": "https://codeforces.com/problemset/problem/2030/B",
      "title": "Minimise Oneness",
      "rating": 800,
      "tags": [
        "combinatorics",
        "constructive algorithms",
        "games",
        "math"
      ],
      "div": "Div. 2",
      "time_limit_ms": 1500,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 342191480\n# status: accepted\n\ndef minimise_oneness(t: int, test_cases: list[int]) -> list[str]:\n    results = []\n    for n in test_cases:\n        results.append('1' + ('0'*(n-1)))\n    return results\n",
      "incorrect_solution": "# submission: 341541139\n\n# Test: #2, time: 62 ms., memory: 28 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 630\n# 1\n# 2\n# 3\n# 4\n# 5\n# 6\n# 7\n# 8\n# 9\n# 10\n# 11\n# 12\n# 13\n# 14\n# 15\n# 16\n# 17\n# 18\n# 19\n# 20\n# 21\n# 22\n# 23\n# 24\n# 25\n# 26\n# 27\n# 28\n# 29\n# 30\n# 31\n# 32\n# 33\n# 34\n# 35\n# 36\n# 37\n# 38\n# 39\n# 40\n# 41\n# 42\n# 43\n# 44\n# 45\n# 46\n# 47\n# 48\n# 49\n# 50\n# 51\n# 52\n# 53\n# 54\n# 55\n# 56\n# 57\n# 58\n# 59\n# 60\n# 61\n# 62\n# 63\n# 64\n# 65\n# 66\n# 67\n# 68\n# 69\n# 70\n# 71\n# 72\n# 73\n# 74\n# 75\n# 76\n# 77\n# 78\n# 79\n# 80\n# 81\n# 82\n# 83\n# 84\n# 85\n# 86\n# 87\n# 88\n# 89\n# 90\n# 91\n# 92\n# 93\n# 94\n# 95\n# 96\n# 97\n# 98\n# 99\n# 100\n# 101\n# 102\n# 103\n# 104\n# 105\n# 106\n# 107\n# 108\n# 109\n# 110\n# 111\n# 112\n# 113\n# 114\n# 115\n# 116\n# 117\n# 118\n# 119\n# 120\n# 121\n# 122\n# 123\n# ...\n# Output\n# 0\n# 01\n# 001\n# 0011\n# 00011\n# 000111\n# 0000111\n# 00001111\n# 000001111\n# 0000011111\n# 00000011111\n# 000000111111\n# 0000000111111\n# 00000001111111\n# 000000001111111\n# 0000000011111111\n# 00000000011111111\n# 000000000111111111\n# 0000000000111111111\n# 00000000001111111111\n# 000000000001111111111\n# 0000000000011111111111\n# 00000000000011111111111\n# 000000000000111111111111\n# 0000000000000111111111111\n# 00000000000001111111111111\n# 000000000000001111111111111\n# 0000000000000011111111111111\n# 00000000000000011111111111111\n# 000000000000000111...\n# Answer\n# 1\n# 10\n# 100\n# 1000\n# 10000\n# 100000\n# 1000000\n# 10000000\n# 100000000\n# 1000000000\n# 10000000000\n# 100000000000\n# 1000000000000\n# 10000000000000\n# 100000000000000\n# 1000000000000000\n# 10000000000000000\n# 100000000000000000\n# 1000000000000000000\n# 10000000000000000000\n# 100000000000000000000\n# 1000000000000000000000\n# 10000000000000000000000\n# 100000000000000000000000\n# 1000000000000000000000000\n# 10000000000000000000000000\n# 100000000000000000000000000\n# 1000000000000000000000000000\n# 10000000000000000000000000000\n# 100000000000000000...\n# Checker Log\n# wrong answer jury has better answer (test case 4)\n\ndef minimise_oneness(t: int, test_cases: list[int]) -> list[str]:\n    results = []\n    for n in test_cases:\n        if n % 2:\n            results.append(('0'*(n//2+1)) + ('1'*(n//2)))\n        else:\n            results.append(('0'*(n//2)) + ('1'*(n//2)))\n    return results\n"
    }
  },
  {
    "id": "perpendicular_segments",
    "requirements": {
      "signature": "def perpendicular_segments(t: int, test_cases: list[tuple[int, int, int]]) -> list[tuple[tuple[int, int, int, int], tuple[int, int, int, int]]]",
      "description": "You are given a coordinate plane and three integers $X$, $Y$, and $K$. Find two line segments $AB$ and $CD$ such that\n\n  1. the coordinates of points $A$, $B$, $C$, and $D$ are integers;    2. $0 \\le A_x, B_x, C_x, D_x \\le X$ and $0 \\le A_y, B_y, C_y, D_y \\le Y$;    3. the length of segment $AB$ is at least $K$;    4. the length of segment $CD$ is at least $K$;    5. segments $AB$ and $CD$ are perpendicular: if you draw lines that contain $AB$ and $CD$, they will cross at a right angle. \n\nNote that it's not necessary for segments to intersect. Segments are perpendicular as long as the lines they induce are perpendicular.\n\n# Input:\nThe first line contains a single integer $t$ ($1 \\le t \\le 5000$) — the number of test cases. Next, $t$ cases follow.\n\nThe first and only line of each test case contains three integers $X$, $Y$, and $K$ ($1 \\le X, Y \\le 1000$; $1 \\le K \\le 1414$).\n\nAdditional constraint on the input: the values of $X$, $Y$, and $K$ are chosen in such a way that the answer exists.\n\n# Output:\nFor each test case, print two lines. The first line should contain $4$ integers $A_x$, $A_y$, $B_x$, and $B_y$ — the coordinates of the first segment.\n\nThe second line should also contain $4$ integers $C_x$, $C_y$, $D_x$, and $D_y$ — the coordinates of the second segment.\n\nIf there are multiple answers, print any of them.\n\n# Example input:\n4\n1 1 1\n3 4 1\n4 3 3\n3 4 4\n\n# Example output:\n0 0 1 0\n0 0 0 1\n2 4 2 2\n0 1 1 1\n0 0 1 3\n1 2 4 1\n0 1 3 4\n0 3 3 0\n\n# Notes:\nThe answer for the first test case is shown below:\n\n![](CDN_BASE_URL/fde49f7448aea636de500404fb8804d1) The answer for the second test case:  ![](CDN_BASE_URL/218ed75e7877cea15a02e0b20b635ea4) The answer for the third test case:  ![](CDN_BASE_URL/a78511ad84067550d68b03ae1de99762) The answer for the fourth test case: ![](CDN_BASE_URL/e06aa850f6b8b3b4ee28ceaee5c5b478)\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int, int, int]], results: list[tuple[tuple[int, int, int, int], tuple[int, int, int, int]]]) -> bool:\n    for (X, Y, K), result in zip(test_cases, results):\n        (Ax, Ay, Bx, By), (Cx, Cy, Dx, Dy) = result\n        for coord in [Ax, Bx, Cx, Dx]:\n            if not (0 <= coord <= X):\n                return False\n        for coord in [Ay, By, Cy, Dy]:\n            if not (0 <= coord <= Y):\n                return False\n        len_AB_squared = (Bx - Ax)**2 + (By - Ay)**2\n        len_CD_squared = (Dx - Cx)**2 + (Dy - Cy)**2\n        if len_AB_squared < K*K or len_CD_squared < K*K:\n            return False\n        vec_AB = (Bx - Ax, By - Ay)\n        vec_CD = (Dx - Cx, Dy - Cy)\n        if vec_AB == (0, 0) or vec_CD == (0, 0):\n            return False\n        dot_product = vec_AB[0] * vec_CD[0] + vec_AB[1] * vec_CD[1]\n        if not (dot_product == 0):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(1, 1, 1)], perpendicular_segments(1, [(1, 1, 1)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, 4, 1)], perpendicular_segments(1, [(3, 4, 1)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(4, 3, 3)], perpendicular_segments(1, [(4, 3, 3)]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(3, 4, 4)], perpendicular_segments(1, [(3, 4, 4)]))"
      }
    ],
    "metadata": {
      "problem_id": "2026A",
      "url": "https://codeforces.com/problemset/problem/2026/A",
      "title": "Perpendicular Segments",
      "rating": 900,
      "tags": [
        "constructive algorithms",
        "geometry",
        "greedy",
        "math"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission:  342772343\n# status: accepted\n\ndef perpendicular_segments(t: int, test_cases: list[tuple[int, int, int]]) -> list[tuple[tuple[int, int, int, int], tuple[int, int, int, int]]]:\n    results = []\n    for test in test_cases:\n        x,y,k=test\n        results.append(((0,0,min(x,y),min(x,y)), (0,min(x,y),min(x,y),0)))\n    return results\n",
      "incorrect_solution": "# submission: 342714181\n\n#  Test: #1, time: 46 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 4\n# 1 1 1\n# 3 4 1\n# 4 3 3\n# 3 4 4\n# Output\n# 0 0 1 0\n# 0 0 0 1\n# 0 0 1 0\n# 0 0 0 1\n# 0 0 3 0\n# 0 0 0 3\n# 0 0 3 4\n# 0 4 3 0\n# Answer\n# 0 0 1 1\n# 0 1 1 0\n# 0 0 3 3\n# 0 3 3 0\n# 0 0 3 3\n# 0 3 3 0\n# 0 0 3 3\n# 0 3 3 0\n# Checker Log\n# wrong answer AB and CD are not perpendicular (test case 4)\n\n\n\ndef perpendicular_segments(t: int, test_cases: list[tuple[int, int, int]]) -> list[tuple[tuple[int, int, int, int], tuple[int, int, int, int]]]:\n    results = []\n    for test in test_cases:\n        X,Y,K=test\n        if X >= K and Y >= K:\n            results.append(((0, 0, K, 0), (0, 0, 0, K)))\n        else:\n            results.append(((0, 0, X, Y), (0, Y, X, 0)))\n    return results\n            \n"
    }
  },
  {
    "id": "prime_xor_coloring",
    "requirements": {
      "signature": "def prime_xor_coloring(t: int, test_cases: list[int]) -> list[tuple[int, list[int]]]",
      "description": "You are given an undirected graph with $n$ vertices, numbered from $1$ to $n$. There is an edge between vertices $u$ and $v$ if and only if $u \\oplus v$ is a [prime number](https://en.wikipedia.org/wiki/Prime_number), where $\\oplus$ denotes the [bitwise XOR operator](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).\n\nColor all vertices of the graph using the minimum number of colors, such that no two vertices directly connected by an edge have the same color.\n\n# Input:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 500$). The description of test cases follows.\n\nThe only line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of vertices in the graph.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output two lines.\n\nThe first line should contain a single integer $k$ ($1 \\le k \\le n$) — the minimum number of colors required.\n\nThe second line should contain $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\le c_i \\le k$) — the color of each vertex.\n\nIf there are multiple solutions, output any of them.\n\n# Example input:\n6\n1\n2\n3\n4\n5\n6\n\n# Example output:\n1\n1\n2\n1 2\n2\n1 2 2\n3\n1 2 2 3\n3\n1 2 2 3 3\n4\n1 2 2 3 3 4\n\n# Notes:\nIn the first test case, the minimum number of colors is $1$, because there is only one vertex.\n\nIn the second test case, the minimum number of colors is $2$, because there is an edge connecting $1$ and $2$ ($1 \\oplus 2 = 3$, which is a prime number).\n\nIn the third test case, the minimum number of colors is still $2$, because $2$ and $3$ can be colored the same since there is no edge between $2$ and $3$ ($2 \\oplus 3 = 1$, which is not a prime number).\n\nIn the fourth test case, it can be shown that the minimum number of colors is $3$.\n\nIn the fifth test case, it can be shown that the minimum number of colors is $3$.\n\nIn the sixth test case, it can be shown that the minimum number of colors is $4$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int], results: list[tuple[int, list[int]]]) -> bool:\n    for (n, result) in zip(test_cases, results):\n        k,colors=result\n        if n==1: optimal_k=1\n        elif n==2: optimal_k=2\n        elif n==3: optimal_k=2\n        elif n==4: optimal_k=3\n        elif n==5: optimal_k=3\n        else: optimal_k=4\n        if k!=optimal_k: return False\n        if not isinstance(colors,(list,tuple)): return False\n        if len(colors)!=n: return False\n        if any((not isinstance(c,int)) or c<1 or c>k for c in colors): return False\n        import math\n        size=1\n        while size< n+1: size<<=1\n        sieve=bytearray(b'\\x01')*size\n        sieve[0:2]=b'\\x00\\x00'\n        limit=int(math.isqrt(size-1))\n        for i in range(2,limit+1):\n            if sieve[i]: sieve[i*i:size:i]=b'\\x00'*(((size-1-i*i)//i)+1)\n        primes=[i for i,is_p in enumerate(sieve) if is_p]\n        def fwht(a):\n            n2=len(a)\n            h=1\n            while h<n2:\n                step=h<<1\n                for i in range(0,n2,step):\n                    for j in range(i,i+h):\n                        x=a[j]; y=a[j+h]\n                        a[j]=x+y; a[j+h]=x-y\n                h<<=1\n        for col_id in range(1,k+1):\n            arr=[0]*size\n            for i,c in enumerate(colors, start=1):\n                if c==col_id: arr[i]=1\n            fa=arr[:]\n            fwht(fa)\n            for i in range(len(fa)): fa[i]=fa[i]*fa[i]\n            fwht(fa)\n            for i in range(len(fa)): fa[i]//=size\n            for p in primes:\n                if fa[p]>0: return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [1], prime_xor_coloring(1, [1]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [2], prime_xor_coloring(1, [2]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [3], prime_xor_coloring(1, [3]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [4], prime_xor_coloring(1, [4]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [5], prime_xor_coloring(1, [5]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [6], prime_xor_coloring(1, [6]))"
      }
    ],
    "metadata": {
      "problem_id": "1991D",
      "url": "https://codeforces.com/problemset/problem/1991/D",
      "title": "Prime XOR Coloring",
      "rating": 1900,
      "tags": [
        "bitmasks",
        "constructive algorithms",
        "graphs",
        "greedy",
        "math",
        "number theory"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 341535114\n# status: accepted\n\nimport sys,threading\nfrom collections import defaultdict, Counter, deque\nfrom bisect import bisect_left, bisect_right, insort\nimport random\nimport math\nfrom heapq import heapify, heappush, heappop\nfrom random import getrandbits\nfrom itertools import accumulate\nfrom functools import reduce\nfrom operator import add, sub, mul, truediv, floordiv, mod, pow, neg, and_, or_, xor, inv, lshift, rshift\nRANDOM = getrandbits(32)\nMOD = 10 ** 9 + 7\ninf = float('inf')\ndef precision(val, x):\n    return f\"{val:.{x}f}\"\nclass Wrapper(int):\n    def __init__(self, x):\n        int.__init__(x)\n    def __hash__(self):\n        return super(Wrapper, self).__hash__() ^ RANDOM\n\ndef prime_xor_coloring(t: int, test_cases: list[int]) -> list[tuple[int, list[int]]]:\n    results = []\n    for n in test_cases:\n        ans = [[1],[1,2],[1,2,2],[1,2,2,3],[1,2,2,3,3]]\n        if n <= 5:\n            results.append((len(set(ans[n - 1])), ans[n - 1]))\n            continue\n        ans = [i % 4 + 1 for i in range(1,n + 1)]\n        results.append((4, ans))\n    return results\n",
      "incorrect_solution": "# submission: 341534730\n\n#  Test: #1, time: 109 ms., memory: 3532 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 6\n# 1\n# 2\n# 3\n# 4\n# 5\n# 6\n# Output\n# 1\n# 1 2\n# 1 2 2\n# 1 2 2 3\n# 1 2 2 3 3\n# 2 3 4 1 2 3\n# Answer\n# 1\n# 1 \n# 2\n# 1 2 \n# 2\n# 1 2 2 \n# 3\n# 1 2 2 3 \n# 3\n# 1 2 2 3 3 \n# 4\n# 2 3 4 1 2 3\n# Checker Log\n# wrong answer Integer parameter [name=color of the vertex] equals to 4, violates the range [1, 3] (test case 5)\n\n\n\nimport sys,threading\nfrom collections import defaultdict, Counter, deque\nfrom bisect import bisect_left, bisect_right, insort\nimport random\nimport math\nfrom heapq import heapify, heappush, heappop\nfrom random import getrandbits\nfrom itertools import accumulate\nfrom functools import reduce\nfrom operator import add, sub, mul, truediv, floordiv, mod, pow, neg, and_, or_, xor, inv, lshift, rshift\nRANDOM = getrandbits(32)\nMOD = 10 ** 9 + 7\ninf = float('inf')\ndef precision(val, x):\n    return f\"{val:.{x}f}\"\nclass Wrapper(int):\n    def __init__(self, x):\n        int.__init__(x)\n    def __hash__(self):\n        return super(Wrapper, self).__hash__() ^ RANDOM\n\ndef prime_xor_coloring(t: int, test_cases: list[int]) -> list[tuple[int, list[int]]]:\n    results = []\n    for n in test_cases:\n        ans = [[1],[1,2],[1,2,2],[1,2,2,3],[1,2,2,3,3]]\n        if n <= 5:\n            results.append((len(ans[n - 1]), ans[n - 1]))\n            continue\n        answer = [i % 4 + 1 for i in range(1,n + 1)]\n        results.append((len(answer), answer))\n    return results\n"
    }
  },
  {
    "id": "slavics_exam",
    "requirements": {
      "signature": "def slavics_exam(t: int, test_cases: list[tuple[str, str]]) -> list[Union[str,tuple[str,str]]]",
      "description": "Slavic has a very tough exam and needs your help in order to pass it. Here is the question he is struggling with:\n\nThere exists a string $s$, which consists of lowercase English letters and possibly zero or more \"?\".\n\nSlavic is asked to change each \"?\" to a lowercase English letter such that string $t$ becomes a subsequence (not necessarily continuous) of the string $s$.\n\nOutput any such string, or say that it is impossible in case no string that respects the conditions exists.\n\n# Input:\nThe first line contains a single integer $T$ ($1 \\leq T \\leq 10^4$) — the number of test cases.\n\nThe first line of each test case contains a single string $s$ ($1 \\leq |s| \\leq 2 \\cdot 10^5$, and $s$ consists only of lowercase English letters and \"?\"-s)  – the original string you have.\n\nThe second line of each test case contains a single string $t$ ($1 \\leq |t| \\leq |s|$, and $t$ consists only of lowercase English letters)  – the string that should be a subsequence of string $s$.\n\nThe sum of $|s|$ over all test cases doesn't exceed $2 \\cdot 10^5$, where $|x|$ denotes the length of the string $x$.\n\n# Output:\nFor each test case, if no such string exists as described in the statement, output \"NO\" (without quotes).\n\nOtherwise, output \"YES\" (without quotes). Then, output one line — the string that respects all conditions.\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\n\nIf multiple answers are possible, you can output any of them.\n\n# Example input:\n5\n?????\nxbx\nab??e\nabcde\nayy?x\na\nab??e\ndac\npaiu\nmom\n\n# Example output:\nYES\nxabax\nYES\nabcde\nYES\nayyyx\nNO\nNO\n\n# Notes:\n\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[str, str]], results: list[Union[str,tuple[str,str]]]) -> bool:\n    for (s, t), result in zip(test_cases, results):\n        if result == \"NO\":\n            j = 0\n            for c in s:\n                if c == '?':\n                    if j < len(t):\n                        j += 1\n                elif j < len(t) and c == t[j]:\n                    j += 1\n            if not(j < len(t)):\n                return False\n        else:\n            if len(result) != len(s):\n                return False\n            for i in range(len(s)):\n                sc = s[i]\n                rc = result[i]\n                if sc != '?' and sc != rc:\n                    return False\n                if sc == '?' and not ('a' <= rc <= 'z'):\n                    return False\n            j = 0\n            for c in result:\n                if j < len(t) and c == t[j]:\n                    j += 1\n            if not(j == len(t)):\n                return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [('?????', 'xbx')], slavics_exam(1, [('?????', 'xbx')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [('ab??e', 'abcde')], slavics_exam(1, [('ab??e', 'abcde')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [('ayy?x', 'a')], slavics_exam(1, [('ayy?x', 'a')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [('ab??e', 'dac')], slavics_exam(1, [('ab??e', 'dac')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [('paiu', 'mom')], slavics_exam(1, [('paiu', 'mom')]))"
      }
    ],
    "metadata": {
      "problem_id": "1999D",
      "url": "https://codeforces.com/problemset/problem/1999/D",
      "title": "Slavic's Exam",
      "rating": 1100,
      "tags": [
        "greedy",
        "implementation",
        "strings"
      ],
      "div": "Div. 4",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 343091485\n# status: accepted\n\n\ndef slavics_exam(t: int, test_cases: list[tuple[str, str]]) -> list[Union[str,tuple[str,str]]]:\n    results = []\n    for test in test_cases:\n        s, target = list(test[0]), test[1]\n\n        n_len, m = len(s), len(target)\n        j = 0\n\n        # Сопоставляем символы target с s\n        for i in range(n_len):\n            if j < m and (s[i] == target[j] or s[i] == '?'):\n                if s[i] == '?':\n                    s[i] = target[j]\n                j += 1\n\n        if j < m:\n            results.append(\"NO\")\n            continue\n\n        # Заменяем оставшиеся '?' на 'a'\n        for i in range(n_len):\n            if s[i] == '?':\n                s[i] = 'a'\n\n        results.append((\"YES\", s))\n\n    return results\n",
      "incorrect_solution": "# submission:  343090387\n\n#  Test: #2, time: 124 ms., memory: 24 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 10000\n# x?\n# am\n# ?\n# z\n# bp?kn?zl\n# bkoz\n# t?j?\n# mlvu\n# a?n??fc\n# eur\n# j\n# s\n# h?\n# f\n# ??ry\n# acvr\n# g?nni\n# ifyer\n# aa\n# gx\n# lq?\n# q\n# h?go?n\n# az\n# c?l?vfj?\n# shyfiq\n# ?\n# x\n# ?q\n# qj\n# ?cxc\n# jcx\n# n\n# s\n# hl??r\n# ar\n# vl?\n# lp\n# e\n# r\n# ?n?q??l\n# qml\n# ??vsy\n# yt\n# qv?a\n# vb\n# na?x???\n# ojra\n# nq\n# wh\n# tzd\n# w\n# y????\n# y\n# m\n# m\n# lgaphe?s\n# cx\n# lh\n# h\n# l\n# c\n# ??ajvyfp\n# m\n# skke??\n# oawqgx\n# xas\n# y\n# f?ketr?j\n# ysa\n# jl\n# n\n# f?n?xgm\n# rbty\n# vm?c\n# xyyc\n# xq\n# w\n# v?\n# g\n# t?or??\n# tuv\n# ?kmv?ow\n# daw\n# lof\n# al\n# kxmenk?x\n# vlswyj\n# cvf\n# c\n# ixo?go\n# mxtek\n# k???\n# qypx\n# fem?ptn\n# ...\n# Output\n# NO\n# YES\n# z\n# NO\n# NO\n# NO\n# NO\n# YES\n# hf\n# NO\n# NO\n# NO\n# YES\n# lqa\n# NO\n# NO\n# YES\n# x\n# NO\n# YES\n# jcxc\n# NO\n# YES\n# hlarr\n# YES\n# vlp\n# NO\n# YES\n# anaqmll\n# YES\n# ytvsy\n# YES\n# qvba\n# NO\n# NO\n# NO\n# YES\n# yaaaa\n# YES\n# m\n# NO\n# YES\n# lh\n# NO\n# YES\n# maajvyfp\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# YES\n# vg\n# NO\n# NO\n# NO\n# NO\n# YES\n# cvf\n# NO\n# NO\n# NO\n# YES\n# blizsfkk\n# YES\n# ufkd\n# YES\n# qoa\n# NO\n# YES\n# tb\n# NO\n# YES\n# ldhn\n# NO\n# YES\n# nq\n# NO\n# YES\n# qmexdage\n# YES\n# rug\n# NO\n# YES\n# izaty\n# NO\n# YES\n# g\n# YES\n# dakag\n# YES\n# xly\n# NO\n# YES\n# ysqg\n# NO\n# NO\n# YES\n# r\n# NO\n# YES\n# usqsag\n# NO\n# NO\n# YES...\n# Answer\n# NO\n# YES\n# z\n# YES\n# bpkknozl\n# NO\n# YES\n# aenurfc\n# NO\n# YES\n# hf\n# NO\n# NO\n# NO\n# YES\n# lqa\n# YES\n# hagozn\n# NO\n# YES\n# x\n# NO\n# YES\n# jcxc\n# NO\n# YES\n# hlarr\n# YES\n# vlp\n# NO\n# YES\n# qnmqlal\n# YES\n# ytvsy\n# YES\n# qvba\n# YES\n# naoxjra\n# NO\n# NO\n# YES\n# yaaaa\n# YES\n# m\n# NO\n# YES\n# lh\n# NO\n# YES\n# maajvyfp\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# NO\n# YES\n# vg\n# YES\n# tuorva\n# YES\n# dkmvaow\n# NO\n# NO\n# YES\n# cvf\n# NO\n# NO\n# NO\n# YES\n# blizsfkk\n# YES\n# ufkd\n# YES\n# qoa\n# NO\n# YES\n# tb\n# NO\n# YES\n# ldhn\n# NO\n# YES\n# nq\n# NO\n# YES\n# qmexdage\n# YES\n# rug\n# NO\n# YES\n# izaty\n# YES\n# wvo\n# YES\n# g\n# YES\n# dakag\n# YES\n# ...\n# Checker Log\n# wrong answer Jury has answer but contestant hasn't got it (test case 3)\n\n\ndef slavics_exam(t: int, test_cases: list[tuple[str, str]]) -> list[Union[str,tuple[str,str]]]:\n    results = []\n    for test in test_cases:\n        s = list(test[0])\n        t = list(test[1])\n\n        for i in range(len(s)- len(t)+1):\n            for j in range(len(t)):\n                # print(s[i+j], t[j])\n                if not(s[i+j] == t[j] or s[i+j] == \"?\"):\n                    break\n            else:\n                s[i:i+len(t)] = t\n                for i in range(len(s)):\n                    if s[i] == \"?\":\n                        s[i] = \"a\"\n\n                results.append((\"YES\", ''.join(s)))\n                break\n        else:\n            results.append(\"NO\")\n    return results\n"
    }
  },
  {
    "id": "stardew_valley",
    "requirements": {
      "signature": "def stardew_valley(t: int, test_cases: list[tuple[int, int, list[tuple[int, int, int]]]]) -> list[Union[str,tuple[str,int,list[int]]]]",
      "description": "Pelican Town represents $n$ houses connected by $m$ bidirectional roads. Some roads have NPCs standing on them. Farmer Buba needs to walk on each road with an NPC and talk to them.\n\nHelp the farmer find a route satisfying the following properties:\n\n  * The route starts at some house, follows the roads, and ends at the same house.    * The route does not follow any road more than once (in both directions together).    * The route follows each road with an NPC exactly once. \n\nNote that the route can follow roads without NPCs, and you do not need to minimize the length of the route.\n\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\n\n# Input:\nEach test consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 10^{4}$) — the number of test cases. Then follows the description of the test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($2 \\leq n \\leq 5 \\cdot 10^5, 1 \\leq m \\leq 5 \\cdot 10^5$) — the number of houses and roads in Pelican Town respectively.\n\nIn each of the next $m$ lines, three integers $u$, $v$, and $c$ ($1 \\leq u, v \\leq n, c = 0/1$) are given — the ends of the road and whether an NPC is on this road. If $c = 1$, then the road has an NPC. If $c = 0$, then the road has no NPC.\n\nThe graph may contain multiple edges and loops, and if there are multiple edges with NPCs standing on them, the route must follow each of these roads.\n\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\n\nIt is guaranteed that the sum of $n$ and $m$ for all test cases does not exceed $5 \\cdot 10^5$.\n\n# Output:\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\nOtherwise, output \"Yes\" (without quotes), and then output $k$ — the number of roads in the route. In the next line, output $k + 1$ numbers — the houses of the route in the order of traversal. Note that the first house should match the last one, as the route is cyclic.\n\nIf there are multiple answers, you can print any of them.\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n# Example input:\n3\n3 2\n1 2 1\n2 3 1\n3 3\n1 2 1\n1 3 1\n2 3 0\n5 9\n1 2 0\n5 2 1\n5 4 1\n5 1 1\n2 3 1\n5 2 1\n4 1 0\n4 3 0\n5 2 0\n\n# Example output:\nNO\nYES\n3\n1 2 3 1 \nYES\n7\n1 2 5 4 3 2 5 1\n\n# Notes:\nNote that in the third test case, there are multiple edges $(5, 2)$. You must walk on two of them.\n"
    },
    "judge": "from collections import defaultdict\ndef __judge(t: int, test_cases: list[tuple[int, int, list[tuple[int, int, int]]]], results: list[Union[str,tuple[str,int,list[int]]]]) -> bool:\n    for (test, result) in zip(test_cases, results):\n        n, m, edges = test\n        if isinstance(result, str):\n            first = result.upper()\n        else:\n            first = result[0].upper()\n        def exists_solution():\n            edg = [0]*m\n            g = [[] for _ in range(n)]\n            black = [[] for _ in range(n)]\n            for i in range(m):\n                u,v,c = edges[i]\n                u -= 1; v -= 1\n                edg[i] = u ^ v\n                g[u].append(i); g[v].append(i)\n                if c == 0:\n                    black[u].append(i); black[v].append(i)\n            deg = [len(g[i]) & 1 for i in range(n)]\n            removed = [False]*m\n            usedv = [False]*n\n            import sys\n            sys.setrecursionlimit(1000000)\n            def dfs(u):\n                usedv[u] = True\n                for id in black[u]:\n                    to = edg[id] ^ u\n                    if usedv[to]: continue\n                    dfs(to)\n                    if deg[to]:\n                        removed[id] = True\n                        deg[to] ^= 1\n                        deg[u] ^= 1\n            ok = True\n            for i in range(n):\n                if not usedv[i]:\n                    dfs(i)\n                    if deg[i]:\n                        ok = False\n            if not ok:\n                return False\n            used_edge = [False]*m\n            start = 0\n            for i in range(n):\n                for id in g[i]:\n                    if not removed[id]:\n                        start = i; break\n                else:\n                    continue\n                break\n            it = [list(lst) for lst in g]\n            path = []\n            stack = [start]\n            while stack:\n                v = stack[-1]\n                while it[v] and (removed[it[v][-1]] or used_edge[it[v][-1]]):\n                    it[v].pop()\n                if not it[v]:\n                    path.append(v)\n                    stack.pop()\n                else:\n                    id = it[v].pop()\n                    used_edge[id] = True\n                    to = edg[id] ^ v\n                    stack.append(to)\n            for i in range(m):\n                if not removed[i] and not used_edge[i]:\n                    return False\n            return True\n        if first == 'NO':\n            return not exists_solution()\n        if first != 'YES':\n            return False\n        k = result[1]\n        route = result[2]\n        if len(route) != k + 1 or route[0] != route[-1]:\n            return False\n        for house in route:\n            if not (1 <= house <= n):\n                return False\n        adj = [defaultdict(list) for _ in range(n + 1)]\n        used = [False] * m\n        for idx in range(m):\n            u, v, c = edges[idx]\n            adj[u][v].append(idx)\n            adj[v][u].append(idx)\n        for i in range(k):\n            a = route[i]\n            b = route[i + 1]\n            if b not in adj[a]:\n                return False\n            found = False\n            while adj[a][b]:\n                idx = adj[a][b].pop()\n                if not used[idx]:\n                    used[idx] = True\n                    found = True\n                    break\n            if not found:\n                return False\n        for idx in range(m):\n            u, v, c = edges[idx]\n            if c == 1 and not used[idx]:\n                return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, 2, [(1, 2, 1), (2, 3, 1)])], stardew_valley(1, [(3, 2, [(1, 2, 1), (2, 3, 1)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(3, 3, [(1, 2, 1), (1, 3, 1), (2, 3, 0)])], stardew_valley(1, [(3, 3, [(1, 2, 1), (1, 3, 1), (2, 3, 0)])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(5, 9, [(1, 2, 0), (5, 2, 1), (5, 4, 1), (5, 1, 1), (2, 3, 1), (5, 2, 1), (4, 1, 0), (4, 3, 0), (5, 2, 0)])], stardew_valley(1, [(5, 9, [(1, 2, 0), (5, 2, 1), (5, 4, 1), (5, 1, 1), (2, 3, 1), (5, 2, 1), (4, 1, 0), (4, 3, 0), (5, 2, 0)])]))"
      }
    ],
    "metadata": {
      "problem_id": "1994F",
      "url": "https://codeforces.com/problemset/problem/1994/F",
      "title": "Stardew Valley",
      "rating": 2500,
      "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "trees"
      ],
      "div": "Div. 1 + 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 333870558\n# status: accepted\n\nUSE_STDIN, IMPORT_EXTRAS, USE_BUFFERED_OUTPUT = 1, 0, 0\nUSE_DFS_BOOTSTRAP, USE_RANDOM_HASH_WRAPPER, READ_FROM_FILE = 0, 0, 0\nENABLE_DEBUG = 1\n\nif 1:\n\n    if USE_STDIN:\n        import io, os, sys\n        input = lambda: sys.stdin.readline().strip()\n\n        import math\n        INF = math.inf\n\n        def read_str():\n            return input()\n        \n        def read_int():\n            return int(input())\n\n        def read_ints():\n            return map(int, input().split())\n\n        def read_tokens():\n            return list(input().split())\n\n        def read_list_ints():\n            return list(map(int, input().split()))\n\n        def read_list_floats():\n            return list(map(float, input().split()))\n\n        def read_ints_zero_based():\n            return map(lambda x: int(x) - 1, input().split())\n\n        def read_list_ints_zero_based():\n            return list(map(lambda x: int(x) - 1, input().split()))\n\n    if IMPORT_EXTRAS:\n        from io import BytesIO, IOBase\n\n        import random\n        import os\n\n        import bisect\n        import typing\n        from collections import Counter, defaultdict, deque\n        from copy import deepcopy\n        from functools import cmp_to_key, lru_cache, reduce\n        from heapq import merge, heapify, heappop, heappush, heappushpop, nlargest, nsmallest\n        from itertools import accumulate, combinations, permutations, count, product\n        from operator import add, iand, ior, itemgetter, mul, xor\n        from string import ascii_lowercase, ascii_uppercase, ascii_letters\n        from typing import *\n        BUFSIZE = 4096\n\n    if USE_BUFFERED_OUTPUT:\n        from io import BytesIO, IOBase\n\n        class FastIO(IOBase):\n            newlines = 0\n\n            def __init__(self, file):\n                self._fd = file.fileno()\n                self.buffer = BytesIO()\n                self.writable = \"x\" in file.mode or \"r\" not in file.mode\n                self.write = self.buffer.write if self.writable else None\n\n            def read(self):\n                while True:\n                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n                    if not b:\n                        break\n                    ptr = self.buffer.tell()\n                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n                self.newlines = 0\n                return self.buffer.read()\n\n            def readline(self):\n                while self.newlines == 0:\n                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n                    self.newlines = b.count(b\"\\n\") + (not b)\n                    ptr = self.buffer.tell()\n                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n                self.newlines -= 1\n                return self.buffer.readline()\n\n            def flush(self):\n                if self.writable:\n                    os.write(self._fd, self.buffer.getvalue())\n                    self.buffer.truncate(0), self.buffer.seek(0)\n\n        class IOWrapper(IOBase):\n            def __init__(self, file):\n                self.buffer = FastIO(file)\n                self.flush = self.buffer.flush\n                self.writable = self.buffer.writable\n                self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n                self.read = lambda: self.buffer.read().decode(\"ascii\")\n                self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n        sys.stdout = IOWrapper(sys.stdout)\n\n    if USE_DFS_BOOTSTRAP:\n        from types import GeneratorType\n\n        def bootstrap(f, stack=[]):\n            def wrappedfunc(*args, **kwargs):\n                if stack:\n                    return f(*args, **kwargs)\n                else:\n                    to = f(*args, **kwargs)\n                    while True:\n                        if type(to) is GeneratorType:\n                            stack.append(to)\n                            to = next(to)\n                        else:\n                            stack.pop()\n                            if not stack:\n                                break\n                            to = stack[-1].send(to)\n                    return to\n            return wrappedfunc\n\n    if USE_RANDOM_HASH_WRAPPER:\n        RANDOM = random.getrandbits(20)\n        class Wrapper(int):\n            def __init__(self, x):\n                int.__init__(x)\n\n            def __hash__(self):\n                return super(Wrapper, self).__hash__() ^ RANDOM\n\n    if READ_FROM_FILE:\n        file = open(\"input.txt\", \"r\").readline().strip()[1:-1]\n        fin = open(file, 'r')\n        input = lambda: fin.readline().strip()\n        output_file = open(\"output.txt\", \"w\")\n        def fprint(*args, **kwargs):\n            print(*args, **kwargs, file=output_file)\n\n    if ENABLE_DEBUG:\n        def debug(*args, **kwargs):\n            print('\\033[92m', end='')\n            print(*args, **kwargs)\n            print('\\033[0m', end='')\n\n\ndef stardew_valley(t: int, test_cases: list[tuple[int, int, list[tuple[int, int, int]]]]) -> list[Union[str,tuple[str,int,list[int]]]]:\n\n    outputs = []\n\n    for test in test_cases:\n        n_nodes, n_edges = test[0], test[1]\n        adj_to = []\n        next_index = []\n        head_index = [-1] * n_nodes\n\n        degree_parity = [0] * n_nodes\n        edge_active = [0] * n_edges\n\n        for edge_id in range(n_edges):\n            u, v, state = test[2][edge_id][0] - 1, test[2][edge_id][1] - 1, test[2][edge_id][2] - 1\n\n            next_index.append(head_index[u])\n            head_index[u] = len(adj_to)\n            adj_to.append(v)\n\n            next_index.append(head_index[v])\n            head_index[v] = len(adj_to)\n            adj_to.append(u)\n\n            edge_active[edge_id] = state + 1  # 0 or 1\n            if edge_active[edge_id]:\n                degree_parity[u] ^= 1\n                degree_parity[v] ^= 1\n\n        is_possible = True\n\n        visited = [0] * n_nodes\n        parent = [-1] * n_nodes\n        parent_arc_index = [0] * n_nodes\n\n        for start in range(n_nodes):\n            if degree_parity[start] and not visited[start]:\n                stack = [start]\n                visited[start] = 1\n                component_parity = 0\n\n                order = []\n                while stack:\n                    u = stack.pop()\n                    component_parity ^= degree_parity[u]\n                    order.append(u)\n\n                    arc = head_index[u]\n                    while ~arc:\n                        v = adj_to[arc]\n                        if not visited[v] and not edge_active[arc // 2]:\n                            visited[v] = 1\n                            parent[v] = u\n                            parent_arc_index[v] = arc\n                            stack.append(v)\n\n                        arc = next_index[arc]\n\n                for u in reversed(order):\n                    if parent[u] != -1 and degree_parity[u]:\n                        degree_parity[u] ^= 1\n                        degree_parity[parent[u]] ^= 1\n                        edge_active[parent_arc_index[u] // 2] = 1\n\n                if component_parity:\n                    is_possible = False\n                    break\n\n        if is_possible:\n            stack = [0]\n            trail = [0]\n            trail_tail = []\n            while stack:\n                u = stack.pop()\n                if u < 0:\n                    u = ~u\n                    while trail[-1] != u:\n                        trail_tail.append(trail.pop())\n                while ~head_index[u] and edge_active[head_index[u] // 2] == 0:\n                    head_index[u] = next_index[head_index[u]]\n                if ~head_index[u]:\n                    stack.append(~u)\n                    edge_active[head_index[u] // 2] = 0\n                    v = adj_to[head_index[u]]\n                    head_index[u] = next_index[head_index[u]]\n                    stack.append(v)\n                    trail.append(v)\n            trail.extend(reversed(trail_tail))\n            outputs.append(('YES', len(trail) - 1, [x + 1 for x in trail]))\n        else:\n            outputs.append('NO')\n\n    return outputs\n\n",
      "incorrect_solution": "# submission: 335616599\n\n#  Test: #1, time: 46 ms., memory: 192 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 3\n# 3 2\n# 1 2 1\n# 2 3 1\n# 3 3\n# 1 2 1\n# 1 3 1\n# 2 3 0\n# 5 9\n# 1 2 0\n# 5 2 1\n# 5 4 1\n# 5 1 1\n# 2 3 1\n# 5 2 1\n# 4 1 0\n# 4 3 0\n# 5 2 0\n# Output\n# NO\n# NO\n# NO\n# Answer\n# NO\n# YES\n# 3\n# 1 2 3 1 \n# YES\n# 7\n# 1 2 5 4 3 2 5 1 \n# Checker Log\n# wrong answer Jury found answer, but participant didn't (test case 2)\n\n\n\nimport sys\nfrom collections import defaultdict\n\n\ndef stardew_valley(t: int, test_cases: list[tuple[int, int, list[tuple[int, int, int]]]]) -> list[Union[str,tuple[str,int,list[int]]]]:\n\n    outputs = []\n\n    for test in test_cases:\n        n, m = test[0], test[1]\n        graph = defaultdict(list)\n        edge_used = dict()\n\n        for idx, (u, v, c) in enumerate(test[2]):\n            if c == 1:\n                graph[u].append((v, idx))\n                graph[v].append((u, idx))\n                edge_used[idx] = False\n\n        # Check all degrees are even\n        ok = all(len(graph[node]) % 2 == 0 for node in graph)\n        if not ok:\n            outputs.append(\"NO\")\n            continue\n\n        # If no NPC edges, trivial circuit\n        if not edge_used:\n            outputs.append((\"YES\", 0, [1, 1]))\n            continue\n\n        # Hierholzer's algorithm\n        circuit = []\n        stack = [next(iter(graph))]\n        while stack:\n            u = stack[-1]\n            while graph[u]:\n                v, idx = graph[u].pop()\n                if edge_used[idx]:\n                    continue\n                edge_used[idx] = True\n                # Remove reverse edge\n                for i, (vv, ii) in enumerate(graph[v]):\n                    if vv == u and ii == idx:\n                        graph[v].pop(i)\n                        break\n                stack.append(v)\n                u = v\n            else:\n                circuit.append(stack.pop())\n\n        # Validate all edges used\n        if not all(edge_used.values()):\n            outputs.append(\"NO\")\n            continue\n\n        outputs.append((\"YES\", len(circuit)-1, circuit))\n    return outputs\n\n"
    }
  },
  {
    "id": "strong_password",
    "requirements": {
      "signature": "def strong_password(t: int, test_cases: list[str]) -> list[str]",
      "description": "Monocarp's current password on Codeforces is a string $s$, consisting of lowercase Latin letters. Monocarp thinks that his current password is too weak, so he wants to insert exactly one lowercase Latin letter into the password to make it stronger. Monocarp can choose any letter and insert it anywhere, even before the first character or after the last character.\n\nMonocarp thinks that the password's strength is proportional to the time it takes him to type the password. The time it takes to type the password is calculated as follows:\n\n  * the time to type the first character is $2$ seconds;    * for each character other than the first, the time it takes to type it is $1$ second if it is the same as the previous character, or $2$ seconds otherwise. \n\nFor example, the time it takes to type the password abacaba is $14$; the time it takes to type the password a is $2$; the time it takes to type the password aaabacc is $11$.\n\nYou have to help Monocarp — insert a lowercase Latin letter into his password so that the resulting password takes the maximum possible amount of time to type.\n\n# Input:\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nEach test case consists of one line containing the string $s$ ($1 \\le |s| \\le 10$), consisting of lowercase Latin letters.\n\n# Output:\nFor each test case, print one line containing the new password — a string which can be obtained from $s$ by inserting one lowercase Latin letter. The string you print should have the maximum possible required time to type it. If there are multiple answers, print any of them.\n\n# Example input:\n4\na\naaa\nabb\npassword\n\n# Example output:\nwa\naada\nabcb\npastsword\n\n# Notes:\n\n"
    },
    "judge": "def __judge(t: int, test_cases: list[str], results: list[str]) -> bool:\n    for (s, result) in zip(test_cases, results):\n        if len(result) != len(s) + 1:\n            return False\n        if not all('a' <= c <= 'z' for c in result):\n            return False\n        valid_insertion = False\n        for i in range(len(result)):\n            if result[:i] + result[i+1:] == s:\n                valid_insertion = True\n                break\n        if not valid_insertion:\n            return False\n        def typing_time(x: str) -> int:\n            p = sum(1 for i in range(1, len(x)) if x[i] == x[i-1])\n            return 2 * len(x) - p\n        res_time = typing_time(result)\n        best_time = -1\n        for i in range(len(s) + 1):\n            for code in range(ord('a'), ord('z') + 1):\n                cand = s[:i] + chr(code) + s[i:]\n                t = typing_time(cand)\n                if t > best_time:\n                    best_time = t\n        if not(res_time == best_time):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, ['a'], strong_password(1, ['a']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, ['aaa'], strong_password(1, ['aaa']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, ['abb'], strong_password(1, ['abb']))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, ['password'], strong_password(1, ['password']))"
      }
    ],
    "metadata": {
      "problem_id": "1997A",
      "url": "https://codeforces.com/problemset/problem/1997/A",
      "title": "Strong Password",
      "rating": 800,
      "tags": [
        "brute force",
        "implementation",
        "strings"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 512,
      "correct_solution": "# submission: 343164964\n# status: accepted\n\ndef strong_password(t: int, test_cases: list[str]) -> list[str]:\n    abc = \"abcdefghijklmnopqrstuvwxyz\"\n    x = \"\"\n    results = []\n    for test in test_cases:\n        line = test\n        ans = None\n        for i in range((len(line) - 1)):\n            if line[i] == line[i + 1]:\n                insert = None\n                for c in abc:\n                    if c != line[i]:\n                        insert = c\n                        break\n                ans = line[:i + 1] + insert + line[i + 1:]\n                break\n        if ans == None:\n            for c in abc:\n                if line[(len(line) - 1)] == \"z\":\n                    x = \"a\"\n                    break\n                elif c != line[(len(line) - 1)]:\n                    x = c\n            results.append(line + x)\n        else:\n            results.append(ans)\n    return results\n\n",
      "incorrect_solution": "# submission: 343164547\n\n#  Test: #2, time: 61 ms., memory: 32 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 1000\n# rn\n# ap\n# v\n# vn\n# vr\n# fxkx\n# qd\n# vfp\n# iuqpibsiv\n# xn\n# jp\n# eu\n# tu\n# ddxhk\n# jx\n# cp\n# yg\n# nj\n# ke\n# eg\n# sx\n# zx\n# ki\n# yncz\n# yc\n# ph\n# ov\n# x\n# in\n# dr\n# cxjzwxvoy\n# ug\n# jcdhi\n# ck\n# d\n# yn\n# bf\n# po\n# zq\n# i\n# be\n# xq\n# gw\n# ym\n# oishtpha\n# bt\n# hr\n# lj\n# njeexyh\n# xf\n# fl\n# g\n# ev\n# pm\n# ch\n# bm\n# wy\n# cu\n# zh\n# io\n# lp\n# ce\n# baawuzmk\n# sf\n# phnzrxgx\n# wz\n# hr\n# nnjcdoohg\n# li\n# yvvdqr\n# oh\n# xrnrhsajar\n# cf\n# ih\n# zmguszcra\n# b\n# ur\n# cg\n# zv\n# as\n# qh\n# ho\n# ns\n# eer\n# zm\n# od\n# ryyysuzjim\n# rg\n# wnrqva\n# pu\n# pd\n# xu\n# jmcxe\n# es\n# ka\n# hu\n# wa\n# ft\n# sh\n# ai\n# uojf\n# wk\n# xt\n# vi\n# ri\n# ...\n# Output\n# rnz\n# apz\n# vz\n# vnz\n# vrz\n# fxkxz\n# qdz\n# vfpz\n# iuqpibsivz\n# xnz\n# jpz\n# euz\n# tuz\n# dadxhk\n# jxz\n# cpz\n# ygz\n# njz\n# kez\n# egz\n# sxz\n# zxz\n# kiz\n# ynczz\n# ycz\n# phz\n# ovz\n# xz\n# inz\n# drz\n# cxjzwxvoyz\n# ugz\n# jcdhiz\n# ckz\n# dz\n# ynz\n# bfz\n# poz\n# zqz\n# iz\n# bez\n# xqz\n# gwz\n# ymz\n# oishtphaz\n# btz\n# hrz\n# ljz\n# njeaexyh\n# xfz\n# flz\n# gz\n# evz\n# pmz\n# chz\n# bmz\n# wyz\n# cuz\n# zhz\n# ioz\n# lpz\n# cez\n# babawuzmk\n# sfz\n# phnzrxgxz\n# wzz\n# hrz\n# nanjcdoohg\n# liz\n# yvavdqr\n# ohz\n# xrnrhsajarz\n# cfz\n# ihz\n# zmguszcraz\n# bz\n# urz\n# cgz\n# zvz\n# asz\n# qhz\n# hoz\n# nsz\n# eaer\n# zmz\n# odz\n# ryayysuzjim\n# ...\n# Answer\n# rna\n# apa\n# va\n# vna\n# vra\n# fxkxa\n# qda\n# vfpa\n# iuqpibsiva\n# xna\n# jpa\n# eua\n# tua\n# dadxhk\n# jxa\n# cpa\n# yga\n# nja\n# kea\n# ega\n# sxa\n# zxa\n# kia\n# yncza\n# yca\n# pha\n# ova\n# xa\n# ina\n# dra\n# cxjzwxvoya\n# uga\n# jcdhia\n# cka\n# da\n# yna\n# bfa\n# poa\n# zqa\n# ia\n# bea\n# xqa\n# gwa\n# yma\n# oishtphab\n# bta\n# hra\n# lja\n# njeaexyh\n# xfa\n# fla\n# ga\n# eva\n# pma\n# cha\n# bma\n# wya\n# cua\n# zha\n# ioa\n# lpa\n# cea\n# babawuzmk\n# sfa\n# phnzrxgxa\n# wza\n# hra\n# nnjcdoaohg\n# lia\n# yvavdqr\n# oha\n# xrnrhsajara\n# cfa\n# iha\n# zmguszcrab\n# ba\n# ura\n# cga\n# zva\n# asa\n# qha\n# hoa\n# nsa\n# eaer\n# zma\n# oda\n# ryyaysuzjim\n# ...\n# Checker Log\n# wrong answer jury has better answer (test case 24)\n\n\n\ndef strong_password(t: int, test_cases: list[str]) -> list[str]:\n    abc = \"abcdefghijklmnopqrstuvwxyz\"\n    x = \"\"\n    \n    results = []\n    for test in test_cases:\n        line = test\n        ans = None\n        for i in range((len(line) - 1)):\n            if line[i] == line[i + 1]:\n                insert = None\n                for c in abc:\n                    if c != line[i]:\n                        insert = c\n                        break\n                ans = line[:i + 1] + insert + line[i + 1:]\n                break\n        if ans == None:\n            for c in abc:\n                if c != line[(len(line) - 1)]:\n                    x = c\n            results.append(line + c)\n        else:\n            results.append(ans)\n    return results\n"
    }
  },
  {
    "id": "turtle_and_good_pairs",
    "requirements": {
      "signature": "def turtle_and_good_pairs(t: int, test_cases: list[tuple[int,str]]) -> list[str]",
      "description": "Turtle gives you a string $s$, consisting of lowercase Latin letters.\n\nTurtle considers a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) to be a pleasant pair if and only if there exists an integer $k$ such that $i \\le k < j$ and both of the following two conditions hold:\n\n  * $s_k \\ne s_{k + 1}$;    * $s_k \\ne s_i$ or $s_{k + 1} \\ne s_j$. \n\nBesides, Turtle considers a pair of integers $(i, j)$ ($1 \\le i < j \\le n$) to be a good pair if and only if $s_i = s_j$ or $(i, j)$ is a pleasant pair.\n\nTurtle wants to reorder the string $s$ so that the number of good pairs is maximized. Please help him!\n\n# Input:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) — the length of the string.\n\nThe second line of each test case contains a string $s$ of length $n$, consisting of lowercase Latin letters.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, output the string $s$ after reordering so that the number of good pairs is maximized. If there are multiple answers, print any of them.\n\n# Example input:\n5\n3\nabc\n5\nedddf\n6\nturtle\n8\npppppppp\n10\ncodeforces\n\n# Example output:\nacb\nddedf\nurtlet\npppppppp\ncodeforces\n\n# Notes:\nIn the first test case, $(1, 3)$ is a good pair in the reordered string. It can be seen that we can't reorder the string so that the number of good pairs is greater than $1$. bac and cab can also be the answer.\n\nIn the second test case, $(1, 2)$, $(1, 4)$, $(1, 5)$, $(2, 4)$, $(2, 5)$, $(3, 5)$ are good pairs in the reordered string. efddd can also be the answer.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[tuple[int,str]], results: list[str]) -> bool:\n    for (n, s), result in zip(test_cases, results):\n        if len(result) != n: return False\n        cnt_s = [0] * 26\n        cnt_result = [0] * 26\n        for c in s:\n            cnt_s[ord(c) - 97] += 1\n        for c in result:\n            cnt_result[ord(c) - 97] += 1\n        if cnt_s != cnt_result: return False\n        if not result:\n            continue\n            #return True\n        runs = []\n        current_char, count = result[0], 1\n        for c in result[1:]:\n            if c == current_char:\n                count += 1\n            else:\n                runs.append(count)\n                current_char, count = c, 1\n        runs.append(count)\n        m = len(runs)\n        total = 0\n        if m == 1:\n            if not( total == 0):\n                return False\n            continue\n        else:\n            for i in range(m - 1):\n                total += runs[i] * runs[i + 1]\n        if not(total == n - 1):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, 'abc')], turtle_and_good_pairs(1, [(3, 'abc')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(5, 'edddf')], turtle_and_good_pairs(1, [(5, 'edddf')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(6, 'turtle')], turtle_and_good_pairs(1, [(6, 'turtle')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(8, 'pppppppp')], turtle_and_good_pairs(1, [(8, 'pppppppp')]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(10, 'codeforces')], turtle_and_good_pairs(1, [(10, 'codeforces')]))"
      }
    ],
    "metadata": {
      "problem_id": "2003C",
      "url": "https://codeforces.com/problemset/problem/2003/C",
      "title": "Turtle and Good Pairs",
      "rating": 1200,
      "tags": [
        "constructive algorithms",
        "greedy",
        "sortings",
        "strings"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 343178703\n# status: accepted\n\ndef turtle_and_good_pairs(t: int, test_cases: list[tuple[int,str]]) -> list[str]:\n    results = []\n    for test in test_cases:\n        a, b = test\n        c = ''.join(sorted(b))\n        d=''\n        for i in range(a//2):\n            d=d+c[i]\n            d=d+c[a-1-i]\n        if a%2:\n            d=d+c[a//2]\n        results.append(d)\n    return results\n",
      "incorrect_solution": "# submission: 339489579\n\n#  Test: #1, time: 62 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 5\n# 3\n# abc\n# 5\n# edddf\n# 6\n# turtle\n# 8\n# pppppppp\n# 10\n# codeforces\n# Output\n# abc\n# edddf\n# turtle\n# pppppppp\n# codeforces\n# Answer\n# cba\n# dddfe\n# tturle\n# pppppppp\n# oecsrfdoec\n# Checker Log\n# wrong answer Participant's answer is worse than jury's: jans = 6, pans = 4. (test case 2)\n\n\ndef turtle_and_good_pairs(t: int, test_cases: list[tuple[int,str]]) -> list[str]:\n    results = []\n    for test in test_cases:\n        n, s = test\n        results.append(s)\n    return results\n"
    }
  },
  {
    "id": "turtle_incomplete_sequence",
    "requirements": {
      "signature": "def turtle_incomplete_sequence(t: int, test_cases: list[int,list[int]]) -> list[Union[int, list[int]]]",
      "description": "Turtle was playing with a sequence $a_1, a_2, \\ldots, a_n$ consisting of positive integers. Unfortunately, some of the integers went missing while playing.\n\nNow the sequence becomes incomplete. There may exist an arbitrary number of indices $i$ such that $a_i$ becomes $-1$. Let the new sequence be $a'$.\n\nTurtle is sad. But Turtle remembers that for every integer $i$ from $1$ to $n - 1$, either $a_i = \\left\\lfloor\\frac{a_{i + 1}}{2}\\right\\rfloor$ or $a_{i + 1} = \\left\\lfloor\\frac{a_i}{2}\\right\\rfloor$ holds for the original sequence $a$.\n\nTurtle wants you to help him complete the sequence. But sometimes Turtle makes mistakes, so you need to tell him if you can't complete the sequence.\n\nFormally, you need to find another sequence $b_1, b_2, \\ldots, b_n$ consisting of positive integers such that:\n\n  * For every integer $i$ from $1$ to $n$, if $a'_i \\ne -1$, then $b_i = a'_i$.    * For every integer $i$ from $1$ to $n - 1$, either $b_i = \\left\\lfloor\\frac{b_{i + 1}}{2}\\right\\rfloor$ or $b_{i + 1} = \\left\\lfloor\\frac{b_i}{2}\\right\\rfloor$ holds.    * For every integer $i$ from $1$ to $n$, $1 \\le b_i \\le 10^9$. \n\nIf there is no sequence $b_1, b_2, \\ldots, b_n$ that satisfies all of the conditions above, you need to report $-1$.\n\n# Input:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$) — the length of the sequence.\n\nThe second line of each test case contains $n$ integers $a'_1, a'_2, \\ldots, a'_n$ ($a'_i = -1$ or $1 \\le a'_i \\le 10^8$) — the elements of the sequence $a'$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n# Output:\nFor each test case, if there is no sequence $b_1, b_2, \\ldots, b_n$ that satisfies all of the conditions, output a single integer $-1$.\n\nOtherwise, output $n$ integers $b_1, b_2, \\ldots, b_n$ — the elements of the sequence $b_1, b_2, \\ldots, b_n$ you find. The sequence should satisfy that $1 \\le b_i \\le 10^9$ for every integer $i$ from $1$ to $n$. If there are multiple answers, print any of them.\n\n# Example input:\n9\n8\n-1 -1 -1 2 -1 -1 1 -1\n4\n-1 -1 -1 -1\n6\n3 -1 -1 -1 9 -1\n4\n-1 5 -1 6\n4\n2 -1 -1 3\n4\n1 2 3 4\n2\n4 2\n5\n-1 3 -1 3 6\n13\n-1 -1 3 -1 -1 -1 -1 7 -1 -1 3 -1 -1\n\n# Example output:\n4 9 4 2 4 2 1 2\n7 3 6 13\n3 1 2 4 9 18\n-1\n-1\n-1\n4 2\n6 3 1 3 6\n3 1 3 1 3 7 3 7 3 1 3 1 3\n\n# Notes:\nIn the first test case, $[4, 2, 1, 2, 1, 2, 1, 3]$ can also be the answer, while $[4, 2, 5, 10, 5, 2, 1, 3]$ and $[4, 2, 1, 2, 1, 2, 1, 4]$ cannot.\n\nIn the second test case, $[1, 2, 5, 2]$ can also be the answer.\n\nFrom the fourth to the sixth test cases, it can be shown that there is no answer, so you should output $-1$.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int,list[int]], results: list[Union[int, list[int]]]) -> bool:\n    def my_lg(x): return x.bit_length()-1 if x else -1\n    for (n, a), result in zip(test_cases, results):\n        if result == -1:\n            all_neg = all(x == -1 for x in a)\n            if all_neg: return False\n            l, r, vc = -1, -1, []\n            for i in range(n):\n                if a[i] != -1:\n                    if l == -1: l = i\n                    r = i\n                    vc.append(i)\n            if l == -1: return False\n            possible = True\n            for k in range(len(vc)-1):\n                i1, i2 = vc[k], vc[k+1]\n                x, y = a[i1], a[i2]\n                L, R = [], []\n                a1, b = x, y\n                while my_lg(a1) > my_lg(b):\n                    L.append(a1)\n                    a1 >>=1\n                while my_lg(b) > my_lg(a1):\n                    R.append(b)\n                    b >>=1\n                while a1 != b:\n                    L.append(a1)\n                    R.append(b)\n                    a1 >>=1\n                    b >>=1\n                path = L + [a1] + R[::-1]\n                path_len = len(path)\n                required_length = i2 - i1\n                if path_len > required_length +1 or (path_len %2) != ((required_length +1) %2):\n                    possible = False\n                    break\n            if possible:\n                return False\n            continue\n        if not isinstance(result, list):\n            return False\n        b = result\n        if len(b)!=n: return False\n        for i in range(n):\n            if a[i] != -1 and b[i] != a[i]: return False\n            if not (1<=b[i]<=10**9): return False\n        for i in range(n-1):\n            if b[i] != (b[i+1]//2) and b[i+1] != (b[i]//2): return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(8, [-1, -1, -1, 2, -1, -1, 1, -1])], turtle_incomplete_sequence(1, [(8, [-1, -1, -1, 2, -1, -1, 1, -1])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(4, [-1, -1, -1, -1])], turtle_incomplete_sequence(1, [(4, [-1, -1, -1, -1])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(6, [3, -1, -1, -1, 9, -1])], turtle_incomplete_sequence(1, [(6, [3, -1, -1, -1, 9, -1])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(4, [-1, 5, -1, 6])], turtle_incomplete_sequence(1, [(4, [-1, 5, -1, 6])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(4, [2, -1, -1, 3])], turtle_incomplete_sequence(1, [(4, [2, -1, -1, 3])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_6():\n    assert __judge(1, [(4, [1, 2, 3, 4])], turtle_incomplete_sequence(1, [(4, [1, 2, 3, 4])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_7():\n    assert __judge(1, [(2, [4, 2])], turtle_incomplete_sequence(1, [(2, [4, 2])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_8():\n    assert __judge(1, [(5, [-1, 3, -1, 3, 6])], turtle_incomplete_sequence(1, [(5, [-1, 3, -1, 3, 6])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_9():\n    assert __judge(1, [(13, [-1, -1, 3, -1, -1, -1, -1, 7, -1, -1, 3, -1, -1])], turtle_incomplete_sequence(1, [(13, [-1, -1, 3, -1, -1, -1, -1, 7, -1, -1, 3, -1, -1])]))"
      }
    ],
    "metadata": {
      "problem_id": "1981C",
      "url": "https://codeforces.com/problemset/problem/1981/C",
      "title": "Turtle and an Incomplete Sequence",
      "rating": 1800,
      "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
      ],
      "div": "Div. 2",
      "time_limit_ms": 3000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 341135073\n# status: accepted\n\n# Suffix removed + To add <= R - L, parity must be the same\n\ndef ops(a, b):\n    abin, bbin = [], []\n\n    for bit in range(31, -1, -1):\n        if a & (1 << bit):\n            abin.append('1')\n        else:\n            if abin:\n                abin.append('0')\n\n    for bit in range(31, -1, -1):\n        if b & (1 << bit):\n            bbin.append('1')\n        else:\n            if bbin:\n                bbin.append('0')\n\n    last = -1\n    for i in range(min(len(abin), len(bbin))):\n        if abin[i] != bbin[i]:\n            last = i\n            break\n\n    if last == -1:\n        diff = abs(len(abin) - len(bbin))\n        return diff, last, abin, bbin\n\n    y = (min(len(abin), len(bbin)) - last) + (max(len(abin), len(bbin)) - last)\n    return y, last, abin, bbin\n\n\ndef construct(a, b, anum, bnum, last):\n    rev = False\n    if anum > bnum:\n        tmp1, tmp2 = anum, a\n        anum, bnum = bnum, tmp1\n        a, b = b, tmp2\n        rev = True\n\n    mn, mx, remove, ans = min(len(a), len(b)), max(len(a), len(b)), -1, []\n\n    if last != -1:\n        remove = mn - last\n\n        for i in range(remove):\n            if i == 0:\n                ans.append(anum // 2)\n            else:\n                ans.append(ans[-1] // 2)\n\n        add = mx - last\n\n        for i in range(add - 1):\n            if b[last + i] == '0':\n                ans.append(2 * ans[-1])\n            else:\n                ans.append(2 * ans[-1] + 1)\n    else:\n        for i in range(min(len(a), len(b)), max(len(a), len(b)) - 1):\n            if b[i] == '0':\n                if i == min(len(a), len(b)):\n                    ans.append(anum * 2)\n                else:\n                    ans.append(ans[-1] * 2)\n            else:\n                if i == min(len(a), len(b)):\n                    ans.append(anum * 2 + 1)\n                else:\n                    ans.append(ans[-1] * 2 + 1)\n\n    if rev:\n        return ans[::-1]\n    else:\n        return ans\n\n\ndef turtle_incomplete_sequence(t: int, test_cases: list[int,list[int]]) -> list[Union[int, list[int]]]:\n    results = []\n    for test in test_cases:\n        n, c = test\n\n        x, ok = [], True\n\n        for i in range(n):\n            if c[i] == -1:\n                continue\n            x.append(i)\n\n        for i in range(len(x) - 1):\n            idx1, idx2 = c[x[i]], c[x[i + 1]]\n            y, last, abin, bbin = ops(idx1, idx2)\n\n            if not (y <= x[i + 1] - x[i] and y % 2 == (x[i + 1] - x[i]) % 2):\n                ok = False\n                break\n\n            z = construct(abin, bbin, c[x[i]], c[x[i + 1]], last)\n\n            for j in range(x[i] + 1, x[i + 1]):\n                if j - x[i] - 1 < len(z):\n                    c[j] = z[j - x[i] - 1]\n                else:\n                    if (j - x[i] - 1 - len(z)) & 1:\n                        c[j] = c[j - 1] // 2\n                    else:\n                        c[j] = c[j - 1] * 2\n\n        if not ok:\n            results.append(-1)\n            continue\n\n        if x:\n            for i in range(x[0] - 1, -1, -1):\n                if (x[0] - 1 - i) & 1:\n                    c[i] = c[i + 1] // 2\n                else:\n                    c[i] = 2 * c[i + 1]\n\n            for i in range(x[-1] + 1, n):\n                if (i - x[-1] - 1) & 1:\n                    c[i] = c[i - 1] // 2\n                else:\n                    c[i] = 2 * c[i - 1]\n        else:\n            c[0] = 67\n            for i in range(1, n):\n                if i & 1:\n                    c[i] = 2 * c[i - 1]\n                else:\n                    c[i] = c[i - 1] // 2\n\n        results.append(c)\n    return results\n",
      "incorrect_solution": "# status: 341134607\n\n#  Test: #4, time: 875 ms., memory: 9928 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 50000\n# 2\n# -1 -1\n# 5\n# -1 2 -1 3 -1\n# 4\n# 2 5 -1 4\n# 2\n# -1 -1\n# 2\n# -1 -1\n# 5\n# -1 3 -1 -1 1\n# 5\n# -1 3 -1 3 6\n# 4\n# -1 3 7 3\n# 4\n# 2 -1 -1 -1\n# 3\n# 2 -1 -1\n# 5\n# -1 3 -1 3 -1\n# 2\n# -1 -1\n# 3\n# 3 -1 -1\n# 2\n# -1 -1\n# 13\n# -1 -1 3 -1 -1 -1 -1 7 -1 -1 3 -1 -1\n# 4\n# -1 7 3 -1\n# 5\n# -1 3 6 -1 7\n# 3\n# -1 3 -1\n# 3\n# -1 5 -1\n# 3\n# -1 -1 -1\n# 5\n# -1 2 1 -1 -1\n# 2\n# -1 1\n# 3\n# -1 2 1\n# 2\n# -1 -1\n# 4\n# -1 -1 1 -1\n# 2\n# -1 6\n# 6\n# -1 2 4 -1 -1 -1\n# 9\n# -1 7 -1 -1 -1 -1 -1 1 -1\n# 16\n# -1 -1 -1 7 -1 -1 -1 3 3 -1 -1 6 3 1 -1 -1\n# 2\n# 6 3\n# 10\n# -1 -1 6 -1 -1 3 6 3 -1 -1\n# 4\n# 6 -1 ...\n# Output\n# 67 134\n# 4 2 1 3 6\n# 2 5 2 4\n# 67 134\n# 67 134\n# 6 3 1 2 1\n# 6 3 6 3 6\n# 6 3 7 3\n# 2 4 2 4\n# 2 4 2\n# 6 3 6 3 6\n# 67 134\n# 3 6 3\n# 67 134\n# 3 6 3 6 3 6 3 7 3 6 3 6 3\n# 14 7 3 6\n# 6 3 6 12 7\n# 6 3 6\n# 10 5 10\n# 67 134 67\n# 4 2 1 2 1\n# 2 1\n# 4 2 1\n# 67 134\n# 1 2 1 2\n# 12 6\n# 4 2 4 8 4 8\n# 14 7 14 7 14 7 14 1 2\n# -1\n# 6 3\n# 6 12 6 12 6 3 6 3 6 3\n# 6 12 6 3\n# 6 6 1\n# 67 134\n# 6 3 6 3 1\n# 6 3 6 3 6 3 6 3 4\n# 3 6 3\n# 67 134 67\n# 2 1\n# 67 134\n# 1 2 1 0 1 0 6 12\n# 2 1 0 0 2\n# 4 2\n# 5 10 5 2 4 2 4 2 1 2 4 2\n# 67 134 67\n# 4 2 4\n# 67 134\n# 6 12\n# 4 8 4\n# 5 10 5 10 5...\n# Answer\n# 2 1\n# 1 2 1 3 6\n# 2 5 2 4\n# 2 1\n# 2 1\n# 6 3 1 2 1\n# 6 3 6 3 6\n# 6 3 7 3\n# 2 1 2 1\n# 2 1 2\n# 6 3 6 3 6\n# 2 1\n# 3 6 3\n# 2 1\n# 3 6 3 7 14 7 14 7 3 6 3 6 3\n# 14 7 3 6\n# 6 3 6 3 7\n# 6 3 6\n# 10 5 10\n# 2 1 2\n# 1 2 1 2 1\n# 2 1\n# 1 2 1\n# 2 1\n# 1 2 1 2\n# 3 6\n# 1 2 4 2 1 2\n# 14 7 3 1 2 1 2 1 2\n# -1\n# 6 3\n# 6 3 6 3 6 3 6 3 6 3\n# 6 3 6 3\n# 6 3 1\n# 2 1\n# 6 3 6 3 1\n# 6 3 1 2 4 8 4 8 4\n# 3 6 3\n# 2 1 2\n# 2 1\n# 2 1\n# 1 2 1 2 1 3 6 3\n# 2 1 2 4 2\n# 1 2\n# 5 10 5 2 1 2 1 2 1 2 4 2\n# 2 1 2\n# 4 2 1\n# 2 1\n# 6 3\n# 4 2 1\n# 5 10 5 10 5 10\n# 2 1 2 1\n# 7 14\n# 6 3 6 3 6 3 6 3 6 3 1 2\n# 6 ...\n# Checker Log\n# wrong answer Neither b[4] = floor(b[5] / 2) nor b[5] = floor(b[4] / 2). (test case 17)\n\n\n\n# Suffix removed + To add <= R - L, parity must be the same\n\ndef ops(a, b):\n    abin, bbin = [], []\n\n    for bit in range(31, -1, -1):\n        if a & (1 << bit):\n            abin.append('1')\n        else:\n            if abin:\n                abin.append('0')\n\n    for bit in range(31, -1, -1):\n        if b & (1 << bit):\n            bbin.append('1')\n        else:\n            if bbin:\n                bbin.append('0')\n\n    last = -1\n    for i in range(min(len(abin), len(bbin))):\n        if abin[i] != bbin[i]:\n            last = i\n            break\n\n    if last == -1:\n        diff = abs(len(abin) - len(bbin))\n        return diff, last, abin, bbin\n\n    y = (min(len(abin), len(bbin)) - last) + (max(len(abin), len(bbin)) - last)\n    return y, last, abin, bbin\n\n\ndef construct(a, b, anum, bnum, last):\n    rev = False\n    if anum > bnum:\n        tmp1, tmp2 = anum, a\n        anum, bnum = bnum, tmp1\n        a, b = b, tmp2\n        rev = True\n\n    mn, mx, remove, ans = min(len(a), len(b)), max(len(a), len(b)), -1, []\n\n    if last != -1:\n        remove = mn - last\n\n        for i in range(remove):\n            if i == 0:\n                ans.append(anum // 2)\n            else:\n                ans.append(ans[-1] // 2)\n\n        add = mx - last\n\n        for i in range(add - 1):\n            if b[last + i] == '0':\n                ans.append(2 * ans[-1])\n            else:\n                ans.append(2 * ans[-1] + 1)\n    else:\n        for i in range(min(len(a), len(b)), max(len(a), len(b))):\n            if b[i] == '0':\n                if i == min(len(a), len(b)):\n                    ans.append(anum * 2)\n                else:\n                    ans.append(ans[-1] * 2)\n            else:\n                if i == min(len(a), len(b)):\n                    ans.append(anum * 2 + 1)\n                else:\n                    ans.append(ans[-1] * 2 + 1)\n\n    if rev:\n        return ans[::-1]\n    else:\n        return ans\n\n\ndef turtle_incomplete_sequence(t: int, test_cases: list[int,list[int]]) -> list[Union[int, list[int]]]:\n    results = []\n    for test in test_cases:\n        n, c = test\n\n        x, ok = [], True\n\n        for i in range(n):\n            if c[i] == -1:\n                continue\n            x.append(i)\n\n        for i in range(len(x) - 1):\n            idx1, idx2 = c[x[i]], c[x[i + 1]]\n            y, last, abin, bbin = ops(idx1, idx2)\n\n            if not (y <= x[i + 1] - x[i] and y % 2 == (x[i + 1] - x[i]) % 2):\n                ok = False\n                break\n\n            z = construct(abin, bbin, c[x[i]], c[x[i + 1]], last)\n\n            for j in range(x[i] + 1, x[i + 1]):\n                if j < len(z):\n                    c[j] = z[j - x[i] - 1]\n                else:\n                    if (j - len(z)) & 1:\n                        c[j] = c[j - 1] // 2\n                    else:\n                        c[j] = c[j - 1] * 2\n\n        if not ok:\n            results.append(-1)\n            continue\n\n        if x:\n            if x[0] - 1 >= 0:\n                if c[x[0]] * 2 >= 10 ** 9:\n                    c[x[0] - 1] = c[x[0]] // 2\n                else:\n                    c[x[0] - 1] = 2 * c[x[0]]\n\n            for i in range(x[0] - 2, -1, -1):\n                if (x[0] - 1 - i) & 1:\n                    c[i] = c[i + 1] // 2\n                else:\n                    c[i] = 2 * c[i + 1]\n\n            if x[-1] + 1 < n:\n                if c[x[-1]] * 2 >= 10 ** 9:\n                    c[x[-1] + 1] = c[x[-1]] // 2\n                else:\n                    c[x[-1] + 1] = c[x[-1]] * 2\n\n            for i in range(x[-1] + 2, n):\n                if (x[-1] + 1 - i) & 1:\n                    c[i] = c[i - 1] // 2\n                else:\n                    c[i] = 2 * c[i - 1]\n        else:\n            c[0] = 67\n            for i in range(1, n):\n                if i & 1:\n                    c[i] = 2 * c[i - 1]\n                else:\n                    c[i] = c[i - 1] // 2\n\n        results.append(c)\n    return results\n"
    }
  },
  {
    "id": "turtle_multiplication",
    "requirements": {
      "signature": "def turtle_multiplication(t: int, test_cases: list[int]) -> list[list[int]]",
      "description": "Turtle just learned how to multiply two integers in his math class, and he was very excited.\n\nThen Piggy gave him an integer $n$, and asked him to construct a sequence $a_1, a_2, \\ldots, a_n$ consisting of integers which satisfied the following conditions:\n\n  * For all $1 \\le i \\le n$, $1 \\le a_i \\le 3 \\cdot 10^5$.    * For all $1 \\le i < j \\le n - 1$, $a_i \\cdot a_{i + 1} \\ne a_j \\cdot a_{j + 1}$. \n\nOf all such sequences, Piggy asked Turtle to find the one with the minimum number of distinct elements.\n\nTurtle definitely could not solve the problem, so please help him!\n\n# Input:\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^6$) — the length of the sequence $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$.\n\n# Output:\nFor each test case, output $n$ integers $a_1, a_2, \\ldots, a_n$ — the elements of the sequence $a$.\n\nIf there are multiple answers, print any of them.\n\n# Example input:\n3\n2\n3\n4\n\n# Example output:\n114514 114514\n1 2 2\n3 3 4 4\n\n# Notes:\nIn the third test case, $a = [3, 4, 2, 6]$ violates the second condition since $a_1 \\cdot a_2 = a_3 \\cdot a_4$. $a = [2, 3, 4, 4]$ satisfy the conditions but its number of distinct elements isn't minimum.\n"
    },
    "judge": "def __judge(t: int, test_cases: list[int], results: list[list[int]]) -> bool:\n    for (n, result) in zip(test_cases, results):\n        if len(result) != n:\n            return False\n        if any(x < 1 or x > 300000 for x in result):\n            return False\n        products = set()\n        for i in range(n - 1):\n            prod = result[i] * result[i + 1]\n            if prod in products:\n                return False\n            products.add(prod)\n        def compute_min_m(n_val):\n            left, right = 1, 2 * 10**6\n            ans = -1\n            while left <= right:\n                mid = (left + right) // 2\n                ok = False\n                if mid % 2 == 1:\n                    edges = mid * (mid + 1) // 2\n                    if edges >= n_val - 1:\n                        ok = True\n                else:\n                    edges = (mid * mid) // 2 + 1\n                    if edges >= n_val - 1:\n                        ok = True\n                if ok:\n                    ans = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return ans\n        m_required = compute_min_m(n)\n        if m_required == -1 or len(set(result)) != m_required:\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [2], turtle_multiplication(1, [2]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [3], turtle_multiplication(1, [3]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [4], turtle_multiplication(1, [4]))"
      }
    ],
    "metadata": {
      "problem_id": "1981D",
      "url": "https://codeforces.com/problemset/problem/1981/D",
      "title": "Turtle and Multiplication",
      "rating": 2400,
      "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "number theory"
      ],
      "div": "Div. 2",
      "time_limit_ms": 3000,
      "memory_limit_mb": 512,
      "correct_solution": "# submission: 333967069\n# status: accepted\n\nimport sys\nimport string\nimport math\nimport array\nimport bisect\nimport os\n#import random\nimport heapq\nimport operator\nfrom io import BytesIO, IOBase\nfrom heapq import heappop,heappush\nfrom functools import lru_cache,cache\nfrom collections import deque,defaultdict,Counter,OrderedDict\nfrom itertools import permutations,combinations\n\nINF = float('inf')\nBUFSIZE = 8192\n\n\ndef turtle_multiplication(t: int, test_cases: list[int]) -> list[list[int]]:\n    results = []\n    \n    MAX = 2*10**6\n    prime = []\n    vis = [False]*(MAX+1)\n    for i in range(2,MAX+1):\n        if vis[i]==False:\n            prime.append(i)\n        for p in prime:\n            if i*p>MAX:\n                break\n            vis[i*p] = True\n            if i%p==0:\n                break\n    #print(len(prime))\n            \n    for n in test_cases:\n        m = 0\n        for i in range(1,10**7):\n            if i%2==1:\n                if i+i*(i-1)//2>=n-1:\n                    m = i\n                    break\n            else:\n                if (i+i*(i-1)//2-(i-2)//2)>=n-1:\n                    m = i\n                    break\n\n        if m==1:\n            results.append([1,1])\n            continue\n        \n        a = prime[:m]\n        \n        g = [[]for i in range(m)]\n        if m%2==1:\n            for i in range(m):\n                for j in range(i+1,m):\n                    g[i].append(j)\n                    g[j].append(i)\n        else:\n            for i in range(m):\n                for j in range(i+1,m):\n                    if not (i%2==1 and j==i+1):\n                        g[i].append(j)\n                        g[j].append(i)\n        \n        def hierholzer(g,st):\n            n = len(g)\n\n            ptr = [0]*n\n            used = [False]*(n*n)\n            stack = [st]\n            path = []\n            \n            while stack:\n                u = stack[-1]\n                if ptr[u] < len(g[u]):\n                    v = g[u][ptr[u]]\n                    ptr[u] += 1\n                    if used[u*n+v]==False:\n                        used[u*n+v] = True\n                        used[v*n+u] = True\n                        stack.append(v)\n                else:\n                    path.append(stack.pop())\n            \n            return path[::-1]\n\n        st = 0\n        for i in range(m):\n            if len(g[i])%2==1:\n                st = i\n                break\n\n        b = hierholzer(g,st)\n        #print(b)\n        \n        ans = []\n        vis = [False]*m\n        for x in b:\n            ans.append(a[x])\n            if vis[x]==False:\n                vis[x] = True\n                ans.append(a[x])\n                \n        while len(ans)>n:\n            ans.pop()\n            \n            \n        #print(m,len(ans))\n        results.append(ans)\n    return results\n",
      "incorrect_solution": "# submission: 333963062\n\n#  Test: #2, time: 577 ms., memory: 45652 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 1412\n# 787\n# 975\n# 466\n# 315\n# 14\n# 1247\n# 141\n# 740\n# 183\n# 1172\n# 1375\n# 27\n# 992\n# 292\n# 1109\n# 139\n# 1269\n# 998\n# 149\n# 889\n# 1410\n# 984\n# 727\n# 1352\n# 598\n# 820\n# 1152\n# 142\n# 1368\n# 348\n# 330\n# 969\n# 601\n# 1297\n# 185\n# 449\n# 666\n# 665\n# 1041\n# 1145\n# 945\n# 41\n# 421\n# 574\n# 287\n# 996\n# 1253\n# 925\n# 1379\n# 316\n# 54\n# 1112\n# 369\n# 946\n# 488\n# 31\n# 720\n# 966\n# 311\n# 706\n# 376\n# 954\n# 455\n# 162\n# 1185\n# 467\n# 1072\n# 247\n# 784\n# 1313\n# 519\n# 36\n# 1147\n# 892\n# 1246\n# 901\n# 1063\n# 1254\n# 686\n# 474\n# 1393\n# 39\n# 1276\n# 1290\n# 131\n# 328\n# 834\n# 1325\n# 319\n# 1097\n# 1087\n# 968\n# 1108\n# 789\n# 381\n# 934\n# 605...\n# Output\n# 2 2 3 3 5 5 2 7 7 3 11 11 2 13 13 3 17 17 2 19 19 3 23 23 2 29 29 3 31 31 2 37 37 3 41 41 2 43 43 3 47 47 2 53 53 3 59 59 2 61 61 3 67 67 2 71 71 3 73 73 2 79 79 3 83 83 2 89 89 3 97 97 2 101 101 3 103 103 2 107 107 3 109 109 2 113 113 3 127 127 2 131 131 3 137 137 2 139 139 3 149 149 2 151 151 3 157 157 2 163 163 3 167 167 2 173 173 3 179 179 5 7 11 5 13 7 17 5 19 7 23 5 29 7 31 5 37 7 41 5 43 7 47 5 53 7 59 5 61 7 67 5 71 7 73 5 79 7 83 5 89 7 97 5 101 7 103 5 107 7 109 5 113 7 127 5 131 7 137 5 139 7 14...\n# Answer\n# 2 173 173 167 167 157 173 163 163 157 157 149 173 151 167 149 163 151 151 149 149 137 173 139 167 137 163 139 157 137 151 139 139 137 137 127 173 131 167 127 163 131 157 127 151 131 149 127 139 131 131 127 127 109 173 113 167 109 163 113 157 109 151 113 149 109 139 113 137 109 131 113 113 109 109 103 173 107 167 103 163 107 157 103 151 107 149 103 139 107 137 103 131 107 127 103 113 107 107 103 103 97 173 101 167 97 163 101 157 97 151 101 149 97 139 101 137 97 131 101 127 97 113 101 109 97 107 101 101 97 9...\n# Checker Log\n# wrong answer Participant's answer is worse than jury's. (test case 1)\n\n\nimport sys\nimport string\nimport math\nimport array\nimport bisect\nimport os\n#import random\nimport heapq\nimport operator\nfrom io import BytesIO, IOBase\nfrom heapq import heappop,heappush\nfrom functools import lru_cache,cache\nfrom collections import deque,defaultdict,Counter,OrderedDict\nfrom itertools import permutations,combinations\n\nINF = float('inf')\nBUFSIZE = 8192\n\n\ndef turtle_multiplication(t: int, test_cases: list[int]) -> list[list[int]]:\n    results = []\n\n    MAX = 2*10**6\n    prime = []\n    vis = [False]*(MAX+1)\n    for i in range(2,MAX+1):\n        if vis[i]==False:\n            prime.append(i)\n        for p in prime:\n            if i*p>MAX:\n                break\n            vis[i*p] = True\n            if i%p==0:\n                break\n    #print(len(prime))\n            \n    for n in test_cases:\n        m = 0\n        for i in range(1,10**7):\n            if i%2==1:\n                if i+i*(i-1)//2>=n+10:\n                    m = i\n                    break\n\n        \n        if m==1:\n            results.append([1,1])\n            continue\n        \n        a = prime[:m]\n        \n        g = [[]for i in range(m)]\n        idx = 0\n        for i in range(m):\n            for j in range(i+1,m):\n                g[i].append((j,idx))\n                g[j].append((i,idx))\n                idx += 1\n        \n        def hierholzer(g,st):\n            stack = [st]\n            ptr = [0] * m\n            used = [False] * (m*m)\n            path = []\n            \n            while stack:\n                u = stack[-1]\n                found = False\n                for i in range(ptr[u], len(g[u])):\n                    v, eid = g[u][i]\n                    if not used[eid]:\n                        used[eid] = True\n                        ptr[u] = i + 1\n                        stack.append(v)\n                        found = True\n                        break\n                if not found:\n                    path.append(stack.pop())\n            \n            circuit = path[::-1]\n            return circuit\n\n        b = hierholzer(g,0)\n        \n        ans = []\n        vis = [False]*m\n        for x in b:\n            ans.append(a[x])\n            if vis[x]==False:\n                vis[x] = True\n                ans.append(a[x])\n                \n        while len(ans)>n:\n            ans.pop()\n            \n            \n        #print(m,len(ans))\n        results.append(ans)\n    return results\n"
    }
  },
  {
    "id": "xorificator",
    "requirements": {
      "signature": "def xorificator(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[tuple[int, str]]",
      "description": "You are given a binary (consisting only of 0s and 1s) $n \\times m$ matrix. You are also given a XORificator, using which you can invert all the values in a chosen row (i.e. replace 0 with 1 and 1 with 0).\n\nA column in the matrix is considered special if it contains exactly one 1. Your task is to find the maximum number of columns that can be made special at the same time, and the set of rows the XORificator should be used on to achieve that.\n\n# Input:\nEach test contains multiple test cases. The first line of input contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 3 \\cdot 10^5$, $n \\cdot m \\leq 3 \\cdot 10^5$).\n\nEach of the following $n$ lines of the test case contains a binary string of length $m$.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n# Output:\nFor each test case, output two lines.\n\nIn the first line, output the maximum number of special columns that is possible to get simultaneously.\n\nIn the second line, output a binary string of length $n$, where the $i$-th character is 0, if you don't use the XORificator on the $i$-th row, and 1, if you use the XORificator on the $i$-th row.\n\nIf there are multiple valid XORificator configurations that achieve the optimal answer, you can output any of them.\n\n# Example input:\n5\n3 4\n1010\n0110\n0100\n1 1\n1\n1 1\n0\n2 5\n00101\n10110\n3 3\n101\n111\n000\n\n# Example output:\n3\n010\n1\n0\n1\n1\n3\n00\n2\n010\n\n# Notes:\nIn the first test case, you can use the XORificator on the second row to make the columns $2$, $3$, and $4$ special.\n\nIn the second test case, the only column is already special, so you don't need to use the XORificator.\n"
    },
    "judge": "from collections import Counter\nimport random\n\ndef __judge(t: int, test_cases: list[tuple[int, int, list[str]]], results: list[tuple[int, str]]) -> bool:\n    for (n, m, matrix), result in zip(test_cases, results):\n\n        if not isinstance(matrix, list) or len(matrix) != n:\n            return False\n        for row in matrix:\n            if not isinstance(row, str) or len(row) != m or any(ch not in \"01\" for ch in row):\n                return False\n\n        if not isinstance(result, (list, tuple)) or len(result) != 2:\n            return False\n        max_cols, config = result\n\n        if not isinstance(max_cols, int) or max_cols < 0 or max_cols > m:\n            return False\n        if not isinstance(config, str) or len(config) != n or any(ch not in \"01\" for ch in config):\n            return False\n\n        rng = random.Random(123456789)\n        rand1 = [rng.getrandbits(64) for _ in range(n)]\n        rand2 = [rng.getrandbits(64) for _ in range(n)]\n\n        col_h1 = [0] * m\n        col_h2 = [0] * m\n        for i in range(n):\n            r1 = rand1[i]\n            r2 = rand2[i]\n            for j, ch in enumerate(matrix[i]):\n                if ch == '1':\n                    col_h1[j] ^= r1\n                    col_h2[j] ^= r2\n\n        cnt = Counter()\n        for j in range(m):\n            h1 = col_h1[j]\n            h2 = col_h2[j]\n            for i in range(n):\n                key = (h1 ^ rand1[i], h2 ^ rand2[i])\n                cnt[key] += 1\n\n        optimal = max(cnt.values()) if cnt else 0\n        if max_cols != optimal:\n            return False\n\n        r_h1 = 0\n        r_h2 = 0\n        for i, ch in enumerate(config):\n            if ch == '1':\n                r_h1 ^= rand1[i]\n                r_h2 ^= rand2[i]\n\n        if cnt.get((r_h1, r_h2), 0) != optimal:\n            return False\n\n        special = 0\n        for j in range(m):\n            ones = 0\n            for i in range(n):\n                if (matrix[i][j] == '1') ^ (config[i] == '1'):\n                    ones += 1\n                    if ones > 1:\n                        break\n            if ones == 1:\n                special += 1\n\n        if not(special == optimal):\n            return False\n    return True\n",
    "tests": [
      {
        "type": "TestFunction",
        "code": "def test_1():\n    assert __judge(1, [(3, 4, ['1010', '0110', '0100'])], xorificator(1, [(3, 4, ['1010', '0110', '0100'])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_2():\n    assert __judge(1, [(1, 1, ['1'])], xorificator(1, [(1, 1, ['1'])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_3():\n    assert __judge(1, [(1, 1, ['0'])], xorificator(1, [(1, 1, ['0'])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_4():\n    assert __judge(1, [(2, 5, ['00101', '10110'])], xorificator(1, [(2, 5, ['00101', '10110'])]))"
      },
      {
        "type": "TestFunction",
        "code": "def test_5():\n    assert __judge(1, [(3, 3, ['101', '111', '000'])], xorificator(1, [(3, 3, ['101', '111', '000'])]))"
      }
    ],
    "metadata": {
      "problem_id": "1977D",
      "url": "https://codeforces.com/problemset/problem/1977/D",
      "title": "XORificator",
      "rating": 2300,
      "tags": [
        "bitmasks",
        "brute force",
        "greedy",
        "hashing"
      ],
      "div": "Div. 2",
      "time_limit_ms": 2000,
      "memory_limit_mb": 256,
      "correct_solution": "# submission: 329299987\n# status: accepted\n\nimport sys\n\ndef xorificator(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[tuple[int, str]]:\n\n    results = []\n    \n    max_n = 3 * 10**5 + 5\n    base = 911382629\n    mod = 10**18 + 3\n    \n    # Precompute pow_base\n    pre_base = [1] * (max_n)\n    for i in range(1, max_n):\n        pre_base[i] = (pre_base[i-1] * base) % mod\n    \n    for test in test_cases:\n        n, m, matrix = test\n        \n        hash_map = {}\n        max_count = 0\n        best_j = best_i = 0\n        \n        for j in range(m):\n            # Compute H_j for column j\n            H_j = 0\n            column = []\n            for i in range(n):\n                a = int(matrix[i][j])\n                column.append(a)\n                H_j = (H_j + a * pre_base[i]) % mod\n            \n            # Process each row i in this column\n            for i in range(n):\n                a = column[i]\n                delta = (1 - 2 * a) * pre_base[i] % mod\n                new_hash = (H_j + delta) % mod\n                \n                if new_hash in hash_map:\n                    current_count, (current_j, current_i) = hash_map[new_hash]\n                    current_count += 1\n                    hash_map[new_hash] = (current_count, (j, i))\n                    if current_count > max_count:\n                        max_count = current_count\n                        best_j, best_i = j, i\n                else:\n                    hash_map[new_hash] = (1, (j, i))\n                    if max_count == 0:\n                        max_count = 1\n                        best_j, best_i = j, i\n        \n        # Construct the flip pattern\n        flip = ['0'] * n\n        j_example = best_j\n        i_example = best_i\n        for k in range(n):\n            if k == i_example:\n                val = 1 - int(matrix[k][j_example])\n            else:\n                val = int(matrix[k][j_example])\n            flip[k] = '1' if val else '0'\n\n        results.append((max_count, flip))\n\n    return results\n",
      "incorrect_solution": "# submission: 329299984\n\n#  Test: #2, time: 234 ms., memory: 9024 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n# Input\n# 10000\n# 2 2\n# 01\n# 01\n# 2 2\n# 00\n# 11\n# 2 3\n# 101\n# 010\n# 7 2\n# 00\n# 01\n# 00\n# 10\n# 00\n# 01\n# 00\n# 1 8\n# 01111011\n# 1 3\n# 100\n# 3 2\n# 10\n# 10\n# 11\n# 2 2\n# 01\n# 00\n# 4 1\n# 1\n# 1\n# 0\n# 0\n# 6 1\n# 1\n# 0\n# 0\n# 1\n# 0\n# 1\n# 2 1\n# 1\n# 1\n# 1 2\n# 10\n# 2 2\n# 10\n# 01\n# 3 1\n# 1\n# 1\n# 0\n# 1 4\n# 0001\n# 1 4\n# 0100\n# 4 1\n# 1\n# 1\n# 1\n# 1\n# 4 1\n# 1\n# 0\n# 1\n# 1\n# 5 1\n# 1\n# 0\n# 1\n# 0\n# 0\n# 1 2\n# 01\n# 2 1\n# 1\n# 1\n# 2 1\n# 0\n# 1\n# 7 1\n# 1\n# 1\n# 0\n# 1\n# 0\n# 0\n# 0\n# 6 1\n# 0\n# 1\n# 0\n# 0\n# 1\n# 0\n# 1 2\n# 01\n# 2 1\n# 1\n# 0\n# 2 1\n# 1\n# 0\n# 11 1\n# 1\n# 1\n# 0\n# 0\n# 0\n# 0\n# 0\n# 1\n# 0\n# 0\n# 0\n# 1 4\n# 0000\n# 3 1\n# 0\n# 1\n# 0\n# 1 7\n# 0101010\n# 1 5\n# 00111\n# 2 2\n# 10\n# 01...\n# Output\n# 2\n# 10\n# 2\n# 00\n# 3\n# 00\n# 1\n# 0000000\n# 6\n# 0\n# 2\n# 1\n# 1\n# 000\n# 1\n# 00\n# 1\n# 1000\n# 0\n# 000000\n# 1\n# 10\n# 1\n# 0\n# 2\n# 00\n# 1\n# 100\n# 3\n# 1\n# 3\n# 1\n# 0\n# 0000\n# 0\n# 0000\n# 1\n# 10000\n# 1\n# 0\n# 1\n# 10\n# 1\n# 00\n# 0\n# 0000000\n# 1\n# 010000\n# 1\n# 0\n# 1\n# 00\n# 1\n# 00\n# 0\n# 00000000000\n# 4\n# 1\n# 1\n# 000\n# 4\n# 1\n# 3\n# 0\n# 2\n# 00\n# 3\n# 0\n# 1\n# 00\n# 1\n# 010000\n# 0\n# 000000\n# 3\n# 10\n# 2\n# 0\n# 15\n# 1\n# 0\n# 0000\n# 1\n# 000\n# 1\n# 00\n# 1\n# 10\n# 0\n# 0000\n# 1\n# 00\n# 1\n# 100000\n# 1\n# 0\n# 2\n# 0\n# 3\n# 1\n# 2\n# 1\n# 0\n# 00000\n# 2\n# 100\n# 2\n# 1\n# 2\n# 1\n# 1\n# 000\n# 1\n# 00\n# 2\n# 0\n# 1\n# 10\n# 3\n# 1\n# 3\n# 1\n# 5\n# 00\n# 0\n# 0000000000\n# 3\n# 1\n# 0\n# 0000000\n# 3\n# 0...\n# Answer\n# 2\n# 01\n# 2\n# 11\n# 3\n# 00\n# 1\n# 1001000\n# 6\n# 0\n# 2\n# 1\n# 2\n# 101\n# 1\n# 10\n# 1\n# 0100\n# 1\n# 000101\n# 1\n# 01\n# 1\n# 0\n# 2\n# 11\n# 1\n# 010\n# 3\n# 1\n# 3\n# 1\n# 1\n# 0111\n# 1\n# 0011\n# 1\n# 00100\n# 1\n# 1\n# 1\n# 01\n# 1\n# 11\n# 1\n# 0101000\n# 1\n# 110010\n# 1\n# 1\n# 1\n# 00\n# 1\n# 00\n# 1\n# 01000001000\n# 4\n# 1\n# 1\n# 110\n# 4\n# 1\n# 3\n# 0\n# 2\n# 11\n# 3\n# 0\n# 1\n# 00\n# 1\n# 111000\n# 1\n# 011111\n# 3\n# 10\n# 2\n# 0\n# 15\n# 1\n# 1\n# 1111\n# 1\n# 000\n# 1\n# 00\n# 1\n# 01\n# 1\n# 0111\n# 1\n# 11\n# 1\n# 000101\n# 1\n# 1\n# 2\n# 0\n# 3\n# 1\n# 2\n# 1\n# 1\n# 11111\n# 2\n# 100\n# 2\n# 1\n# 2\n# 1\n# 1\n# 110\n# 1\n# 00\n# 2\n# 0\n# 1\n# 10\n# 3\n# 1\n# 3\n# 1\n# 5\n# 00\n# 1\n# 1100101111\n# 3\n# 1\n# 1\n# 1011010\n# 3\n# 0...\n# Checker Log\n# wrong answer The answer is wrong: expected = 2, found = 1 (test case 7)\n\n\n\nimport sys\n\ndef xorificator(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[tuple[int, str]]:\n\n    results = []\n\n    for test in test_cases:\n        n, m, matrix = test\n        s = [0] * m\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == '1':\n                    s[j] +=1\n        target = [1 - s[j] for j in range(m)]\n        initial_count = sum(1 for j in range(m) if s[j] == 1)\n        max_count = initial_count\n        best_row = -1  # -1 means no flip is the best\n        \n        for i in range(n):\n            current = 0\n            for j in range(m):\n                # Compute c_ij for row i and column j\n                if matrix[i][j] == '0':\n                    c = 1\n                else:\n                    c = -1\n                if c == target[j]:\n                    current +=1\n            if current > max_count:\n                max_count = current\n                best_row = i\n        \n        if best_row == -1:\n            results.append((max_count, '0' * n))\n        else:\n            res = ['0'] * n\n            res[best_row] = '1'\n            results.append((max_count, ''.join(res)))\n\n    return results\n"
    }
  }
]