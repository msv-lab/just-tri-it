[
    {
        "id": "different_string",
        "requirements": {
            "signature": "def different_string(s: str) -> str",
            "description": "Given a string s consisting of lowercase English letters, rearrange the characters to form a new string r that is not equal to s. If it's impossible, return 'NO'. Otherwise, return 'YES' followed by a newline and the rearranged string."
        },
        "judge": "def __judge(s: str, result: str) -> bool:\n    lines = result.strip().split('\\n')\n    if len(lines) == 1 and lines[0].upper() == 'NO':\n        # Check if all characters in s are the same\n        return len(set(s)) == 1\n    if len(lines) != 2:\n        return False\n    if lines[0].upper() != 'YES':\n        return False\n    r = lines[1]\n    # Check if r is a valid rearrangement of s and r != s\n    return sorted(s) == sorted(r) and s != r",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge('codeforces', different_string('codeforces'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge('aaaaa', different_string('aaaaa'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge('xxxxy', different_string('xxxxy'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge('co', different_string('co'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge('d', different_string('d'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge('nutdealer', different_string('nutdealer'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_7():\n    assert __judge('mwistht', different_string('mwistht'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_8():\n    assert __judge('hhhhhhhhhh', different_string('hhhhhhhhhh'))"
            }
        ],
        "metadata": {
            "problem_id": "1971B",
            "url": "https://codeforces.com/problemset/problem/1971/B",
            "title": "Different String",
            "rating": 800,
            "tags": [
                "implementation",
                "strings"
            ],
            "div": "Div. 4",
            "time_limit_ms": 1000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "ingenuity_2",
        "requirements": {
            "signature": "def ingenuity_2(n: int, s: str) -> str",
            "description": "Given n instructions (N/S/E/W), distribute them between a rover and helicopter so both end at the same position. Each device must execute at least one instruction. Return distribution string with 'R' for rover, 'H' for helicopter, or 'NO' if impossible."
        },
        "judge": "def __judge(n: int, s: str, result: str) -> bool:\n    if result == 'NO':\n        x_total = 0\n        y_total = 0\n        for c in s:\n            if c == 'E':\n                x_total += 1\n            elif c == 'W':\n                x_total -= 1\n            elif c == 'N':\n                y_total += 1\n            elif c == 'S':\n                y_total -= 1\n        if x_total % 2 != 0 or y_total % 2 != 0:\n            return True\n        if x_total == 0 and y_total == 0:\n            if n == 2:\n                return True\n            else:\n                return False\n        return False\n    if len(result) != n:\n        return False\n    rx, ry, hx, hy = 0, 0, 0, 0\n    r_count, h_count = 0, 0\n    for i in range(n):\n        dx, dy = 0, 0\n        if s[i] == 'N': dy = 1\n        elif s[i] == 'S': dy = -1\n        elif s[i] == 'E': dx = 1\n        elif s[i] == 'W': dx = -1\n        if result[i] == 'R':\n            rx += dx\n            ry += dy\n            r_count += 1\n        elif result[i] == 'H':\n            hx += dx\n            hy += dy\n            h_count += 1\n        else:\n            return False\n    return rx == hx and ry == hy and r_count > 0 and h_count > 0",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(6, 'NENSNE', ingenuity_2(6, 'NENSNE'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, 'WWW', ingenuity_2(3, 'WWW'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(6, 'NESSWS', ingenuity_2(6, 'NESSWS'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(2, 'SN', ingenuity_2(2, 'SN'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(2, 'WE', ingenuity_2(2, 'WE'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(4, 'SSNN', ingenuity_2(4, 'SSNN'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_7():\n    assert __judge(4, 'WESN', ingenuity_2(4, 'WESN'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_8():\n    assert __judge(2, 'SS', ingenuity_2(2, 'SS'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_9():\n    assert __judge(4, 'EWNN', ingenuity_2(4, 'EWNN'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_10():\n    assert __judge(4, 'WEWE', ingenuity_2(4, 'WEWE'))"
            }
        ],
        "metadata": {
            "problem_id": "1974D",
            "url": "https://codeforces.com/problemset/problem/1974/D",
            "title": "Ingenuity-2",
            "rating": 1400,
            "tags": [
                "constructive algorithms",
                "greedy",
                "implementation"
            ],
            "div": "Div. 3",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "binary_colouring",
        "requirements": {
            "signature": "def binary_colouring(x: int) -> tuple[int, list[int]]",
            "description": "Find array a of length n (1≤n≤32) where each a[i] is -1, 0, or 1, such that x = sum(a[i] * 2^i), and no two consecutive elements are both non-zero. Return (n, array)."
        },
        "judge": "def __judge(x: int, result: tuple[int, list[int]]) -> bool:\n    n, a = result\n    if not (1 <= n <= 32):\n        return False\n    if len(a) != n:\n        return False\n    # Check each element is -1, 0, or 1\n    for val in a:\n        if val not in [-1, 0, 1]:\n            return False\n    # Check sum equals x\n    total = sum(a[i] * (2 ** i) for i in range(n))\n    if total != x:\n        return False\n    # Check no consecutive non-zero elements\n    for i in range(n - 1):\n        if a[i] != 0 and a[i + 1] != 0:\n            return False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, binary_colouring(1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(14, binary_colouring(14))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(24, binary_colouring(24))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(15, binary_colouring(15))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(27, binary_colouring(27))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(11, binary_colouring(11))"
            },
            {
                "type": "TestFunction",
                "code": "def test_7():\n    assert __judge(19, binary_colouring(19))"
            }
        ],
        "metadata": {
            "problem_id": "1977B",
            "url": "https://codeforces.com/problemset/problem/1977/B",
            "title": "Binary Colouring",
            "rating": 1100,
            "tags": [
                "bitmasks",
                "constructive algorithms",
                "greedy",
                "math"
            ],
            "div": "Div. 2",
            "time_limit_ms": 1000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "xorificator",
        "requirements": {
            "signature": "def xorificator(n: int, m: int, matrix: list[str]) -> tuple[int, str]",
            "description": "Given n×m binary matrix, find which rows to XOR (invert) to maximize columns with exactly one 1. Return (max_special_columns, binary_string) where binary_string[i]='1' if row i should be XORed."
        },
        "judge": "def __judge(n: int, m: int, matrix: list[str], result: tuple[int, str]) -> bool:\n    from collections import Counter\n    import random\n\n    if not isinstance(matrix, list) or len(matrix) != n:\n        return False\n    for row in matrix:\n        if not isinstance(row, str) or len(row) != m or any(ch not in \"01\" for ch in row):\n            return False\n\n    if not isinstance(result, (list, tuple)) or len(result) != 2:\n        return False\n    max_cols, config = result\n\n    if not isinstance(max_cols, int) or max_cols < 0 or max_cols > m:\n        return False\n    if not isinstance(config, str) or len(config) != n or any(ch not in \"01\" for ch in config):\n        return False\n\n    rng = random.Random(123456789)\n    rand1 = [rng.getrandbits(64) for _ in range(n)]\n    rand2 = [rng.getrandbits(64) for _ in range(n)]\n\n    col_h1 = [0] * m\n    col_h2 = [0] * m\n    for i in range(n):\n        r1 = rand1[i]\n        r2 = rand2[i]\n        for j, ch in enumerate(matrix[i]):\n            if ch == '1':\n                col_h1[j] ^= r1\n                col_h2[j] ^= r2\n\n    cnt = Counter()\n    for j in range(m):\n        h1 = col_h1[j]\n        h2 = col_h2[j]\n        for i in range(n):\n            key = (h1 ^ rand1[i], h2 ^ rand2[i])\n            cnt[key] += 1\n\n    optimal = max(cnt.values()) if cnt else 0\n    if max_cols != optimal:\n        return False\n\n    r_h1 = 0\n    r_h2 = 0\n    for i, ch in enumerate(config):\n        if ch == '1':\n            r_h1 ^= rand1[i]\n            r_h2 ^= rand2[i]\n\n    if cnt.get((r_h1, r_h2), 0) != optimal:\n        return False\n\n    special = 0\n    for j in range(m):\n        ones = 0\n        for i in range(n):\n            if (matrix[i][j] == '1') ^ (config[i] == '1'):\n                ones += 1\n                if ones > 1:\n                    break\n        if ones == 1:\n            special += 1\n\n    return special == optimal",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, 4, ['1010', '0110', '0100'], xorificator(3, 4, ['1010', '0110', '0100']))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(1, 1, ['1'], xorificator(1, 1, ['1']))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(1, 1, ['0'], xorificator(1, 1, ['0']))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(2, 5, ['00101', '10110'], xorificator(2, 5, ['00101', '10110']))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(3, 3, ['101', '111', '000'], xorificator(3, 3, ['101', '111', '000']))"
            }
        ],
        "metadata": {
            "problem_id": "1977D",
            "url": "https://codeforces.com/problemset/problem/1977/D",
            "title": "XORificator",
            "rating": 2300,
            "tags": [
                "bitmasks",
                "brute force",
                "greedy",
                "hashing"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "manhattan_permutations",
        "requirements": {
            "signature": "def manhattan_permutations(n: int, k: int) -> str",
            "description": "Find permutation p of [1,2,...,n] with Manhattan value |p[0]-1|+|p[1]-2|+...+|p[n-1]-n| equal to k. Return 'No' if impossible, otherwise 'Yes\\n' followed by the permutation."
        },
        "judge": "def __judge(n: int, k: int, result: str) -> bool:\n    lines = result.strip().split('\\n')\n    if lines[0].upper() == 'NO':\n        max_val = (n * n) // 2\n        return k > max_val or k % 2 != 0\n    if lines[0].upper() != 'YES' or len(lines) != 2:\n        return False\n    try:\n        perm = list(map(int, lines[1].split()))\n    except:\n        return False\n    if len(perm) != n:\n        return False\n    if sorted(perm) != list(range(1, n + 1)):\n        return False\n    manhattan = sum(abs(perm[i] - (i + 1)) for i in range(n))\n    return manhattan == k",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, 4, manhattan_permutations(3, 4))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(4, 5, manhattan_permutations(4, 5))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(7, 0, manhattan_permutations(7, 0))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(1, 1000000000000, manhattan_permutations(1, 1000000000000))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(8, 14, manhattan_permutations(8, 14))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(112, 777, manhattan_permutations(112, 777))"
            },
            {
                "type": "TestFunction",
                "code": "def test_7():\n    assert __judge(5, 12, manhattan_permutations(5, 12))"
            },
            {
                "type": "TestFunction",
                "code": "def test_8():\n    assert __judge(5, 2, manhattan_permutations(5, 2))"
            }
        ],
        "metadata": {
            "problem_id": "1978C",
            "url": "https://codeforces.com/problemset/problem/1978/C",
            "title": "Manhattan Permutations",
            "rating": 1300,
            "tags": [
                "constructive algorithms",
                "data structures",
                "greedy",
                "implementation",
                "math"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "earning_on_bets",
        "requirements": {
            "signature": "def earning_on_bets(n: int, k: list[int]) -> str",
            "description": "Given n outcomes with multipliers k[i], find bets x[i] such that sum(x[i]) < x[j]*k[j] for all j. Return '-1' if impossible, otherwise return space-separated bets."
        },
        "judge": "def __judge(n: int, k: list[int], result: str) -> bool:\n    if result == '-1':\n        from math import gcd\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        current_lcm = 1\n        for ki in k:\n            current_lcm = lcm(current_lcm, ki)\n        sum_terms = 0\n        for ki in k:\n            sum_terms += current_lcm // ki\n        return sum_terms >= current_lcm\n    try:\n        x = list(map(int, result.split()))\n    except:\n        return False\n    if len(x) != n:\n        return False\n    if any(xi < 1 or xi > 10**9 for xi in x):\n        return False\n    total = sum(x)\n    for i in range(n):\n        if x[i] * k[i] <= total:\n            return False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, [3, 2, 7], earning_on_bets(3, [3, 2, 7]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(2, [3, 3], earning_on_bets(2, [3, 3]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(5, [5, 5, 5, 5, 5], earning_on_bets(5, [5, 5, 5, 5, 5]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(6, [7, 9, 3, 17, 9, 13], earning_on_bets(6, [7, 9, 3, 17, 9, 13]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(3, [6, 3, 2], earning_on_bets(3, [6, 3, 2]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(5, [9, 4, 6, 8, 3], earning_on_bets(5, [9, 4, 6, 8, 3]))"
            }
        ],
        "metadata": {
            "problem_id": "1979C",
            "url": "https://codeforces.com/problemset/problem/1979/C",
            "title": "Earning on Bets",
            "rating": 1200,
            "tags": [
                "binary search",
                "combinatorics",
                "constructive algorithms",
                "number theory"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "fixing_binary_string",
        "requirements": {
            "signature": "def fixing_binary_string(n: int, k: int, s: str) -> int",
            "description": "Given binary string s and divisor k of n, find p such that after reversing s[0:p] and shifting left p times, the result is k-proper. Return p or -1 if impossible."
        },
        "judge": "def __judge(n: int, k: int, s: str, p: int) -> bool:\n    if p == -1:\n        # Check if no valid p exists\n        last_char = s[-1]\n        x = 0\n        for i in reversed(range(n)):\n            if s[i] == last_char:\n                x += 1\n            else:\n                break\n        \n        if x > k:\n            return True  # No solution exists\n        \n        candidates = []\n        if x == k:\n            # Case x == k\n            found = False\n            for i in reversed(range(n - k)):\n                if s[i] == s[i + k]:\n                    candidates.append(i + 1)\n                    found = True\n                    break\n            candidates.append(n)  # Fallback to p = n\n        else:\n            # Case x < k\n            i = 0\n            added = False\n            while i < n:\n                if s[i] != last_char:\n                    i += 1\n                    continue\n                j = i\n                while j + 1 < n and s[j + 1] == last_char:\n                    j += 1\n                block_len = j - i + 1\n                if block_len + x == k:\n                    candidates.append(j + 1)\n                    added = True\n                    break\n                elif block_len + x == 2 * k:\n                    candidates.append(i + (k - x))\n                    added = True\n                    break\n                i = j + 1\n            if not added:\n                candidates.append(n)\n        \n        # Check all candidates\n        valid_found = False\n        for candidate_p in candidates:\n            if not (1 <= candidate_p <= n):\n                continue\n            # Apply reverse and shift\n            reversed_part = s[candidate_p - 1::-1]\n            new_s = reversed_part + s[candidate_p:]\n            rotated = new_s[candidate_p:] + new_s[:candidate_p]\n            # Check if k-proper\n            valid = True\n            if not all(c == rotated[0] for c in rotated[:k]):\n                valid = False\n            else:\n                for i in range(len(rotated) - k):\n                    if rotated[i] == rotated[i + k]:\n                        valid = False\n                        break\n            if valid:\n                valid_found = True\n                break\n        return not valid_found\n    else:\n        # Check if p is valid\n        if not (1 <= p <= n):\n            return False\n        # Apply reverse and shift\n        reversed_part = s[p - 1::-1]\n        new_s = reversed_part + s[p:]\n        rotated = new_s[p:] + new_s[:p]\n        # Check if k-proper\n        if not all(c == rotated[0] for c in rotated[:k]):\n            return False\n        for i in range(n - k):\n            if rotated[i] == rotated[i + k]:\n                return False\n        return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(8, 4, '11100001', fixing_binary_string(8, 4, '11100001'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(4, 2, '1110', fixing_binary_string(4, 2, '1110'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(12, 3, '111000100011', fixing_binary_string(12, 3, '111000100011'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(5, 5, '00000', fixing_binary_string(5, 5, '00000'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(6, 1, '101001', fixing_binary_string(6, 1, '101001'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(8, 4, '01110001', fixing_binary_string(8, 4, '01110001'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_7():\n    assert __judge(12, 2, '110001100110', fixing_binary_string(12, 2, '110001100110'))"
            }
        ],
        "metadata": {
            "problem_id": "1979D",
            "url": "https://codeforces.com/problemset/problem/1979/D",
            "title": "Fixing a Binary String",
            "rating": 1800,
            "tags": [
                "bitmasks",
                "brute force",
                "constructive algorithms",
                "dp",
                "greedy",
                "hashing",
                "strings"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "manhattan_triangle",
        "requirements": {
            "signature": "def manhattan_triangle(n: int, d: int, points: list[tuple[int, int]]) -> tuple[int, int, int]",
            "description": "Find three points from the given set that form a Manhattan triangle with distance d between each pair. Return indices (1-based) or (0, 0, 0) if impossible."
        },
        "judge": "def __judge(n: int, d: int, points: list[tuple[int, int]], result: tuple[int, int, int]) -> bool:\n    i, j, k = result\n    if (i, j, k) == (0, 0, 0):\n        sum_groups = {}\n        for idx, (x, y) in enumerate(points):\n            s = x + y\n            if s not in sum_groups:\n                sum_groups[s] = []\n            sum_groups[s].append((x, idx))\n        for key in sum_groups:\n            sum_groups[key].sort()\n        found = False\n        for idx, (x, y) in enumerate(points):\n            s = x + y\n            if s not in sum_groups:\n                continue\n            lst = sum_groups[s]\n            xs = [item[0] for item in lst]\n            target_x = x + (d // 2)\n            low = 0\n            high = len(xs)\n            while low < high:\n                mid = (low + high) // 2\n                if xs[mid] < target_x:\n                    low = mid + 1\n                else:\n                    high = mid\n            pos = low\n            if pos < len(xs) and xs[pos] == target_x:\n                s_plus = s + d\n                if s_plus in sum_groups:\n                    third_list = sum_groups[s_plus]\n                    t_xs = [item[0] for item in third_list]\n                    x_min = target_x\n                    x_max = target_x + (d // 2)\n                    low3 = 0\n                    high3 = len(t_xs)\n                    while low3 < high3:\n                        mid3 = (low3 + high3) // 2\n                        if t_xs[mid3] < x_min:\n                            low3 = mid3 + 1\n                        else:\n                            high3 = mid3\n                    pos3 = low3\n                    if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                        found = True\n                        break\n                if not found:\n                    s_minus = s - d\n                    if s_minus in sum_groups:\n                        third_list = sum_groups[s_minus]\n                        t_xs = [item[0] for item in third_list]\n                        x_min = x - (d // 2)\n                        x_max = target_x - (d // 2)\n                        low3 = 0\n                        high3 = len(t_xs)\n                        while low3 < high3:\n                            mid3 = (low3 + high3) // 2\n                            if t_xs[mid3] < x_min:\n                                low3 = mid3 + 1\n                            else:\n                                high3 = mid3\n                        pos3 = low3\n                        if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                            found = True\n                            break\n            if found:\n                break\n        if not found:\n            diff_groups = {}\n            for idx, (x, y) in enumerate(points):\n                diff = x - y\n                if diff not in diff_groups:\n                    diff_groups[diff] = []\n                diff_groups[diff].append((x, idx))\n            for key in diff_groups:\n                diff_groups[key].sort()\n            for idx, (x, y) in enumerate(points):\n                diff = x - y\n                if diff not in diff_groups:\n                    continue\n                lst = diff_groups[diff]\n                xs = [item[0] for item in lst]\n                target_x = x + (d // 2)\n                low = 0\n                high = len(xs)\n                while low < high:\n                    mid = (low + high) // 2\n                    if xs[mid] < target_x:\n                        low = mid + 1\n                    else:\n                        high = mid\n                pos = low\n                if pos < len(xs) and xs[pos] == target_x:\n                    diff_plus = diff + d\n                    if diff_plus in diff_groups:\n                        third_list = diff_groups[diff_plus]\n                        t_xs = [item[0] for item in third_list]\n                        x_min = target_x\n                        x_max = target_x + (d // 2)\n                        low3 = 0\n                        high3 = len(t_xs)\n                        while low3 < high3:\n                            mid3 = (low3 + high3) // 2\n                            if t_xs[mid3] < x_min:\n                                low3 = mid3 + 1\n                            else:\n                                high3 = mid3\n                        pos3 = low3\n                        if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                            found = True\n                            break\n                    if not found:\n                        diff_minus = diff - d\n                        if diff_minus in diff_groups:\n                            third_list = diff_groups[diff_minus]\n                            t_xs = [item[0] for item in third_list]\n                            x_min = x - (d // 2)\n                            x_max = target_x - (d // 2)\n                            low3 = 0\n                            high3 = len(t_xs)\n                            while low3 < high3:\n                                mid3 = (low3 + high3) // 2\n                                if t_xs[mid3] < x_min:\n                                    low3 = mid3 + 1\n                                else:\n                                    high3 = mid3\n                            pos3 = low3\n                            if pos3 < len(t_xs) and t_xs[pos3] <= x_max:\n                                found = True\n                                break\n                if found:\n                    break\n        return not found\n    else:\n        if not (1 <= i <= n and 1 <= j <= n and 1 <= k <= n):\n            return False\n        if len({i-1, j-1, k-1}) != 3:\n            return False\n        p1 = points[i-1]\n        p2 = points[j-1]\n        p3 = points[k-1]\n        d12 = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        d13 = abs(p1[0] - p3[0]) + abs(p1[1] - p3[1])\n        d23 = abs(p2[0] - p3[0]) + abs(p2[1] - p3[1])\n        return d12 == d and d13 == d and d23 == d",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(6, 4, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)], manhattan_triangle(6, 4, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(5, 4, [(0, 0), (0, -2), (5, -3), (3, -5), (2, -2)], manhattan_triangle(5, 4, [(0, 0), (0, -2), (5, -3), (3, -5), (2, -2)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(6, 6, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)], manhattan_triangle(6, 6, [(3, 1), (0, 0), (0, -2), (5, -3), (3, -5), (2, -2)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(4, 4, [(3, 0), (0, 3), (-3, 0), (0, -3)], manhattan_triangle(4, 4, [(3, 0), (0, 3), (-3, 0), (0, -3)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(10, 8, [(2, 1), (-5, -1), (-4, -1), (-5, -3), (0, 1), (-2, 5), (-4, 4), (-4, 2), (0, 0), (-4, 1)], manhattan_triangle(10, 8, [(2, 1), (-5, -1), (-4, -1), (-5, -3), (0, 1), (-2, 5), (-4, 4), (-4, 2), (0, 0), (-4, 1)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(4, 400000, [(100000, 100000), (-100000, 100000), (100000, -100000), (-100000, -100000)], manhattan_triangle(4, 400000, [(100000, 100000), (-100000, 100000), (100000, -100000), (-100000, -100000)]))"
            }
        ],
        "metadata": {
            "problem_id": "1979E",
            "url": "https://codeforces.com/problemset/problem/1979/E",
            "title": "Manhattan Triangle",
            "rating": 2400,
            "tags": [
                "binary search",
                "constructive algorithms",
                "data structures",
                "geometry",
                "implementation",
                "two pointers"
            ],
            "div": "Div. 2",
            "time_limit_ms": 3000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "turtle_incomplete_sequence",
        "requirements": {
            "signature": "def turtle_incomplete_sequence(n: int, a: list[int]) -> str",
            "description": "Complete sequence where -1s are missing values. Adjacent elements must satisfy: a[i] = a[i+1]//2 or a[i+1] = a[i]//2. Return completed sequence or '-1' if impossible."
        },
        "judge": "def __judge(n: int, a: list[int], result: str) -> bool:\n    def my_lg(x): return x.bit_length()-1 if x else -1\n    if result.strip() == '-1':\n        all_neg = all(x == -1 for x in a)\n        if all_neg: return False\n        l, r, vc = -1, -1, []\n        for i in range(n):\n            if a[i] != -1:\n                if l == -1: l = i\n                r = i\n                vc.append(i)\n        if l == -1: return False\n        possible = True\n        for k in range(len(vc)-1):\n            i1, i2 = vc[k], vc[k+1]\n            x, y = a[i1], a[i2]\n            L, R = [], []\n            a1, b = x, y\n            while my_lg(a1) > my_lg(b):\n                L.append(a1)\n                a1 >>=1\n            while my_lg(b) > my_lg(a1):\n                R.append(b)\n                b >>=1\n            while a1 != b:\n                L.append(a1)\n                R.append(b)\n                a1 >>=1\n                b >>=1\n            path = L + [a1] + R[::-1]\n            path_len = len(path)\n            required_length = i2 - i1\n            if path_len > required_length +1 or (path_len %2) != ((required_length +1) %2):\n                possible = False\n                break\n        return not possible\n    try:\n        b = list(map(int, result.strip().split()))\n    except:\n        return False\n    if len(b)!=n: return False\n    for i in range(n):\n        if a[i] != -1 and b[i] != a[i]: return False\n        if not (1<=b[i]<=10**9): return False\n    for i in range(n-1):\n        if b[i] != (b[i+1]//2) and b[i+1] != (b[i]//2): return False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(8, [-1, -1, -1, 2, -1, -1, 1, -1], turtle_incomplete_sequence(8, [-1, -1, -1, 2, -1, -1, 1, -1]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(4, [-1, -1, -1, -1], turtle_incomplete_sequence(4, [-1, -1, -1, -1]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(6, [3, -1, -1, -1, 9, -1], turtle_incomplete_sequence(6, [3, -1, -1, -1, 9, -1]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(4, [-1, 5, -1, 6], turtle_incomplete_sequence(4, [-1, 5, -1, 6]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(4, [2, -1, -1, 3], turtle_incomplete_sequence(4, [2, -1, -1, 3]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(4, [1, 2, 3, 4], turtle_incomplete_sequence(4, [1, 2, 3, 4]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_7():\n    assert __judge(2, [4, 2], turtle_incomplete_sequence(2, [4, 2]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_8():\n    assert __judge(5, [-1, 3, -1, 3, 6], turtle_incomplete_sequence(5, [-1, 3, -1, 3, 6]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_9():\n    assert __judge(13, [-1, -1, 3, -1, -1, -1, -1, 7, -1, -1, 3, -1, -1], turtle_incomplete_sequence(13, [-1, -1, 3, -1, -1, -1, -1, 7, -1, -1, 3, -1, -1]))"
            }
        ],
        "metadata": {
            "problem_id": "1981C",
            "url": "https://codeforces.com/problemset/problem/1981/C",
            "title": "Turtle and an Incomplete Sequence",
            "rating": 1800,
            "tags": [
                "bitmasks",
                "brute force",
                "constructive algorithms",
                "greedy",
                "implementation",
                "math"
            ],
            "div": "Div. 2",
            "time_limit_ms": 3000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "turtle_multiplication",
        "requirements": {
            "signature": "def turtle_multiplication(n: int) -> list[int]",
            "description": "Construct sequence of length n where all elements are between 1 and 300000, and all products a[i]*a[i+1] are distinct, minimizing number of distinct elements."
        },
        "judge": "def __judge(n: int, result: list[int]) -> bool:\n    if len(result) != n:\n        return False\n    if any(x < 1 or x > 300000 for x in result):\n        return False\n    products = set()\n    for i in range(n - 1):\n        prod = result[i] * result[i + 1]\n        if prod in products:\n            return False\n        products.add(prod)\n    def compute_min_m(n_val):\n        left, right = 1, 2 * 10**6\n        ans = -1\n        while left <= right:\n            mid = (left + right) // 2\n            ok = False\n            if mid % 2 == 1:\n                edges = mid * (mid + 1) // 2\n                if edges >= n_val - 1:\n                    ok = True\n            else:\n                edges = (mid * mid) // 2 + 1\n                if edges >= n_val - 1:\n                    ok = True\n            if ok:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans\n    m_required = compute_min_m(n)\n    if m_required == -1 or len(set(result)) != m_required:\n        return False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(2, turtle_multiplication(2))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, turtle_multiplication(3))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(4, turtle_multiplication(4))"
            }
        ],
        "metadata": {
            "problem_id": "1981D",
            "url": "https://codeforces.com/problemset/problem/1981/D",
            "title": "Turtle and Multiplication",
            "rating": 2400,
            "tags": [
                "constructive algorithms",
                "dfs and similar",
                "graphs",
                "number theory"
            ],
            "div": "Div. 2",
            "time_limit_ms": 3000,
            "memory_limit_mb": 512
        }
    },
    {
        "id": "increasing_sequence_fixed_or",
        "requirements": {
            "signature": "def increasing_sequence_fixed_or(n: int) -> list[int]",
            "description": "Find longest strictly increasing sequence a where each element <= n and a[i]|a[i-1] = n for all i >= 2. Return the sequence."
        },
        "judge": "def __judge(n: int, result: list[int]) -> bool:\n    if not result:\n        return False\n    if any(x < 1 or x > n for x in result):\n        return False\n    for i in range(1, len(result)):\n        if result[i] <= result[i-1]:\n            return False\n    for i in range(1, len(result)):\n        if (result[i] | result[i-1]) != n:\n            return False\n    m = bin(n).count('1')\n    expected_length = 1 if m == 1 else m + 1\n    return len(result) == expected_length",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, increasing_sequence_fixed_or(1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, increasing_sequence_fixed_or(3))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(14, increasing_sequence_fixed_or(14))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(23, increasing_sequence_fixed_or(23))"
            }
        ],
        "metadata": {
            "problem_id": "1988C",
            "url": "https://codeforces.com/problemset/problem/1988/C",
            "title": "Increasing Sequence with Fixed OR",
            "rating": 1300,
            "tags": [
                "bitmasks",
                "constructive algorithms",
                "greedy"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 512
        }
    },
    {
        "id": "and_reconstruction",
        "requirements": {
            "signature": "def and_reconstruction(n: int, b: list[int]) -> str",
            "description": "Given array b where b[i] = a[i] & a[i+1], reconstruct array a. Return space-separated integers or '-1' if impossible."
        },
        "judge": "def __judge(n: int, b: list[int], result: str) -> bool:\n    if result == '-1':\n        a = []\n        for i in range(n):\n            left = b[i - 1] if i > 0 else 0\n            right = b[i] if i < n - 1 else 0\n            a.append(left | right)\n        for i in range(n - 1):\n            if (a[i] & a[i + 1]) != b[i]:\n                return True\n        return False\n    try:\n        a = list(map(int, result.split()))\n    except:\n        return False\n    if len(a) != n:\n        return False\n    if any(x < 0 or x >= 2**30 for x in a):\n        return False\n    # Check AND condition\n    for i in range(n - 1):\n        if a[i] & a[i + 1] != b[i]:\n            return False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(2, [1], and_reconstruction(2, [1]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, [2, 0], and_reconstruction(3, [2, 0]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(4, [1, 2, 3], and_reconstruction(4, [1, 2, 3]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(5, [3, 5, 4, 2], and_reconstruction(5, [3, 5, 4, 2]))"
            }
        ],
        "metadata": {
            "problem_id": "1991B",
            "url": "https://codeforces.com/problemset/problem/1991/B",
            "title": "AND Reconstruction",
            "rating": 1100,
            "tags": [
                "bitmasks",
                "constructive algorithms",
                "greedy"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 1000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "absolute_zero",
        "requirements": {
            "signature": "def absolute_zero(n: int, a: list[int]) -> str",
            "description": "Make all elements zero using operations: choose x and replace each a[i] with |a[i]-x|. Return number of operations and values of x, or '-1' if impossible."
        },
        "judge": "def __judge(n: int, a: list[int], result: str) -> bool:\n    result = result.strip()\n    if result == '-1':\n        has_even = any(num % 2 == 0 for num in a)\n        has_odd = any(num % 2 == 1 for num in a)\n        return has_even and has_odd\n    lines = result.split('\\n')\n    if len(lines) != 2:\n        return False\n    try:\n        k = int(lines[0])\n        ops = list(map(int, lines[1].split()))\n    except:\n        return False\n    if k < 0 or k > 40 or len(ops) != k:\n        return False\n    if any(x < 0 or x > 10**9 for x in ops):\n        return False\n    arr = a[:]\n    for x in ops:\n        arr = [abs(ai - x) for ai in arr]\n    return all(x == 0 for x in arr)",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, [5], absolute_zero(1, [5]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(2, [0, 0], absolute_zero(2, [0, 0]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(3, [4, 6, 8], absolute_zero(3, [4, 6, 8]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(4, [80, 40, 20, 10], absolute_zero(4, [80, 40, 20, 10]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(5, [1, 2, 3, 4, 5], absolute_zero(5, [1, 2, 3, 4, 5]))"
            }
        ],
        "metadata": {
            "problem_id": "1991C",
            "url": "https://codeforces.com/problemset/problem/1991/C",
            "title": "Absolute Zero",
            "rating": 1300,
            "tags": [
                "constructive algorithms",
                "greedy",
                "math"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "prime_xor_coloring",
        "requirements": {
            "signature": "def prime_xor_coloring(n: int) -> tuple[int, list[int]]",
            "description": "Color vertices 1 to n where edge exists if XOR is prime. Return (num_colors, colors) where colors[i] is color of vertex i+1."
        },
        "judge": "def __judge(n:int,result:tuple[int,list[int]])->bool:\n    k,colors=result\n    if n==1: optimal_k=1\n    elif n==2: optimal_k=2\n    elif n==3: optimal_k=2\n    elif n==4: optimal_k=3\n    elif n==5: optimal_k=3\n    else: optimal_k=4\n    if k!=optimal_k: return False\n    if not isinstance(colors,(list,tuple)): return False\n    if len(colors)!=n: return False\n    if any((not isinstance(c,int)) or c<1 or c>k for c in colors): return False\n    import math\n    size=1\n    while size< n+1: size<<=1\n    sieve=bytearray(b'\\x01')*size\n    sieve[0:2]=b'\\x00\\x00'\n    limit=int(math.isqrt(size-1))\n    for i in range(2,limit+1):\n        if sieve[i]: sieve[i*i:size:i]=b'\\x00'*(((size-1-i*i)//i)+1)\n    primes=[i for i,is_p in enumerate(sieve) if is_p]\n    def fwht(a):\n        n2=len(a)\n        h=1\n        while h<n2:\n            step=h<<1\n            for i in range(0,n2,step):\n                for j in range(i,i+h):\n                    x=a[j]; y=a[j+h]\n                    a[j]=x+y; a[j+h]=x-y\n            h<<=1\n    for col_id in range(1,k+1):\n        arr=[0]*size\n        for i,c in enumerate(colors, start=1):\n            if c==col_id: arr[i]=1\n        fa=arr[:]\n        fwht(fa)\n        for i in range(len(fa)): fa[i]=fa[i]*fa[i]\n        fwht(fa)\n        for i in range(len(fa)): fa[i]//=size\n        for p in primes:\n            if fa[p]>0: return False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, prime_xor_coloring(1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(2, prime_xor_coloring(2))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(3, prime_xor_coloring(3))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(4, prime_xor_coloring(4))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(5, prime_xor_coloring(5))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(6, prime_xor_coloring(6))"
            }
        ],
        "metadata": {
            "problem_id": "1991D",
            "url": "https://codeforces.com/problemset/problem/1991/D",
            "title": "Prime XOR Coloring",
            "rating": 1900,
            "tags": [
                "bitmasks",
                "constructive algorithms",
                "graphs",
                "greedy",
                "math",
                "number theory"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "grid_reset",
        "requirements": {
            "signature": "def grid_reset(n: int, m: int, k: int, ops: str) -> str",
            "description": "Process H (horizontal 1×k) and V (vertical k×1) operations on n×m grid. Return '-1' if impossible, else k lines of 'c i j' for each operation."
        },
        "judge": "def __judge(n: int, m: int, k: int, ops: str, result: str) -> bool:\n    if result == '-1':\n        return False\n    lines = [ln.strip() for ln in result.strip().splitlines() if ln.strip() != \"\"]\n    if len(lines) != len(ops):\n        return False\n    grid = [[False] * m for _ in range(n)]\n    for step, (op_char, line) in enumerate(zip(ops, lines), start=1):\n        parts = line.split()\n        if len(parts) != 2:\n            return False\n        try:\n            i = int(parts[0])\n            j = int(parts[1])\n        except ValueError:\n            return False\n        if not (1 <= i <= n and 1 <= j <= m):\n            return False\n        r0 = i - 1\n        c0 = j - 1\n        if op_char == 'H':\n            if c0 + k - 1 >= m:\n                return False\n            for c in range(c0, c0 + k):\n                if grid[r0][c]:\n                    return False\n            for c in range(c0, c0 + k):\n                grid[r0][c] = True\n        elif op_char == 'V':\n            if r0 + k - 1 >= n:\n                return False\n            for r in range(r0, r0 + k):\n                if grid[r][c0]:\n                    return False\n            for r in range(r0, r0 + k):\n                grid[r][c0] = True\n        else:\n            return False\n        full_rows = [r for r in range(n) if all(grid[r][c] for c in range(m))]\n        full_cols = [c for c in range(m) if all(grid[r][c] for r in range(n))]\n        if full_rows or full_cols:\n            for r in full_rows:\n                for c in range(m):\n                    grid[r][c] = False\n            for c in full_cols:\n                for r in range(n):\n                    grid[r][c] = False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(4, 5, 3, 'HVVHHV', grid_reset(4, 5, 3, 'HVVHHV'))"
            }
        ],
        "metadata": {
            "problem_id": "1991G",
            "url": "https://codeforces.com/problemset/problem/1991/G",
            "title": "Grid Reset",
            "rating": 2700,
            "tags": [
                "constructive algorithms",
                "greedy",
                "implementation"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "gorilla_and_permutation",
        "requirements": {
            "signature": "def gorilla_and_permutation(n: int, m: int, k: int) -> list[int]",
            "description": "Construct permutation of length n maximizing f(i)-g(i) where f(i) is sum of prefix elements >= k, g(i) is sum of prefix elements <= m."
        },
        "judge": "def __judge(n: int, m: int, k: int, result: list[int]) -> bool:\n    if len(result) != n:\n        return False\n    if sorted(result) != list(range(1, n + 1)):\n        return False\n    std_perm = list(range(n, m, -1)) + list(range(1, m + 1))\n    def compute_score(perm):\n        score = 0\n        for idx, num in enumerate(perm):\n            pos = idx + 1\n            if num >= k:\n                score += num * (n - pos + 1)\n            if num <= m:\n                score -= num * (n - pos + 1)\n        return score\n    given_score = compute_score(result)\n    optimal_score = compute_score(std_perm)\n    return given_score == optimal_score",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(5, 2, 5, gorilla_and_permutation(5, 2, 5))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, 1, 3, gorilla_and_permutation(3, 1, 3))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(10, 3, 8, gorilla_and_permutation(10, 3, 8))"
            }
        ],
        "metadata": {
            "problem_id": "1992C",
            "url": "https://codeforces.com/problemset/problem/1992/C",
            "title": "Gorilla and Permutation",
            "rating": 900,
            "tags": [
                "constructive algorithms",
                "math"
            ],
            "div": "Div. 3",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "stardew_valley",
        "requirements": {
            "signature": "def stardew_valley(n: int, m: int, edges: list[tuple[int, int, int]]) -> str",
            "description": "Find cyclic route visiting each NPC road exactly once. Return 'NO' if impossible, else 'YES\\nk\\nroute' where route has k+1 houses."
        },
        "judge": "def __judge(n: int, m: int, edges: list, result: str) -> bool:\n    from collections import defaultdict\n    lines = result.strip().split('\\n')\n    if not lines:\n        return False\n    first = lines[0].strip().upper()\n    def exists_solution():\n        edg = [0]*m\n        g = [[] for _ in range(n)]\n        black = [[] for _ in range(n)]\n        for i in range(m):\n            u,v,c = edges[i]\n            u -= 1; v -= 1\n            edg[i] = u ^ v\n            g[u].append(i); g[v].append(i)\n            if c == 0:\n                black[u].append(i); black[v].append(i)\n        deg = [len(g[i]) & 1 for i in range(n)]\n        removed = [False]*m\n        usedv = [False]*n\n        import sys\n        sys.setrecursionlimit(1000000)\n        def dfs(u):\n            usedv[u] = True\n            for id in black[u]:\n                to = edg[id] ^ u\n                if usedv[to]: continue\n                dfs(to)\n                if deg[to]:\n                    removed[id] = True\n                    deg[to] ^= 1\n                    deg[u] ^= 1\n        ok = True\n        for i in range(n):\n            if not usedv[i]:\n                dfs(i)\n                if deg[i]:\n                    ok = False\n        if not ok:\n            return False\n        used_edge = [False]*m\n        start = 0\n        for i in range(n):\n            for id in g[i]:\n                if not removed[id]:\n                    start = i; break\n            else:\n                continue\n            break\n        it = [list(lst) for lst in g]\n        path = []\n        stack = [start]\n        while stack:\n            v = stack[-1]\n            while it[v] and (removed[it[v][-1]] or used_edge[it[v][-1]]):\n                it[v].pop()\n            if not it[v]:\n                path.append(v)\n                stack.pop()\n            else:\n                id = it[v].pop()\n                used_edge[id] = True\n                to = edg[id] ^ v\n                stack.append(to)\n        for i in range(m):\n            if not removed[i] and not used_edge[i]:\n                return False\n        return True\n    if first == 'NO':\n        return not exists_solution()\n    if first != 'YES' or len(lines) < 3:\n        return False\n    try:\n        k = int(lines[1].strip())\n    except:\n        return False\n    try:\n        route = list(map(int, lines[2].strip().split()))\n    except:\n        return False\n    if len(route) != k + 1 or route[0] != route[-1]:\n        return False\n    for house in route:\n        if not (1 <= house <= n):\n            return False\n    adj = [defaultdict(list) for _ in range(n + 1)]\n    used = [False] * m\n    for idx in range(m):\n        u, v, c = edges[idx]\n        adj[u][v].append(idx)\n        adj[v][u].append(idx)\n    for i in range(k):\n        a = route[i]\n        b = route[i + 1]\n        if b not in adj[a]:\n            return False\n        found = False\n        while adj[a][b]:\n            idx = adj[a][b].pop()\n            if not used[idx]:\n                used[idx] = True\n                found = True\n                break\n        if not found:\n            return False\n    for idx in range(m):\n        u, v, c = edges[idx]\n        if c == 1 and not used[idx]:\n            return False\n    return True\n",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, 2, [(1, 2, 1), (2, 3, 1)], stardew_valley(3, 2, [(1, 2, 1), (2, 3, 1)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, 3, [(1, 2, 1), (1, 3, 1), (2, 3, 0)], stardew_valley(3, 3, [(1, 2, 1), (1, 3, 1), (2, 3, 0)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(5, 9, [(1, 2, 0), (5, 2, 1), (5, 4, 1), (5, 1, 1), (2, 3, 1), (5, 2, 1), (4, 1, 0), (4, 3, 0), (5, 2, 0)], stardew_valley(5, 9, [(1, 2, 0), (5, 2, 1), (5, 4, 1), (5, 1, 1), (2, 3, 1), (5, 2, 1), (4, 1, 0), (4, 3, 0), (5, 2, 0)]))"
            }
        ],
        "metadata": {
            "problem_id": "1994F",
            "url": "https://codeforces.com/problemset/problem/1994/F",
            "title": "Stardew Valley",
            "rating": 2500,
            "tags": [
                "constructive algorithms",
                "dfs and similar",
                "graphs",
                "trees"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "strong_password",
        "requirements": {
            "signature": "def strong_password(s: str) -> str",
            "description": "Insert one lowercase letter into password s to maximize typing time. First char takes 2 seconds, subsequent chars take 1 second if same as previous, 2 otherwise."
        },
        "judge": "def __judge(s: str, result: str) -> bool:\n    if len(result) != len(s) + 1:\n        return False\n    if not all('a' <= c <= 'z' for c in result):\n        return False\n    valid_insertion = False\n    for i in range(len(result)):\n        if result[:i] + result[i+1:] == s:\n            valid_insertion = True\n            break\n    if not valid_insertion:\n        return False\n    def typing_time(x: str) -> int:\n        p = sum(1 for i in range(1, len(x)) if x[i] == x[i-1])\n        return 2 * len(x) - p\n    res_time = typing_time(result)\n    best_time = -1\n    for i in range(len(s) + 1):\n        for code in range(ord('a'), ord('z') + 1):\n            cand = s[:i] + chr(code) + s[i:]\n            t = typing_time(cand)\n            if t > best_time:\n                best_time = t\n    return res_time == best_time",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge('a', strong_password('a'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge('aaa', strong_password('aaa'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge('abb', strong_password('abb'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge('password', strong_password('password'))"
            }
        ],
        "metadata": {
            "problem_id": "1997A",
            "url": "https://codeforces.com/problemset/problem/1997/A",
            "title": "Strong Password",
            "rating": 800,
            "tags": [
                "brute force",
                "implementation",
                "strings"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 512
        }
    },
    {
        "id": "find_k_distinct_points",
        "requirements": {
            "signature": "def find_k_distinct_points(xc: int, yc: int, k: int) -> list[tuple[int, int]]",
            "description": "Find k distinct integer points whose center is (xc, yc). Return list of (x, y) tuples."
        },
        "judge": "def __judge(xc: int, yc: int, k: int, result: list[tuple[int, int]]) -> bool:\n    if len(result) != k:\n        return False\n    if len(set(result)) != k:  # Check distinct\n        return False\n    # Check all coordinates are within bounds\n    for x, y in result:\n        if not (-10**9 <= x <= 10**9 and -10**9 <= y <= 10**9):\n            return False\n    # Check center\n    sum_x = sum(x for x, y in result)\n    sum_y = sum(y for x, y in result)\n    return sum_x == k * xc and sum_y == k * yc",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(10, 10, 1, find_k_distinct_points(10, 10, 1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(0, 0, 3, find_k_distinct_points(0, 0, 3))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(-5, -8, 8, find_k_distinct_points(-5, -8, 8))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(4, -5, 3, find_k_distinct_points(4, -5, 3))"
            }
        ],
        "metadata": {
            "problem_id": "1998A",
            "url": "https://codeforces.com/problemset/problem/1998/A",
            "title": "Find K Distinct Points with Fixed Center",
            "rating": 800,
            "tags": [
                "constructive algorithms",
                "implementation",
                "math"
            ],
            "div": "Div. 2",
            "time_limit_ms": 1000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "slavics_exam",
        "requirements": {
            "signature": "def slavics_exam(s: str, t: str) -> str",
            "description": "Replace each '?' in s with a lowercase letter so that t becomes a subsequence. Return modified string or 'NO' if impossible."
        },
        "judge": "def __judge(s: str, t: str, result: str) -> bool:\n    if result == \"NO\":\n        j = 0\n        for c in s:\n            if c == '?':\n                if j < len(t):\n                    j += 1\n            elif j < len(t) and c == t[j]:\n                j += 1\n        return j < len(t)\n    else:\n        if len(result) != len(s):\n            return False\n        for i in range(len(s)):\n            sc = s[i]\n            rc = result[i]\n            if sc != '?' and sc != rc:\n                return False\n            if sc == '?' and not ('a' <= rc <= 'z'):\n                return False\n        j = 0\n        for c in result:\n            if j < len(t) and c == t[j]:\n                j += 1\n        return j == len(t)",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge('?????', 'xbx', slavics_exam('?????', 'xbx'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge('ab??e', 'abcde', slavics_exam('ab??e', 'abcde'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge('ayy?x', 'a', slavics_exam('ayy?x', 'a'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge('ab??e', 'dac', slavics_exam('ab??e', 'dac'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge('paiu', 'mom', slavics_exam('paiu', 'mom'))"
            }
        ],
        "metadata": {
            "problem_id": "1999D",
            "url": "https://codeforces.com/problemset/problem/1999/D",
            "title": "Slavic's Exam",
            "rating": 1100,
            "tags": [
                "greedy",
                "implementation",
                "strings"
            ],
            "div": "Div. 4",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "generate_permutation",
        "requirements": {
            "signature": "def generate_permutation(n: int) -> list[int]",
            "description": "Find permutation where minimum carriage returns needed is same for both left-to-right and right-to-left typewriters. Return permutation or [-1] if impossible."
        },
        "judge": "def __judge(n: int, result: list[int]) -> bool:\n    if result == [-1]:\n        return n % 2 == 0\n    if len(result) != n:\n        return False\n    if sorted(result) != list(range(1, n + 1)):\n        return False\n    pos = [0] * (n + 1)\n    for idx in range(n):\n        pos[result[idx]] = idx\n    c1 = sum(1 for x in range(1, n) if pos[x] > pos[x + 1])\n    c2 = sum(1 for x in range(1, n) if pos[x] < pos[x + 1])\n    return c1 == c2",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, generate_permutation(1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(2, generate_permutation(2))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(3, generate_permutation(3))"
            }
        ],
        "metadata": {
            "problem_id": "2001B",
            "url": "https://codeforces.com/problemset/problem/2001/B",
            "title": "Generate Permutation",
            "rating": 800,
            "tags": [
                "constructive algorithms"
            ],
            "div": "Div. 2",
            "time_limit_ms": 1500,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "turtle_and_good_pairs",
        "requirements": {
            "signature": "def turtle_and_good_pairs(n: int, s: str) -> str",
            "description": "Reorder string s to maximize good pairs. A pair (i,j) is good if s[i]=s[j] or it's a pleasant pair (has index k where s[k]!=s[k+1] and conditions hold)."
        },
        "judge": "def __judge(n: int, s: str, result: str) -> bool:\n    if len(result) != n: return False\n    cnt_s = [0] * 26\n    cnt_result = [0] * 26\n    for c in s:\n        cnt_s[ord(c) - 97] += 1\n    for c in result:\n        cnt_result[ord(c) - 97] += 1\n    if cnt_s != cnt_result: return False\n    if not result: return True\n    runs = []\n    current_char, count = result[0], 1\n    for c in result[1:]:\n        if c == current_char:\n            count += 1\n        else:\n            runs.append(count)\n            current_char, count = c, 1\n    runs.append(count)\n    m = len(runs)\n    total = 0\n    if m == 1:\n        return total == 0\n    else:\n        for i in range(m - 1):\n            total += runs[i] * runs[i + 1]\n    return total == n - 1",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, 'abc', turtle_and_good_pairs(3, 'abc'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(5, 'edddf', turtle_and_good_pairs(5, 'edddf'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(6, 'turtle', turtle_and_good_pairs(6, 'turtle'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(8, 'pppppppp', turtle_and_good_pairs(8, 'pppppppp'))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(10, 'codeforces', turtle_and_good_pairs(10, 'codeforces'))"
            }
        ],
        "metadata": {
            "problem_id": "2003C",
            "url": "https://codeforces.com/problemset/problem/2003/C",
            "title": "Turtle and Good Pairs",
            "rating": 1200,
            "tags": [
                "constructive algorithms",
                "greedy",
                "sortings",
                "strings"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "concatenation_of_arrays",
        "requirements": {
            "signature": "def concatenation_of_arrays(n: int, arrays: list[tuple[int, int]]) -> list[int]",
            "description": "Concatenate n arrays of length 2 to minimize inversions. Return the concatenated array."
        },
        "judge": "def __judge(n: int, arrays: list[tuple[int, int]], result: list[int]) -> bool:\n    if len(result) != 2 * n:\n        return False\n    from collections import Counter\n    arr_counter = Counter(arrays)\n    for i in range(0, 2 * n, 2):\n        pair = (result[i], result[i+1])\n        if pair not in arr_counter or arr_counter[pair] == 0:\n            return False\n        arr_counter[pair] -= 1\n    if any(v != 0 for v in arr_counter.values()):\n        return False\n    def count_inversions(arr: list[int]) -> int:\n        if not arr:\n            return 0\n        vals = sorted(set(arr))\n        rank = {v: i+1 for i, v in enumerate(vals)}\n        size = len(vals)\n        bit = [0] * (size + 1)\n        def bit_add(i: int, delta: int) -> None:\n            while i <= size:\n                bit[i] += delta\n                i += i & -i\n        def bit_sum(i: int) -> int:\n            s = 0\n            while i > 0:\n                s += bit[i]\n                i -= i & -i\n            return s\n        inv = 0\n        seen = 0\n        for x in arr:\n            r = rank[x]\n            inv += seen - bit_sum(r)\n            bit_add(r, 1)\n            seen += 1\n        return inv\n    result_inversions = count_inversions(result)\n    sorted_arrays = sorted(arrays, key=lambda x: x[0] + x[1])\n    optimal = []\n    for arr in sorted_arrays:\n        optimal.extend(arr)\n    optimal_inversions = count_inversions(optimal)\n    return result_inversions == optimal_inversions",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(2, [(1, 4), (2, 3)], concatenation_of_arrays(2, [(1, 4), (2, 3)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, [(3, 2), (4, 3), (2, 1)], concatenation_of_arrays(3, [(3, 2), (4, 3), (2, 1)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(5, [(5, 10), (2, 3), (9, 6), (4, 1), (8, 7)], concatenation_of_arrays(5, [(5, 10), (2, 3), (9, 6), (4, 1), (8, 7)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(1, [(10, 20)], concatenation_of_arrays(1, [(10, 20)]))"
            }
        ],
        "metadata": {
            "problem_id": "2023A",
            "url": "https://codeforces.com/problemset/problem/2023/A",
            "title": "Concatenation of Arrays",
            "rating": 1300,
            "tags": [
                "constructive algorithms",
                "greedy",
                "math",
                "sortings"
            ],
            "div": "Div. 1",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "choose_your_queries",
        "requirements": {
            "signature": "def choose_your_queries(n: int, queries: list[tuple[int, int]]) -> list[str]",
            "description": "Process q queries on array of n zeros. Each query: choose p from {x,y} and d from {-1,1}, add d to a[p]. Keep all elements non-negative. Return list of 'x+', 'x-', 'y+', or 'y-' for each query."
        },
        "judge": "def __judge(n: int, queries: list[tuple[int, int]], result: list[str]) -> bool:\n    if len(result) != len(queries):\n        return False\n    a = [0] * n\n    for i, (x, y) in enumerate(queries):\n        choice = result[i]\n        if choice not in ['x+', 'x-', 'y+', 'y-']:\n            return False\n        p = x - 1 if choice[0] == 'x' else y - 1\n        delta = 1 if choice[1] == '+' else -1\n        a[p] += delta\n        if a[p] < 0:\n            return False\n    actual_sum = sum(a)\n    parent = list(range(n))\n    rank = [0] * n\n    for x, y in queries:\n        u = x - 1\n        v = y - 1\n        root_u = u\n        while parent[root_u] != root_u:\n            parent[root_u] = parent[parent[root_u]]\n            root_u = parent[root_u]\n        root_v = v\n        while parent[root_v] != root_v:\n            parent[root_v] = parent[parent[root_v]]\n            root_v = parent[root_v]\n        if root_u != root_v:\n            if rank[root_u] > rank[root_v]:\n                parent[root_v] = root_u\n            else:\n                parent[root_u] = root_v\n                if rank[root_u] == rank[root_v]:\n                    rank[root_v] += 1\n    counts = {}\n    for x, y in queries:\n        u = x - 1\n        v = y - 1\n        root_u = u\n        while parent[root_u] != root_u:\n            root_u = parent[root_u]\n        counts[root_u] = counts.get(root_u, 0) + 1\n    S = 0\n    for cnt in counts.values():\n        if cnt % 2 == 1:\n            S += 1\n    return actual_sum == S",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, [(1, 2), (3, 2), (3, 1), (1, 2)], choose_your_queries(3, [(1, 2), (3, 2), (3, 1), (1, 2)]))"
            }
        ],
        "metadata": {
            "problem_id": "2025F",
            "url": "https://codeforces.com/problemset/problem/2025/F",
            "title": "Choose Your Queries",
            "rating": 2700,
            "tags": [
                "constructive algorithms",
                "dfs and similar",
                "dp",
                "graphs",
                "greedy",
                "trees"
            ],
            "div": "Div. 2",
            "time_limit_ms": 3000,
            "memory_limit_mb": 512
        }
    },
    {
        "id": "perpendicular_segments",
        "requirements": {
            "signature": "def perpendicular_segments(X: int, Y: int, K: int) -> tuple[int, int, int, int, int, int, int, int]",
            "description": "Find two perpendicular line segments AB and CD with integer coordinates in [0,X]×[0,Y], each with length at least K. Return (Ax, Ay, Bx, By, Cx, Cy, Dx, Dy)."
        },
        "judge": "def __judge(X: int, Y: int, K: int, result: tuple[int, int, int, int, int, int, int, int]) -> bool:\n    Ax, Ay, Bx, By, Cx, Cy, Dx, Dy = result\n    for coord in [Ax, Bx, Cx, Dx]:\n        if not (0 <= coord <= X):\n            return False\n    for coord in [Ay, By, Cy, Dy]:\n        if not (0 <= coord <= Y):\n            return False\n    len_AB_squared = (Bx - Ax)**2 + (By - Ay)**2\n    len_CD_squared = (Dx - Cx)**2 + (Dy - Cy)**2\n    if len_AB_squared < K*K or len_CD_squared < K*K:\n        return False\n    vec_AB = (Bx - Ax, By - Ay)\n    vec_CD = (Dx - Cx, Dy - Cy)\n    if vec_AB == (0, 0) or vec_CD == (0, 0):\n        return False\n    dot_product = vec_AB[0] * vec_CD[0] + vec_AB[1] * vec_CD[1]\n    return dot_product == 0",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, 1, 1, perpendicular_segments(1, 1, 1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, 4, 1, perpendicular_segments(3, 4, 1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(4, 3, 3, perpendicular_segments(4, 3, 3))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(3, 4, 4, perpendicular_segments(3, 4, 4))"
            }
        ],
        "metadata": {
            "problem_id": "2026A",
            "url": "https://codeforces.com/problemset/problem/2026/A",
            "title": "Perpendicular Segments",
            "rating": 900,
            "tags": [
                "constructive algorithms",
                "geometry",
                "greedy",
                "math"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "alices_adventures_in_cards",
        "requirements": {
            "signature": "def alices_adventures_in_cards(n: int, q: list[int], k: list[int], j: list[int]) -> str",
            "description": "Alice has card 1, needs card n. Can trade with Queen/King/Jack based on preferences. Return 'NO' if impossible, else 'YES\\nk\\n' followed by k lines of trades 'c x'."
        },
        "judge": "def __judge(n: int, q: list[int], k: list[int], j: list[int], result: str) -> bool:\n    lines = result.strip().split('\\n')\n    if not lines:\n        return False\n    first_line = lines[0].upper()\n    prefs = [q, k, j]\n    \n    if first_line == 'NO':\n        if n == 1:\n            return False  # Alice starts at 1 and wants 1, so NO is invalid\n        # Compute if solution exists using AC logic\n        mins = [n] * 3\n        sol = [None] * (n + 2)\n        for i in range(n-1, 0, -1):\n            win = -1\n            for j_idx in range(3):\n                pref_i = prefs[j_idx][i-1]\n                pref_mins = prefs[j_idx][mins[j_idx]-1]\n                if pref_i > pref_mins:\n                    win = j_idx\n                    break\n            if win != -1:\n                sol[i] = win\n                for j_idx in range(3):\n                    pref_i = prefs[j_idx][i-1]\n                    pref_mins = prefs[j_idx][mins[j_idx]-1]\n                    if pref_i < pref_mins:\n                        mins[j_idx] = i\n        return sol[1] is None\n    \n    elif first_line != 'YES':\n        return False\n    \n    if len(lines) < 2:\n        return False\n    try:\n        num_trades = int(lines[1])\n    except:\n        return False\n    if len(lines) != num_trades + 2:\n        return False\n    \n    current_card = 1\n    trades = lines[2:]\n    for trade in trades:\n        parts = trade.strip().split()\n        if len(parts) != 2:\n            return False\n        player, x_str = parts\n        player = player.lower()\n        if player not in ['q', 'k', 'j']:\n            return False\n        try:\n            x = int(x_str)\n        except:\n            return False\n        if x < 1 or x > n or x <= current_card:\n            return False\n        j_idx = -1\n        if player == 'q':\n            j_idx = 0\n        elif player == 'k':\n            j_idx = 1\n        else:\n            j_idx = 2\n        a = current_card\n        b = x\n        if prefs[j_idx][a-1] <= prefs[j_idx][b-1]:\n            return False\n        current_card = x\n    return current_card == n",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, [1, 3, 2], [2, 1, 3], [1, 2, 3], alices_adventures_in_cards(3, [1, 3, 2], [2, 1, 3], [1, 2, 3]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(4, [2, 3, 1, 4], [1, 2, 3, 4], [1, 4, 2, 3], alices_adventures_in_cards(4, [2, 3, 1, 4], [1, 2, 3, 4], [1, 4, 2, 3]))"
            }
        ],
        "metadata": {
            "problem_id": "2028D",
            "url": "https://codeforces.com/problemset/problem/2028/D",
            "title": "Alice's Adventures in Cards",
            "rating": 2000,
            "tags": [
                "constructive algorithms",
                "divide and conquer",
                "dp",
                "graphs",
                "greedy",
                "implementation",
                "sortings",
                "two pointers"
            ],
            "div": "Div. 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "cool_graph",
        "requirements": {
            "signature": "def cool_graph(n: int, edges: list[tuple[int, int]]) -> list[tuple[int, int, int]]",
            "description": "Make graph cool (no edges or tree) using triangle operations. Each operation on vertices (a,b,c) toggles edges (a,b), (b,c), (c,a). Return list of operations."
        },
        "judge": "def __judge(n: int, edges: list[tuple[int, int]], operations: list[tuple[int, int, int]]) -> bool:\n    from collections import deque\n    if len(operations) > 2 * max(n, len(edges)):\n        return False\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n    for a, b, c in operations:\n        if len({a, b, c}) != 3:\n            return False\n        if not all(1 <= x <= n for x in [a, b, c]):\n            return False\n        a0, b0, c0 = a-1, b-1, c-1\n        for u, v in [(a0, b0), (b0, c0), (c0, a0)]:\n            if v in adj[u]:\n                adj[u].remove(v)\n                adj[v].remove(u)\n            else:\n                adj[u].add(v)\n                adj[v].add(u)\n    edge_count = sum(len(lst) for lst in adj) // 2\n    if edge_count not in (0, n-1):\n        return False\n    if edge_count == 0:\n        return True\n    visited = [False]*n\n    q = deque()\n    for i in range(n):\n        if len(adj[i]) > 0:\n            q.append(i)\n            visited[i] = True\n            break\n    count = 0\n    while q:\n        u = q.popleft()\n        count += 1\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append(v)\n    return count == n",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, [], cool_graph(3, []))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, [(1, 2)], cool_graph(3, [(1, 2)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(3, [(1, 2), (2, 3)], cool_graph(3, [(1, 2), (2, 3)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(3, [(1, 2), (2, 3), (3, 1)], cool_graph(3, [(1, 2), (2, 3), (3, 1)]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(6, [(1, 2), (1, 6), (4, 5), (3, 4), (4, 6), (3, 6)], cool_graph(6, [(1, 2), (1, 6), (4, 5), (3, 4), (4, 6), (3, 6)]))"
            }
        ],
        "metadata": {
            "problem_id": "2029D",
            "url": "https://codeforces.com/problemset/problem/2029/D",
            "title": "Cool Graph",
            "rating": 1900,
            "tags": [
                "constructive algorithms",
                "data structures",
                "dfs and similar",
                "graphs",
                "trees"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 3000,
            "memory_limit_mb": 512
        }
    },
    {
        "id": "common_generator",
        "requirements": {
            "signature": "def common_generator(n: int, a: list[int]) -> int",
            "description": "Find x>=2 that can generate all elements in array a by repeatedly adding divisors. Return x or -1 if impossible."
        },
        "judge": "def __judge(n: int, a: list[int], x: int) -> bool:\n    if x < 2:\n        return False\n    if any(y < x for y in a):\n        return False\n    max_v = max(a)\n    spf = [0] * (max_v + 1)\n    for i in range(2, max_v + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            ii = i * i\n            if ii <= max_v:\n                for j in range(ii, max_v + 1, i):\n                    if spf[j] == 0:\n                        spf[j] = i\n    from collections import deque\n    visited = [False] * (max_v + 1)\n    q = deque([x])\n    visited[x] = True\n    def gen_divisors(val):\n        res = [1]\n        v = val\n        while v > 1:\n            p = spf[v]\n            if p == 0:\n                p = v\n            cnt = 0\n            while v % p == 0:\n                v //= p\n                cnt += 1\n            cur = []\n            powp = 1\n            for _ in range(cnt + 1):\n                for r in res:\n                    cur.append(r * powp)\n                powp *= p\n            res = cur\n        for d in res:\n            if d >= 2:\n                yield d\n    while q:\n        v = q.popleft()\n        for d in gen_divisors(v):\n            nv = v + d\n            if nv <= max_v and not visited[nv]:\n                visited[nv] = True\n                q.append(nv)\n    for y in a:\n        if not visited[y]:\n            return False\n    return True",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(3, [8, 9, 10], common_generator(3, [8, 9, 10]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(4, [2, 3, 4, 5], common_generator(4, [2, 3, 4, 5]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(2, [147, 154], common_generator(2, [147, 154]))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(5, [3, 6, 8, 25, 100000], common_generator(5, [3, 6, 8, 25, 100000]))"
            }
        ],
        "metadata": {
            "problem_id": "2029E",
            "url": "https://codeforces.com/problemset/problem/2029/E",
            "title": "Common Generator",
            "rating": 2100,
            "tags": [
                "brute force",
                "math",
                "number theory"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 512
        }
    },
    {
        "id": "minimise_oneness",
        "requirements": {
            "signature": "def minimise_oneness(n: int) -> str",
            "description": "Construct binary string of length n minimizing |f(t)-g(t)| where f(t) is count of all-0 subsequences, g(t) is count of subsequences with at least one 1."
        },
        "judge": "def __judge(n: int, result: str) -> bool:\n    if len(result) != n:\n        return False\n    if not all(c in '01' for c in result):\n        return False\n    count0 = result.count('0')\n    count1 = result.count('1')\n    f_val = (1 << count0) - 1\n    g_val = (1 << n) - 1 - f_val\n    oneness = abs(f_val - g_val)\n    return oneness == 1",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, minimise_oneness(1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(2, minimise_oneness(2))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(3, minimise_oneness(3))"
            }
        ],
        "metadata": {
            "problem_id": "2030B",
            "url": "https://codeforces.com/problemset/problem/2030/B",
            "title": "Minimise Oneness",
            "rating": 800,
            "tags": [
                "combinatorics",
                "constructive algorithms",
                "games",
                "math"
            ],
            "div": "Div. 2",
            "time_limit_ms": 1500,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "medians_2032",
        "requirements": {
            "signature": "def medians_2032(n: int, k: int) -> str",
            "description": "Split array [1,2,...,n] into odd-length subarrays where median of medians equals k. Return '-1' if impossible, else 'm\\nborders' where borders are left indices."
        },
        "judge": "def __judge(n: int, k: int, result: str) -> bool:\n    if result.strip() == '-1': return (n >1) and (k ==1 or k == n)\n    lines = result.strip().split('\\n')\n    if len(lines)!=2: return False\n    try:\n        m = int(lines[0])\n        if m % 2 == 0: return False\n        p = list(map(int, lines[1].split()))\n        if len(p)!=m: return False\n        if p[0]!=1: return False\n        for i in range(1, m):\n            if p[i]<=p[i-1]: return False\n        if p[-1]>n: return False\n    except: return False\n    starts = p\n    ends = []\n    for i in range(m-1): ends.append(p[i+1]-1)\n    ends.append(n)\n    for i in range(m):\n        s = starts[i]\n        e = ends[i]\n        if s>e or e>n: return False\n        if (e - s +1) %2 ==0: return False\n    medians = []\n    for i in range(m):\n        s = starts[i]\n        e = ends[i]\n        mid = (s + e) //2\n        medians.append(mid)\n    medians.sort()\n    return medians[len(medians)//2] ==k",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(1, 1, medians_2032(1, 1))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(3, 2, medians_2032(3, 2))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(3, 3, medians_2032(3, 3))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(15, 8, medians_2032(15, 8))"
            }
        ],
        "metadata": {
            "problem_id": "2032B",
            "url": "https://codeforces.com/problemset/problem/2032/B",
            "title": "Medians",
            "rating": 1100,
            "tags": [
                "constructive algorithms",
                "greedy",
                "implementation",
                "math"
            ],
            "div": "Div. 2",
            "time_limit_ms": 1000,
            "memory_limit_mb": 256
        }
    },
    {
        "id": "alya_and_permutation",
        "requirements": {
            "signature": "def alya_and_permutation(n: int) -> tuple[int, list[int]]",
            "description": "Construct permutation of [1,2,...,n] maximizing k after alternating AND/OR operations. Return (max_k, permutation)."
        },
        "judge": "def __judge(n: int, result: tuple[int, list[int]]) -> bool:\n    max_k, perm = result\n    if len(perm) != n: return False\n    if sorted(perm) != list(range(1, n + 1)): return False\n    k_calculated = 0\n    for i in range(n):\n        if i % 2 == 0: k_calculated &= perm[i]\n        else: k_calculated |= perm[i]\n    if k_calculated != max_k: return False\n    if n % 2 == 1: theoretical = n\n    else:\n        po2 = 1\n        while po2 * 2 <= n: po2 *= 2\n        theoretical = 2 * po2 - 1\n    return max_k == theoretical",
        "tests": [
            {
                "type": "TestFunction",
                "code": "def test_1():\n    assert __judge(5, alya_and_permutation(5))"
            },
            {
                "type": "TestFunction",
                "code": "def test_2():\n    assert __judge(6, alya_and_permutation(6))"
            },
            {
                "type": "TestFunction",
                "code": "def test_3():\n    assert __judge(7, alya_and_permutation(7))"
            },
            {
                "type": "TestFunction",
                "code": "def test_4():\n    assert __judge(8, alya_and_permutation(8))"
            },
            {
                "type": "TestFunction",
                "code": "def test_5():\n    assert __judge(9, alya_and_permutation(9))"
            },
            {
                "type": "TestFunction",
                "code": "def test_6():\n    assert __judge(10, alya_and_permutation(10))"
            }
        ],
        "metadata": {
            "problem_id": "2035C",
            "url": "https://codeforces.com/problemset/problem/2035/C",
            "title": "Alya and Permutation",
            "rating": 1400,
            "tags": [
                "bitmasks",
                "constructive algorithms",
                "math"
            ],
            "div": "Div. 1 + 2",
            "time_limit_ms": 2000,
            "memory_limit_mb": 256
        }
    }
]